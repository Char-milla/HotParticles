--[[============================================================
--=
--=  GUI panel
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

export PANEL_WIDTH :: LABEL_WIDTH + 300

local LABEL_WIDTH   :: 110
local PANEL_SPACING :: 3

local GUIDE_LINE_OPACITY           :: .2
local HOVER_OUTLINE_OPACITY        :: .3
local HOVER_OUTLINE_OPACITY_STRONG :: .5

local CONTEXT_MENU_MIN_WIDTH :: 120
local CONTEXT_MENU_PADDING_X :: 15
local CONTEXT_MENU_PADDING_Y :: 5

local BUTTON_LABELS_YES_NO :: {"yes", "no"}



export pressedOnPanelWithMouseButton = 0

export draggedPanelItem    = 0
export draggedPanelSubItem = 0

export contextMenu: ContextMenu = NULL

local clipboardScalar: float   = NULL
local clipboardAngle:  float   = NULL
local clipboardColor:  []float = NULL -- {h,s,v,a}

local panelItemToPasteAt = 0
local pasteTarget        = 0 -- E.g. "the hue" in a color.



local PanelState :: struct {
	panelY:     int,
	lastPanelY: int,

	panelItem: int,

	fontH: int,

	mx: int,
	my: int,
	myScrolled: int,
	ignoreMouseAboveY = 0,

	mod: ModifierKey = NULL,

	showedContextMenuThisFrame = false,
}

export ContextMenu :: struct {
	x:        int,
	y:        int,
	width:    int,
	height:   int,
	items:    []string,
	callback: (choice:int) = NULL,
}



local showContextMenu :: (state:PanelState, items:[]string, cb:type_of(ContextMenu.callback)) {
	local w = 0
	local h = #items * (fontNormal.getHeight!() + 2*CONTEXT_MENU_PADDING_Y)

	for items  w = math.max(w, fontNormal.getWidth!(it))
	w = math.max(w+2*CONTEXT_MENU_PADDING_X, CONTEXT_MENU_MIN_WIDTH)

	local x, y  = love.mouse.getPosition()
	y          += 2

	x = math.min(x, LG.getWidth()-w)
	if y+h > LG.getHeight()  y -= h+4

	contextMenu = {
		x        = x,
		y        = y,
		width    = w,
		height   = h,
		items    = items,
		callback = cb,
	}
	state.showedContextMenuThisFrame = true
}



export isInsideContextMenu :: (mx,my:int) -> bool {
	return contextMenu ~= NULL
		and mx >= contextMenu.x
		and my >= contextMenu.y
		and mx <  contextMenu.x + contextMenu.width
		and my <  contextMenu.y + contextMenu.height
}

local isHoveringPanelItemRectangle :: (state:PanelState, x,y,w,h:int) -> bool {
	if draggedPanelItem == state.panelItem      return true
	if draggedPanelItem > 0                     return false
	if state.my < state.ignoreMouseAboveY       return false
	if isInsideContextMenu(state.mx, state.my)  return false
	return isInside(state.mx, state.myScrolled, x, y, w, h)
}
local isHoveringPanelItemCircle :: (state:PanelState, x,y,radius:int) -> bool {
	if draggedPanelItem == state.panelItem      return true
	if draggedPanelItem > 0                     return false
	if state.my < state.ignoreMouseAboveY       return false
	if isInsideContextMenu(state.mx, state.my)  return false
	return math.distance(state.mx,state.myScrolled, x,y) <= radius
}

local isPressingOrMayPress :: (state:PanelState) -> (pressedMouseButton:int) {
	if state.panelItem == draggedPanelItem  return 1
	return (draggedPanelItem or panelItemToPasteAt) ? 0 : pressedOnPanelWithMouseButton
}



local drawChecker :: (x,y,w,h:float, scale=1.0) {
	static quad: LG.Quad = NULL

	if quad == NULL {
		local iw, ih = imageChecker.getDimensions!()
		quad         = LG.newQuad(0, 0, 1, 1, iw, ih)
	}

	quad.setViewport!(0, 0, w/scale, h/scale)
	LG.draw(imageChecker, quad, x, y, 0, scale)
}

local drawPanelSeparator :: (state:PanelState, thick=false) {
	local w = thick ? 6 : 2
	LG.setColor(0, 0, 0, .5)
	LG.rectangle(LG.DrawMode.FILL, 0, state.panelY, PANEL_WIDTH, w)
	state.lastPanelY  = state.panelY
	state.panelY     += w+PANEL_SPACING
}

local drawLabels :: (label1,label2:string, y:int) {
	LG.setColor(1, 1, 1)
	if label1 {
		LG.print(label1, PANEL_SPACING, y)
	}
	if label2 {
		LG.setFont(fontSmall)
		LG.print(label2, LABEL_WIDTH-fontSmall.getWidth!(label2), y+1)
		LG.setFont(fontNormal)
	}
}

local drawPanelDirection :: (state:PanelState, label1,label2:string, angle:float, slot=1, spreadCcw,spreadCw=0.0) -> (pressedMouseButton:int, angle:float) {
	state.panelItem += 1

	local RADIUS :: 25

	local x = LABEL_WIDTH+PANEL_SPACING+RADIUS + (slot-1)*(PANEL_SPACING+2*RADIUS)
	local y = state.panelY + RADIUS

	local hovered = isHoveringPanelItemCircle(state, x, y, RADIUS)
	local pressed = hovered ? isPressingOrMayPress(state) : 0

	if pressed == 1 {
		draggedPanelItem = state.panelItem
		angle            = math.atan(state.myScrolled-y, state.mx-x)
		if state.mod == ModifierKey.C  angle = math.round(angle * 8/math.TAU) / 8*math.TAU

	} elseif pressed == 2 {
		local ITEMS :: {"Copy angle","Paste angle"}
		local panelItem = state.panelItem

		showContextMenu(state, ITEMS, [angle,panelItem] (choice:int) {
			if choice == {
				case 1: clipboardAngle                  = angle
				case 2: panelItemToPasteAt, pasteTarget = panelItem, 0
			}
		})

	} elseif state.panelItem == panelItemToPasteAt {
		if clipboardAngle ~= NULL {
			angle                 = clipboardAngle
			pressed               = 1
			scheduleSaveWorkspace = true
		}

	} elseif hovered and (keysPressedThisFrame.left or keysPressedThisFrame.right) {
		local delta = math.TAU * ((state.mod == ModifierKey.S) ? 45/360 : (state.mod == ModifierKey.C) ? 1/360 : 5/360)
		angle       = ((keysPressedThisFrame.left ? angle-delta : angle+delta) + math.PI) % math.TAU - math.PI
		pressed     = 1
		scheduleSaveWorkspace = true
	}

	drawLabels(label1, label2, math.round(y-state.fontH/2))

	LG.setColor(0, 0, 0)
	LG.circle(LG.DrawMode.FILL, x, y, RADIUS)
	LG.setColor(1, 1, 1, .25)
	if spreadCcw  LG.arc(LG.DrawMode.FILL, x, y, .8*RADIUS, angle-spreadCcw, angle, 32)
	if spreadCw   LG.arc(LG.DrawMode.FILL, x, y, .8*RADIUS, angle,  angle+spreadCw, 32)
	LG.setColor(1, 1, 1, GUIDE_LINE_OPACITY)
	LG.line(x-RADIUS+1, y, x+RADIUS-1, y)
	LG.line(x, y-RADIUS+1, x, y+RADIUS-1)
	if hovered {
		LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
		LG.circle(LG.DrawMode.LINE, x, y, RADIUS+.5)
	}
	LG.setColor(1, 1, 1)
	LG.line(x, y, x+RADIUS*math.cos(angle), y+RADIUS*math.sin(angle))

	if showPanelNumbers {
		local text  = format("%d°", angle*360/math.TAU)
		local textX = math.round(x-fontSmall.getWidth!(text)/2)
		local textY = (angle % math.TAU < math.PI) ? state.panelY+5 : state.panelY+2*RADIUS-5-fontSmall.getHeight!()
		LG.setFont(fontSmall)
		LG.setColor(0, 0, 0)
		LG.print(text, textX+1, textY+1)
		LG.setColor(1, 1, 1)
		LG.print(text, textX, textY)
		LG.setFont(fontNormal)
	}

	state.lastPanelY  = state.panelY
	state.panelY     += 2*RADIUS + PANEL_SPACING
	return pressed, angle
}

local drawSliderValue :: (sliderX,sliderY:float, sliderW,sliderH:float, value:float, readout:float, readoutFormat:string) {
	if showPanelNumbers and readoutFormat {
		local text = format(readoutFormat, readout)
		local x    = math.round(sliderX+(sliderW-fontSmall.getWidth!(text))/2)
		local y    = math.round(sliderY+(sliderH-fontSmall.getHeight!())/2)
		LG.setFont(fontSmall)
		LG.setColor(0, 0, 0)
		LG.print(text, x+1, y+1)
		LG.setColor(1, 1, 1)
		LG.print(text, x, y)
		LG.setFont(fontNormal)
	}
	do {
		local x = sliderX + value*(sliderW-4)
		LG.setColor(0, 0, 0)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, 4, sliderH)
		LG.setColor(1, 1, 1)
		LG.rectangle(LG.DrawMode.FILL, x+1, sliderY, 2, sliderH)
	}
}

local drawPanelSlider :: (state:PanelState,
	label1,label2:string, valueMin,valueMax:float, value:float,
	readoutMultiplier:float, readoutFormat:string, other:float|none=nil
) -> (
	pressedMouseButton:int, value:float
) {
	state.panelItem += 1

	local w = PANEL_WIDTH-LABEL_WIDTH-2*PANEL_SPACING
	local h = state.fontH
	local x = LABEL_WIDTH+PANEL_SPACING
	local y = state.panelY

	local hovered = isHoveringPanelItemRectangle(state, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(state) : 0

	if pressed == 1 {
		draggedPanelItem = state.panelItem
		value            = math.lerp(valueMin, valueMax, math.clamp01((state.mx-x)/w))
		if state.mod == ModifierKey.C  value = math.lerp(valueMin, valueMax, math.round(math.clamp01((state.mx-x)/w)*16)/16)

	} elseif pressed == 2 {
		local ITEMS :: {"Copy value","Paste value"}
		local panelItem = state.panelItem

		showContextMenu(state, ITEMS, [value,panelItem] (choice:int) {
			if choice == {
				case 1: clipboardScalar                 = value
				case 2: panelItemToPasteAt, pasteTarget = panelItem, 0
			}
		})

	} elseif state.panelItem == panelItemToPasteAt {
		if clipboardScalar ~= NULL {
			value                 = math.clamp(clipboardScalar, valueMin, valueMax)
			pressed               = 1
			scheduleSaveWorkspace = true
		}

	} elseif hovered and (keysPressedThisFrame.left or keysPressedThisFrame.right) {
		local delta           = (valueMax-valueMin) * ((state.mod == ModifierKey.S) ? 1/16 : (state.mod == ModifierKey.C) ? 1/1024 : 1/128)
		value                 = math.clamp((keysPressedThisFrame.left ? value-delta : value+delta), valueMin, valueMax)
		pressed               = 1
		scheduleSaveWorkspace = true
	}

	drawLabels(label1, label2, state.panelY)

	-- Background.
	LG.setColor(0, 0, 0)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h)

	-- The other value.
	if other ~= nil {
		local valueX = (x+2) + (w-4) * (           (value)-valueMin) / (valueMax-valueMin)
		local otherX = (x+2) + (w-4) * (cast(float)(other)-valueMin) / (valueMax-valueMin)
		LG.setColor(1, 1, 1, .25)
		LG.rectangle(LG.DrawMode.FILL, valueX, y+.25*h, otherX-valueX, h/2)
	}

	-- Hover effect.
	if hovered {
		LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
		LG.rectangle(LG.DrawMode.LINE, x-.5, y-.5, w+1, h+1)
	}

	-- Guide lines.
	LG.setColor(1, 1, 1, GUIDE_LINE_OPACITY)
	LG.rectangle(LG.DrawMode.FILL, x+.25*w, y, 1, h)
	LG.rectangle(LG.DrawMode.FILL, x+.50*w, y, 1, h)
	LG.rectangle(LG.DrawMode.FILL, x+.75*w, y, 1, h)

	-- The actual value.
	drawSliderValue(x, y, w, h, (value-valueMin)/(valueMax-valueMin), value*readoutMultiplier, readoutFormat)

	state.lastPanelY  = state.panelY
	state.panelY     += h + PANEL_SPACING
	return pressed, value
}

local drawPanelColor :: (state:PanelState, label1,label2:string, hue,saturation,value:float,a:float|none) -> (pressedMouseButton:int, hue,saturation,value,a:float) {
	state.panelItem += 1

	local SLIDER_HEIGHT :: 12
	local PREVIEW_WIDTH :: 24

	local components = (a == nil ? 3 : 4)

	local w = PANEL_WIDTH - LABEL_WIDTH - PREVIEW_WIDTH - 3*PANEL_SPACING
	local h = SLIDER_HEIGHT * components
	local x = LABEL_WIDTH + PANEL_SPACING
	local y = state.panelY

	local hovered = isHoveringPanelItemRectangle(state, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(state) : 0

	local component = math.clamp(math.floor(1+(state.myScrolled-y)/SLIDER_HEIGHT), 1, components)

	if pressed == 1 {
		draggedPanelItem = state.panelItem

		if not draggedPanelSubItem  draggedPanelSubItem = component
		component = draggedPanelSubItem

		if component == {
			case 1: hue        = math.clamp01((state.mx-x)/w)
			case 2: saturation = math.clamp01((state.mx-x)/w)
			case 3: value      = math.clamp01((state.mx-x)/w)
			case 4: a          = math.clamp01((state.mx-x)/w)
		}

	} elseif pressed == 2 {
		local ITEMS_H :: {"Copy hue",           "Copy color","Paste hue",           "Paste color"}
		local ITEMS_S :: {"Copy saturation",    "Copy color","Paste saturation",    "Paste color"}
		local ITEMS_V :: {"Copy value strength","Copy color","Paste value strength","Paste color"}
		local ITEMS_A :: {"Copy opacity",       "Copy color","Paste opacity",       "Paste color"}
		local panelItem = state.panelItem

		local items =
			component == 1 ? ITEMS_H :
			component == 2 ? ITEMS_S :
			component == 3 ? ITEMS_V :
			ITEMS_A

		showContextMenu(state, items, [hue,saturation,value,a,panelItem,component] (choice:int) {
			if choice == {
				case 1:
					if component == {
						case 1: clipboardScalar = hue
						case 2: clipboardScalar = saturation
						case 3: clipboardScalar = value
						case 4: clipboardScalar = cast(float) a
					}
				case 2: clipboardColor = {hue, saturation, value, (a == NULL ? 1.0 : cast(float)a)}
				case 3: panelItemToPasteAt, pasteTarget = panelItem, component
				case 4: panelItemToPasteAt, pasteTarget = panelItem, 0
			}
		})

	} elseif state.panelItem == panelItemToPasteAt {
		component = cast(int) pasteTarget
		if component > 0 {
			if clipboardScalar ~= NULL {
				if component == {
					case 1: hue        = math.clamp01(clipboardScalar)
					case 2: saturation = math.clamp01(clipboardScalar)
					case 3: value      = math.clamp01(clipboardScalar)
					case 4: a          = math.clamp01(clipboardScalar)
				}
				pressed               = 1
				scheduleSaveWorkspace = true
			}
		} else {
			if clipboardColor ~= NULL {
				hue        = clipboardColor[1]
				saturation = clipboardColor[2]
				value      = clipboardColor[3]
				a          = clipboardColor[4]
				pressed    = 1
				scheduleSaveWorkspace = true
			}
		}

	} elseif hovered and (keysPressedThisFrame.left or keysPressedThisFrame.right) {
		local delta = ((state.mod == ModifierKey.S) ? 16/255 : (state.mod == ModifierKey.C) ? 1/255 : 4/255)
		if component == {
			case 1: hue        = math.clamp01((keysPressedThisFrame.left ? hue            - delta : hue            + delta))
			case 2: saturation = math.clamp01((keysPressedThisFrame.left ? saturation     - delta : saturation     + delta))
			case 3: value      = math.clamp01((keysPressedThisFrame.left ? value          - delta : value          + delta))
			case 4: a          = math.clamp01((keysPressedThisFrame.left ? cast(float)(a) - delta : cast(float)(a) + delta))
		}
		pressed               = 1
		scheduleSaveWorkspace = true
	}

	drawLabels(label1, label2, state.panelY)
	-- drawLabels(label1, label2, math.round(state.panelY+(h-state.fontH)/2))

	-- Preview.
	local r, g, b = hsvToRgb(hue, saturation, value)

	do {
		local previewX = x+w+PANEL_SPACING
		LG.setColor(.15, .15, .15)
		LG.rectangle(LG.DrawMode.FILL, previewX, y, PREVIEW_WIDTH, h)
		LG.setColor(.27, .27, .27)
		drawChecker(previewX, y, PREVIEW_WIDTH, h)
		LG.setColor(r, g, b, (a == nil ? 1.0 : cast(float)a))
		LG.rectangle(LG.DrawMode.FILL, previewX, y, PREVIEW_WIDTH, h)
	}

	-- Components.
	do {
		local iw, ih     = imageGradient.getDimensions!()
		local gradientSx = w/iw
		local gradientSy = SLIDER_HEIGHT/ih

		iw, ih           = imageRainbow.getDimensions!()
		local rainbowSx  = w/iw
		local rainbowSy  = SLIDER_HEIGHT/ih

		local sliderY    = y

		LG.setColor(1, 1, 1)
		LG.draw(imageRainbow, x, sliderY, 0, rainbowSx, rainbowSy)
		drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, hue, hue*360, "%d°")
		sliderY += SLIDER_HEIGHT

		local r2, g2, b2 = hsvToRgb(hue, 1, 1)
		LG.setColor(.5, .5, .5)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, SLIDER_HEIGHT)
		LG.setColor(r2, g2, b2)
		LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
		drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, saturation, saturation*100, "%d%%")
		sliderY += SLIDER_HEIGHT

		r2, g2, b2 = hsvToRgb(hue, saturation, 1)
		LG.setColor(0, 0, 0)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, SLIDER_HEIGHT)
		LG.setColor(r2, g2, b2)
		LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
		drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, value, value*100, "%d%%")
		sliderY += SLIDER_HEIGHT

		if a ~= nil {
			LG.setColor(.15, .15, .15)
			LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, SLIDER_HEIGHT)
			LG.setColor(.27, .27, .27)
			drawChecker(x, sliderY, w, SLIDER_HEIGHT)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
			drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, cast(float)a, cast(float)(a)*100, "%d%%")
		}

		if hovered {
			LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY_STRONG)
			LG.rectangle(LG.DrawMode.LINE, x-.5, y+(component-1)*SLIDER_HEIGHT-.5, w+1, SLIDER_HEIGHT+1)
		}
	}

	state.lastPanelY  = state.panelY
	state.panelY     += h + PANEL_SPACING
	return pressed, hue,saturation,value,cast(float)a -- 'a' is actually nil if the function was called with a=nil.
}

local ButtonStyle :: enum { NORMAL, TABS }

local drawPanelButtons :: (state:PanelState, label1,label2:string, buttonLabels:[]string, selected=0, style=ButtonStyle.NORMAL, lastButtonWidth=0, showLabel=true) -> (pressedMouseButton:int, pressedIndex:int) {
	state.panelItem += 1

	local highlightAll = (selected == 0)

	local x = showLabel ? LABEL_WIDTH+PANEL_SPACING : PANEL_SPACING
	local y = state.panelY
	local w = PANEL_WIDTH - x-PANEL_SPACING
	local h = state.fontH

	local buttonW0 = lastButtonWidth ? (w-lastButtonWidth)/(#buttonLabels-1) : w/#buttonLabels

	local hovered = isHoveringPanelItemRectangle(state, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(state) : 0
	local pressedIndex: int

	if pressed {
		pressedIndex          = math.clamp(math.floor(1+(state.mx-x)/buttonW0), 1, #buttonLabels)
		scheduleSaveWorkspace = true
	}

	if showLabel  drawLabels(label1, label2, state.panelY)

	for buttonLabels {
		local buttonX1 = math.round(x + (itIndex-1)*buttonW0)
		local buttonX2 = math.round(x + (itIndex  )*buttonW0)
		local buttonW  = buttonW0

		if lastButtonWidth and itIndex == #buttonLabels {
			buttonX2 = x+w
			buttonW  = buttonX2-buttonX1
		}

		local padding = (style == ButtonStyle.TABS) ? 8 : 3

		local textX = buttonX1 + math.max(math.round((buttonW-fontNormal.getWidth!(it))/2), padding)
		local faded = not (highlightAll or itIndex == selected)

		if hovered and state.mx >= buttonX1 and state.mx < buttonX2
			LG.setColor(1, 1, 1, .45)
		elseif faded
			LG.setColor(1, 1, 1, .15)
		else
			LG.setColor(1, 1, 1, .3)

		if style == ButtonStyle.TABS {
			local inset = math.min(.6*h, buttonW/4)
			LG.polygon(LG.DrawMode.FILL, buttonX1,y+h, buttonX1+inset,y, buttonX2-inset,y, buttonX2,y+h)
		} else {
			LG.rectangle(LG.DrawMode.FILL, buttonX1+1, y+1, buttonX2-buttonX1-2, h-2, 3)
		}

		local scissorX1 = buttonX1+(padding-1)
		local scissorX2 = buttonX2-(padding-1)

		if scissorX2 > scissorX1 {
			LG.push(LG.StackType.ALL)
			LG.intersectScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
			LG.setColor(1, 1, 1, (faded ? .6 : 1.0))
			LG.print(it, textX, y)
			LG.pop()
		}
	}

	state.lastPanelY  = state.panelY
	state.panelY     += h + PANEL_SPACING
	return pressed, pressedIndex
}

export drawPanel :: () {
	local state: PanelState = {
		panelY     = PANEL_SPACING,
		fontH      = fontNormal.getHeight!(),
		mx         = love.mouse.getX(),
		my         = love.mouse.getY(),
		myScrolled = love.mouse.getY(),
		mod        = getModifierKey(),
	}

	-- Note: Some things may render incorrectly for one frame if the user does
	-- something because we handle mouse input here while rendering.
	LG.setColor(.2, .2, .2)
	LG.rectangle(LG.DrawMode.FILL, 0, 0, PANEL_WIDTH, LG.getHeight())

	-- Project.
	local project = openProjects[currentProjectIndex]

	do {
		local buttonLabels: []string
		for openProjects  buttonLabels[itIndex] = "(unnamed)" -- Use filenames on tabs.

		insert(buttonLabels, "+")

		local pressed, i = drawPanelButtons(state, "", "", buttonLabels, selected=currentProjectIndex, style=ButtonStyle.TABS, showLabel=false, lastButtonWidth=32)
		if pressed == 1 {
			if i < #buttonLabels {
				currentProjectIndex = i
			} else {
				addNewProject()
				currentProjectIndex = #openProjects
			}
			scheduleRecreateCanvases = true
			updateParticleImageFilters()

		} elseif pressed == 3 and i < #buttonLabels {
			-- @UX: Confirm closing project if there are changes.
			remove(openProjects, i)
			if openProjects[1] == NULL
				addNewProject()
			elseif i < currentProjectIndex
				currentProjectIndex -= 1
			else
				currentProjectIndex = math.min(currentProjectIndex, #openProjects)
			scheduleRecreateCanvases = true
			updateParticleImageFilters()
		}
	}
	do {
		local BUTTON_LABELS_SHOW :: {"show settings"}
		local BUTTON_LABELS_HIDE :: {"hide settings"}
		local pressed, i = drawPanelButtons(state, "", "", (showProjectSettings ? BUTTON_LABELS_HIDE : BUTTON_LABELS_SHOW), showLabel=false)
		if pressed == 1 {
			showProjectSettings   = not showProjectSettings
			scheduleSaveWorkspace = true
		}
	}
	if showProjectSettings {
		drawPanelSeparator(state)
		do {
			local pressed, i = drawPanelButtons(state, "PixelateWorld", "", BUTTON_LABELS_YES_NO, selected=(project.pixelateWorld ? 1 : 2))
			if pressed == 1 {
				project.pixelateWorld    = (i == 1)
				scheduleRecreateCanvases = true

				if project.pixelateWorld and project.zoomLevel < -1 {
					project.zoomLevel  = -1
					project.zoomSource = project.zoom
					project.zoomTarget = 2^project.zoomLevel
				}
			}
		}
		do {
			local pressed, i = drawPanelButtons(state, "PixelateTextures", "", BUTTON_LABELS_YES_NO, selected=(project.pixelateTextures ? 1 : 2))
			if pressed == 1 {
				project.pixelateTextures = (i == 1)
				updateParticleImageFilters()
			}
		}
		drawPanelSeparator(state)
		do {
			local pressed, h,s,v = drawPanelColor(state, "Background", "", project.bgColorH, project.bgColorS, project.bgColorV, nil)

			if pressed == 1 {
				project.bgColorH, project.bgColorS, project.bgColorV = h,s,v
			}
		}
	}

	-- System.
	local system = project.systems[project.systemIndex]
	drawPanelSeparator(state, true)
	do {
		local doRemove = (state.mod == ModifierKey.A)

		local buttonLabels: []string
		for project.systems  buttonLabels[itIndex] = format("%d", itIndex)

		insert(buttonLabels, "+")

		local pressed, i = drawPanelButtons(state, "ParticleSystem", "", buttonLabels, selected=project.systemIndex, lastButtonWidth=32, style=ButtonStyle.TABS)
		if pressed == 1 {
			if i < #buttonLabels {
				project.systemIndex = i
			} else {
				addNewSystem(project)
				project.systemIndex = #project.systems
			}
			system = project.systems[project.systemIndex]

		} elseif pressed == 3 and i < #buttonLabels {
			-- @UX: Confirm removal of system.
			remove(project.systems, i)
			if project.systems[1] == NULL
				addNewSystem(project)
			elseif i < project.systemIndex
				project.systemIndex -= 1
			else
				project.systemIndex = math.min(project.systemIndex, #project.systems)
			system = project.systems[project.systemIndex]
		}
	}

	drawPanelSeparator(state, true)

	do {
		local scissorY = state.panelY-PANEL_SPACING

		LG.push(LG.StackType.ALL)
		LG.setScissor(0, scissorY, PANEL_WIDTH, LG.getHeight()-scissorY)
		LG.translate(0, project.panelScroll)

		state.myScrolled        -= math.round(project.panelScroll)
		state.ignoreMouseAboveY  = scissorY

		state.panelY += 5
	}

	-- Misc params.
	local ps = system.particles
	do {
		local BUTTON_LABELS :: {"top", "bottom", "random"}
		local INSERT_MODE_TO_INDEX: struct { !key:LG.ParticleInsertMode, !value:int } = {
			[LG.ParticleInsertMode.TOP]    = 1,
			[LG.ParticleInsertMode.BOTTOM] = 2,
			[LG.ParticleInsertMode.RANDOM] = 3,
		}
		local pressed, i = drawPanelButtons(state, "Insert", "", BUTTON_LABELS, selected=INSERT_MODE_TO_INDEX[ps.getInsertMode!()])
		if pressed == 1  if i == {
			case 1: ps.setInsertMode!(LG.ParticleInsertMode.TOP)
			case 2: ps.setInsertMode!(LG.ParticleInsertMode.BOTTOM)
			case 3: ps.setInsertMode!(LG.ParticleInsertMode.RANDOM)
		}
	}
	drawPanelSeparator(state)
	do {
		local lifetime = math.max(ps.getEmitterLifetime!(), 0)
		local pressed, ^lifetime = drawPanelSlider(state, "Lifetime", "emitter", 0, 20, lifetime,other=0, 1, (lifetime > 0 ? "%.2f sec" : "∞"))
		if pressed == 1 {
			ps.setEmitterLifetime!(lifetime > 0 ? lifetime : -1.0)
			if lifetime <= 0  ps.start!()
		}
	}
	do {
		local min, max = ps.getParticleLifetime!()
		local pressedMin, ^min = drawPanelSlider(state, "", "particle min", 0, 20, min,other=max, 1, "%.2f sec")
		local pressedMax, ^max = drawPanelSlider(state, "", "particle max", 0, 20, max,other=min, 1, "%.2f sec")
		if pressedMin  max = math.max(min, max)
		if pressedMax  min = math.min(min, max)
		if pressedMin == 1 or pressedMax == 1  ps.setParticleLifetime!(min, max)
	}
	drawPanelSeparator(state, true)
	do {
		local pressed, rate = drawPanelSlider(state, "SpawnRate", "", .1, 1000, ps.getEmissionRate!(),other=0, 1, "%.1f / sec")
		if pressed == 1  ps.setEmissionRate!(rate)
	}
	drawPanelSeparator(state)
	do {
		using LG.AreaSpreadDistribution
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()

		local BUTTON_LABELS :: {"none", "uni", "norm", "ellip", "b.ellip", "b.rect"}
		local DISTRIBUTION_TO_INDEX: struct { !key:LG.AreaSpreadDistribution, !value:int } = {
			[NONE]             = 1,
			[UNIFORM]          = 2,
			[NORMAL]           = 3,
			[ELLIPSE]          = 4,
			[BORDER_ELLIPSE]   = 5,
			[BORDER_RECTANGLE] = 6,
		}
		local pressed1, i = drawPanelButtons(state, "Area", "distribution", BUTTON_LABELS, selected=DISTRIBUTION_TO_INDEX[distribution])
		if pressed1 == 1  if i == {
			case 1: distribution = NONE
			case 2: distribution = UNIFORM
			case 3: distribution = NORMAL
			case 4: distribution = ELLIPSE
			case 5: distribution = BORDER_ELLIPSE
			case 6: distribution = BORDER_RECTANGLE
		}

		if distribution == NONE {
			if pressed1 == 1  ps.setEmissionArea!(distribution, 0,0)

		} else {
			local pressed2, ^dx = drawPanelSlider(state, "", "dx", 0, 1000, dx,other=0, 1, "%d")
			local pressed3, ^dy = drawPanelSlider(state, "", "dy", 0, 1000, dy,other=0, 1, "%d")

			local pressed4, ^angle = drawPanelDirection(state, "", "angle", angle)

			local pressed5, ^i = drawPanelButtons(state, "", "dir relative to center", BUTTON_LABELS_YES_NO, selected=(relative ? 1 : 2))
			if pressed5 == 1  relative = (i == 1)

			if pressed1 == 1 or pressed2 == 1 or pressed3 == 1 or pressed4 == 1 or pressed5 == 1 {
				ps.setEmissionArea!(distribution, dx,dy, angle, relative)
			}
		}
	}
	drawPanelSeparator(state)
	do {
		local pressed, angle = drawPanelDirection(state, "Direction", "", ps.getDirection!(), spreadCcw=ps.getSpread!()/2,spreadCw=ps.getSpread!()/2)
		if pressed == 1  ps.setDirection!(angle)
	}
	do {
		local pressed, angle = drawPanelSlider(state, "", "spread", 0, math.TAU, ps.getSpread!(),other=0, 360/math.TAU, "%d°")
		if pressed == 1  ps.setSpread!(angle)
	}
	drawPanelSeparator(state, true)
	do {
		local min, max = ps.getSpeed!()
		local pressedMin, ^min = drawPanelSlider(state, "Speed", "min", -2000, 2000, min,other=max, 1, "%d / sec")
		local pressedMax, ^max = drawPanelSlider(state, "",      "max", -2000, 2000, max,other=min, 1, "%d / sec")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setSpeed!(min, max)
		}
	}
	drawPanelSeparator(state)
	do {
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		local pressedXmin, ^xmin = drawPanelSlider(state, "AccLinear", "xmin", -10000, 10000, xmin,other=xmax, 1, "%d / sec²")
		local pressedXmax, ^xmax = drawPanelSlider(state, "",          "xmax", -10000, 10000, xmax,other=xmin, 1, "%d / sec²")
		local pressedYmin, ^ymin = drawPanelSlider(state, "",          "ymin", -10000, 10000, ymin,other=ymax, 1, "%d / sec²")
		local pressedYmax, ^ymax = drawPanelSlider(state, "",          "ymax", -10000, 10000, ymax,other=ymin, 1, "%d / sec²")
		if pressedXmin == 1 or pressedXmax == 1 or pressedYmin == 1 or pressedYmax == 1 {
			if pressedXmin  xmax = math.max(xmin, xmax)
			if pressedXmax  xmin = math.min(xmin, xmax)
			if pressedYmin  ymax = math.max(ymin, ymax)
			if pressedYmax  ymin = math.min(ymin, ymax)
			ps.setLinearAcceleration!(xmin,ymin, xmax,ymax)
		}
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getRadialAcceleration!()
		local pressedMin, ^min = drawPanelSlider(state, "AccRadial", "min", -20000, 20000, min,other=max, 1, "%d / sec²")
		local pressedMax, ^max = drawPanelSlider(state, "",          "max", -20000, 20000, max,other=min, 1, "%d / sec²")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setRadialAcceleration!(min, max)
		}
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getTangentialAcceleration!()
		local pressedMin, ^min = drawPanelSlider(state, "AccTangent", "min", -20000, 20000, min,other=max, 1, "%d / sec²")
		local pressedMax, ^max = drawPanelSlider(state, "",           "max", -20000, 20000, max,other=min, 1, "%d / sec²")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setTangentialAcceleration!(min, max)
		}
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getLinearDamping!()
		local pressedMin, ^min = drawPanelSlider(state, "DampLinear", "min", -50, 50, min,other=max, 1, "%.2f")
		local pressedMax, ^max = drawPanelSlider(state, "",           "max", -50, 50, max,other=min, 1, "%.2f")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setLinearDamping!(min, max)
		}
	}
	drawPanelSeparator(state, true)
	do {
		local min, max = ps.getRotation!()
		local pressedMin, ^min = drawPanelDirection(state, "Rotation", "min/max", min, slot=1, spreadCw=max-min) ; state.panelY = state.lastPanelY
		local pressedMax, ^max = drawPanelDirection(state, "",         "",        max, slot=2, spreadCcw=max-min)
		if pressedMin == 1 or pressedMax == 1 {
			-- if pressedMin  max = math.max(min, max)
			-- if pressedMax  min = math.min(min, max)
			ps.setRotation!(min, max)
		}
	}
	do {
		local pressed, i = drawPanelButtons(state, "", "relative", BUTTON_LABELS_YES_NO, selected=(ps.hasRelativeRotation!() ? 1 : 2))
		if pressed == 1  ps.setRelativeRotation!(i == 1)
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getSpin!()
		local pressedMin, ^min = drawPanelSlider(state, "Spin", "at start", -8*math.TAU, 8*math.TAU, min,other=max, 1/math.TAU, "%.2f turns / sec")
		local pressedMax, ^max = drawPanelSlider(state, "",     "at end",   -8*math.TAU, 8*math.TAU, max,other=min, 1/math.TAU, "%.2f turns / sec")
		if pressedMin == 1 or pressedMax == 1  ps.setSpin!(min, max)
	}
	do {
		local pressed, variation = drawPanelSlider(state, "", "variation", 0, 1, ps.getSpinVariation!(),other=0, 100, "%d%%")
		if pressed == 1  ps.setSpinVariation!(variation)
	}
	--[[
	-- @Incomplete:
	ps.setQuads!(quad1,quad2)
	ps.setTexture!(texture)
	ps.setOffset!(x,y)
	ps.setBufferSize!(size) -- Automatically calculate this!
	]]

	-- Sizes.
	drawPanelSeparator(state, true)
	do {
		local sizes    = {ps.getSizesAsVararg!()}
		local doRemove = (state.mod == ModifierKey.A)
		local buttonLabels: []string

		if doRemove {
			for i = 1, #sizes  insert(buttonLabels, format("%d", i))
		} else {
			insert(buttonLabels, "+")
		}

		local pressed, i = drawPanelButtons(state, "Size", (doRemove ? "DEL" : ""), buttonLabels)

		if pressed ~= 1 {
			-- void

		} elseif doRemove {
			remove(sizes, i)
			if sizes[1] == NULL  insert(sizes, 1)
			ps.setSizes!(sizes)

		} elseif sizes[8] == NULL {
			insert(sizes, sizes[#sizes])
			ps.setSizes!(sizes)
		}
	}
	do {
		local sizes      = {ps.getSizesAsVararg!()}
		local anyPressed = false
		local moveAll    = state.mod == ModifierKey.CS

		for i = 1, #sizes {
			local pressed, size = drawPanelSlider(state, "", format("#%d", i), 0, 8, sizes[i],other=0, 1, "%.2f")
			anyPressed          = anyPressed or pressed == 1

			if pressed ~= 1 {
				-- void
			} elseif not moveAll {
				sizes[i] = size
			} else {
				for j = 1, #sizes  sizes[j] = size
			}
		}
		if anyPressed  ps.setSizes!(sizes)
	}
	do {
		local pressed, variation = drawPanelSlider(state, "", "variation", 0, 1, ps.getSizeVariation!(),other=0, 100, "%d%%")
		if pressed == 1  ps.setSizeVariation!(variation)
	}

	-- Colors + blend mode.
	drawPanelSeparator(state)
	do {
		local colors   = system.colors
		local doRemove = (state.mod == ModifierKey.A)
		local buttonLabels: []string

		if doRemove {
			for i = 1, #colors//4  insert(buttonLabels, format("%d", i))
		} else {
			insert(buttonLabels, "+")
		}

		local pressed, i = drawPanelButtons(state, "Color", (doRemove ? "DEL" : ""), buttonLabels)

		if pressed ~= 1 {
			-- void

		} elseif doRemove {
			local colorIndex = i*4-3
			for 1, 4  remove(colors, colorIndex)

			if colors[1] == NULL {
				for 1, 4  insert(colors, 1)
			}

			updateParticleColors(ps, colors)

		} elseif colors[8*4] == NULL {
			local lastColorIndex = (#colors//4)*4-3
			for 1, 4  insert(colors, colors[lastColorIndex+it-1])
			updateParticleColors(ps, colors)
		}
	}
	do {
		local colors     = system.colors
		local anyPressed = false
		local moveAll    = state.mod == ModifierKey.CS

		for i = 1, #colors, 4 {
			local pressed, h,s,v,a = drawPanelColor(state, "", format("#%d", (i+3)//4), colors[i], colors[i+1], colors[i+2], colors[i+3])
			anyPressed             = anyPressed or pressed == 1

			if pressed ~= 1 {
				-- void
			} elseif not moveAll {
				colors[i], colors[i+1], colors[i+2], colors[i+3] = h,s,v,a
			} elseif draggedPanelSubItem < 4 {
				for j = 1, #colors, 4  colors[j], colors[j+1], colors[j+2] = h,s,v
			} else {
				for j = 4, #colors, 4  colors[j] = a
			}
		}
		if anyPressed  updateParticleColors(ps, colors)
	}
	do {
		local BUTTON_LABELS :: {"alpha", "add", "screen", "subtract"}
		local BLEND_MODE_TO_INDEX: struct { !key:LG.BlendMode, !value:int } = {
			[LG.BlendMode.ALPHA]    = 1,
			[LG.BlendMode.ADD]      = 2,
			[LG.BlendMode.SCREEN]   = 3,
			[LG.BlendMode.SUBTRACT] = 4,
		}
		local pressed, i = drawPanelButtons(state, "", "blend mode", BUTTON_LABELS, selected=BLEND_MODE_TO_INDEX[system.blendMode])
		if pressed == 1  if i == {
			case 1: system.blendMode = LG.BlendMode.ALPHA
			case 2: system.blendMode = LG.BlendMode.ADD
			case 3: system.blendMode = LG.BlendMode.SCREEN
			case 4: system.blendMode = LG.BlendMode.SUBTRACT
		}
	}
	drawPanelSeparator(state, true)

	do {
		-- Reset these here after the target panel item has handled the paste.
		panelItemToPasteAt = 0
		pasteTarget        = 0
	}

	LG.pop()

	do {
		local h = (project.panelScroll ? 30 : 10)

		local iw, ih     = imageGradient.getDimensions!()
		local gradientSx = h/ih
		local gradientSy = PANEL_WIDTH/iw

		LG.setColor(0, 0, 0, (project.panelScroll ? 1.0 : .3))
		LG.draw(imageGradient, 0, state.ignoreMouseAboveY+h, -math.TAU/4, gradientSx, gradientSy)
	}

	if contextMenu ~= NULL {
		local itemHeight  = state.fontH + 2*CONTEXT_MENU_PADDING_Y
		local pressedItem = 0

		LG.setColor(.6, .6, .6)
		LG.rectangle(LG.DrawMode.FILL, contextMenu.x, contextMenu.y, contextMenu.width, contextMenu.height)

		for contextMenu.items {
			local x = contextMenu.x
			local y = contextMenu.y + (itIndex-1)*itemHeight

			if isInside(state.mx, state.my, x, y, contextMenu.width, itemHeight) {
				if not state.showedContextMenuThisFrame and pressedOnPanelWithMouseButton == 1
					pressedItem = itIndex

				LG.setColor(.8, .8, .8)
				LG.rectangle(LG.DrawMode.FILL, x, y, contextMenu.width, itemHeight)
			}

			LG.setColor(0, 0, 0)
			LG.print(it, x+CONTEXT_MENU_PADDING_X, y+CONTEXT_MENU_PADDING_Y)
		}

		if pressedItem {
			local _contextMenu = contextMenu
			contextMenu        = NULL
			_contextMenu.callback(pressedItem)

		} elseif pressedAnythingThisFrame and not (state.showedContextMenuThisFrame or isInsideContextMenu(state.mx, state.my)) {
			contextMenu = NULL
		}
	}

	pressedOnPanelWithMouseButton = 0
}


