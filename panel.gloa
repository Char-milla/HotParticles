--[[============================================================
--=
--=  GUI panel
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

export PANEL_WIDTH :: LABEL_WIDTH + 300

local LABEL_WIDTH   :: 110
local PANEL_SPACING :: 3

local GUIDE_LINE_OPACITY           :: .2
local HOVER_OUTLINE_OPACITY        :: .3
local HOVER_OUTLINE_OPACITY_STRONG :: .5

local BUTTON_LABELS_YES_NO :: {"yes", "no"}



export pressedOnPanelWithMouseButton = 0

export draggedPanelItem    = 0
export draggedPanelSubItem = 0

export panelScroll       = 0.0
export panelScrollSource = 0.0
export panelScrollTarget = 0



local PanelState :: struct {
	panelY: int,
	fontH: int,
	mx: int,
	my: int,
	lastPanelY: int,
	panelItem: int,
}



local isHoveringPanelItemRectangle :: (state:PanelState, x,y,w,h:int) -> bool {
	return state.panelItem == draggedPanelItem
		or draggedPanelItem == 0 and state.mx >= x and state.mx < x+w and state.my >= y and state.my < y+h
}
local isHoveringPanelItemCircle :: (state:PanelState, x,y,radius:int) -> bool {
	return state.panelItem == draggedPanelItem
		or draggedPanelItem == 0 and math.distance(state.mx,state.my, x,y) <= radius
}

local isPressingOrMayPress :: (state:PanelState) -> (pressedMouseButton:int) {
	if state.panelItem == draggedPanelItem  return 1
	return draggedPanelItem == 0 ? pressedOnPanelWithMouseButton : 0
}



local drawChecker :: (x,y,w,h:float, scale=1.0) {
	static quad: LG.Quad = NULL

	if quad == NULL {
		local iw, ih = imageChecker.getDimensions!()
		quad         = LG.newQuad(0, 0, 1, 1, iw, ih)
	}

	quad.setViewport!(0, 0, w/scale, h/scale)
	LG.draw(imageChecker, quad, x, y, 0, scale)
}

local drawPanelSeparator :: (state:PanelState, thick=false) {
	local w = thick ? 6 : 2
	LG.setColor(0, 0, 0, .5)
	LG.rectangle(LG.DrawMode.FILL, 0, state.panelY, PANEL_WIDTH, w)
	state.lastPanelY  = state.panelY
	state.panelY     += w+PANEL_SPACING
}

local drawLabels :: (label1,label2:string, y:int) {
	LG.setColor(1, 1, 1)
	if label1 {
		LG.print(label1, PANEL_SPACING, y)
	}
	if label2 {
		LG.setFont(fontSmall)
		LG.print(label2, LABEL_WIDTH-fontSmall.getWidth!(label2), y+1)
		LG.setFont(fontNormal)
	}
}

local drawPanelDirection :: (state:PanelState, label1,label2:string, angle:float, slot=1, spreadCcw,spreadCw=0.0) -> (pressedMouseButton:int, angle:float) {
	state.panelItem += 1

	local RADIUS :: 25

	local x = LABEL_WIDTH+PANEL_SPACING+RADIUS + (slot-1)*(PANEL_SPACING+2*RADIUS)
	local y = state.panelY + RADIUS

	local hovered = isHoveringPanelItemCircle(state, x, y, RADIUS)
	local pressed = hovered ? isPressingOrMayPress(state) : 0
	if pressed == 1 {
		draggedPanelItem = state.panelItem
		angle            = math.atan(state.my-y, state.mx-x)

		if LK.isDown("lctrl","rctrl")  angle = math.round(angle*8/math.TAU)/8*math.TAU
	}

	drawLabels(label1, label2, math.round(y-state.fontH/2))

	LG.setColor(0, 0, 0)
	LG.circle(LG.DrawMode.FILL, x, y, RADIUS)
	LG.setColor(1, 1, 1, .25)
	if spreadCcw  LG.arc(LG.DrawMode.FILL, x, y, .8*RADIUS, angle-spreadCcw, angle, 32)
	if spreadCw   LG.arc(LG.DrawMode.FILL, x, y, .8*RADIUS, angle,  angle+spreadCw, 32)
	LG.setColor(1, 1, 1, GUIDE_LINE_OPACITY)
	LG.line(x-RADIUS+1, y, x+RADIUS-1, y)
	LG.line(x, y-RADIUS+1, x, y+RADIUS-1)
	if hovered {
		LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
		LG.circle(LG.DrawMode.LINE, x, y, RADIUS+.5)
	}
	LG.setColor(1, 1, 1)
	LG.line(x, y, x+RADIUS*math.cos(angle), y+RADIUS*math.sin(angle))

	if showPanelNumbers {
		local text  = format("%d°", angle*360/math.TAU)
		local textX = math.round(x-fontSmall.getWidth!(text)/2)
		local textY = (angle % math.TAU < math.PI) ? state.panelY+5 : state.panelY+2*RADIUS-5-fontSmall.getHeight!()
		LG.setFont(fontSmall)
		LG.setColor(0, 0, 0)
		LG.print(text, textX+1, textY+1)
		LG.setColor(1, 1, 1)
		LG.print(text, textX, textY)
		LG.setFont(fontNormal)
	}

	state.lastPanelY  = state.panelY
	state.panelY     += 2*RADIUS + PANEL_SPACING
	return pressed, angle
}

local drawSliderValue :: (sliderX,sliderY:float, sliderW,sliderH:float, value:float, readout:float, readoutFormat:string) {
	if showPanelNumbers and readoutFormat {
		local text = format(readoutFormat, readout)
		local x    = math.round(sliderX+(sliderW-fontSmall.getWidth!(text))/2)
		local y    = math.round(sliderY+(sliderH-fontSmall.getHeight!())/2)
		LG.setFont(fontSmall)
		LG.setColor(0, 0, 0)
		LG.print(text, x+1, y+1)
		LG.setColor(1, 1, 1)
		LG.print(text, x, y)
		LG.setFont(fontNormal)
	}
	do {
		local x = sliderX + value*(sliderW-4)
		LG.setColor(0, 0, 0)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, 4, sliderH)
		LG.setColor(1, 1, 1)
		LG.rectangle(LG.DrawMode.FILL, x+1, sliderY, 2, sliderH)
	}
}

local drawPanelSlider ::
	(
		state:PanelState, label1,label2:string, valueMin,valueMax:float, value:float,
		readoutMultiplier:float, readoutFormat:string, other:float|none=nil
	)
	-> (pressedMouseButton:int, value:float)
{
	state.panelItem += 1

	local w = PANEL_WIDTH-LABEL_WIDTH-2*PANEL_SPACING
	local h = state.fontH
	local x = LABEL_WIDTH+PANEL_SPACING
	local y = state.panelY

	local hovered = isHoveringPanelItemRectangle(state, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(state) : 0
	if pressed == 1 {
		draggedPanelItem = state.panelItem
		value            = math.lerp(valueMin, valueMax, math.clamp01((state.mx-x)/w))

		if LK.isDown("lctrl","rctrl")  value = math.lerp(valueMin, valueMax, math.round(math.clamp01((state.mx-x)/w)*16)/16)
	}

	drawLabels(label1, label2, state.panelY)

	LG.setColor(0, 0, 0)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
	if other ~= nil {
		local valueX = x+w*(           (value)-valueMin)/(valueMax-valueMin)
		local otherX = x+w*(cast(float)(other)-valueMin)/(valueMax-valueMin)
		LG.setColor(1, 1, 1, .25)
		LG.rectangle(LG.DrawMode.FILL, valueX, y+.25*h, otherX-valueX, h/2)
	}
	if hovered {
		LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
		LG.rectangle(LG.DrawMode.LINE, x-.5, y-.5, w+1, h+1)
	}
	LG.setColor(1, 1, 1, GUIDE_LINE_OPACITY)
	LG.rectangle(LG.DrawMode.FILL, x+.25*w, y, 1, h)
	LG.rectangle(LG.DrawMode.FILL, x+.50*w, y, 1, h)
	LG.rectangle(LG.DrawMode.FILL, x+.75*w, y, 1, h)
	drawSliderValue(x, y, w, h, (value-valueMin)/(valueMax-valueMin), value*readoutMultiplier, readoutFormat)

	state.lastPanelY  = state.panelY
	state.panelY     += h + PANEL_SPACING
	return pressed, value
}

local drawPanelColor :: (state:PanelState, label1,label2:string, r,g,b:float,a:float|none) -> (pressedMouseButton:int, r,g,b,a:float) {
	state.panelItem += 1

	local SLIDER_HEIGHT :: 12

	local w = PANEL_WIDTH-LABEL_WIDTH-2*PANEL_SPACING
	local h = SLIDER_HEIGHT * (a == nil ? 3 : 4)
	local x = LABEL_WIDTH+PANEL_SPACING
	local y = state.panelY

	!import "color"
	local hue, saturation, value = rgbToHsv(r, g, b)

	local hovered = isHoveringPanelItemRectangle(state, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(state) : 0
	if pressed == 1 {
		draggedPanelItem = state.panelItem

		if not draggedPanelSubItem {
			draggedPanelSubItem = math.clamp(math.floor(1+(state.my-y)/SLIDER_HEIGHT), 1, 4)
		}

		if draggedPanelSubItem == {
			case 1: hue        = math.clamp01((state.mx-x)/w) ; r, g, b = hsvToRgb(hue, saturation, value)
			case 2: saturation = math.clamp01((state.mx-x)/w) ; r, g, b = hsvToRgb(hue, saturation, value)
			case 3: value      = math.clamp01((state.mx-x)/w) ; r, g, b = hsvToRgb(hue, saturation, value)
			case 4: a          = math.clamp01((state.mx-x)/w)
		}
	}

	drawLabels(label1, label2, state.panelY)
	-- drawLabels(label1, label2, math.round(state.panelY+(h-state.fontH)/2))

	do {
		local iw, ih     = imageGradient.getDimensions!()
		local gradientSx = w/iw
		local gradientSy = SLIDER_HEIGHT/ih

		iw, ih           = imageRainbow.getDimensions!()
		local rainbowSx  = w/iw
		local rainbowSy  = SLIDER_HEIGHT/ih

		local sliderY    = y

		LG.setColor(1, 1, 1)
		LG.draw(imageRainbow, x, sliderY, 0, rainbowSx, rainbowSy)
		drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, hue, 360, "%d°")
		sliderY += SLIDER_HEIGHT

		local r2, g2, b2 = hsvToRgb(hue, 1, 1)
		LG.setColor(.5, .5, .5)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, SLIDER_HEIGHT)
		LG.setColor(r2, g2, b2)
		LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
		drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, saturation, 100, "%d%%")
		sliderY += SLIDER_HEIGHT

		r2, g2, b2 = hsvToRgb(hue, saturation, 1)
		LG.setColor(0, 0, 0)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, SLIDER_HEIGHT)
		LG.setColor(r2, g2, b2)
		LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
		drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, value, 100, "%d%%")
		sliderY += SLIDER_HEIGHT

		if a ~= nil {
			LG.setColor(.1, .1, .1)
			LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, SLIDER_HEIGHT)
			LG.setColor(.3, .3, .3)
			drawChecker(x, sliderY, w, SLIDER_HEIGHT)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
			drawSliderValue(x, sliderY, w, SLIDER_HEIGHT, cast(float)a, 100, "%d%%")
		}

		if hovered {
			local outlineY = y + ((state.my-y)//SLIDER_HEIGHT) * SLIDER_HEIGHT
			LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY_STRONG)
			LG.rectangle(LG.DrawMode.LINE, x-.5, outlineY-.5, w+1, SLIDER_HEIGHT+1)
		}
	}

	state.lastPanelY  = state.panelY
	state.panelY     += h + PANEL_SPACING
	return pressed, r,g,b,cast(float)a -- 'a' is actually nil if the function was called with a=nil.
}

local ButtonStyle :: enum { NORMAL, TABS }

local drawPanelButtons :: (state:PanelState, label1,label2:string, buttonLabels:[]string, selected=0, style=ButtonStyle.NORMAL, lastButtonWidth=0) -> (pressedMouseButton:int, pressedIndex:int) {
	state.panelItem += 1

	local highlightAll = (selected == 0)

	local x = (style == ButtonStyle.TABS) ? PANEL_SPACING : LABEL_WIDTH+PANEL_SPACING
	local y = state.panelY
	local w = PANEL_WIDTH - x-PANEL_SPACING
	local h = state.fontH

	local buttonW0 = lastButtonWidth ? (w-lastButtonWidth)/(#buttonLabels-1) : w/#buttonLabels

	local hovered = isHoveringPanelItemRectangle(state, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(state) : 0
	local pressedIndex: int

	if pressed {
		pressedIndex          = math.clamp(math.floor(1+(state.mx-x)/buttonW0), 1, #buttonLabels)
		scheduleSaveWorkspace = true
	}

	drawLabels(label1, label2, state.panelY)

	for buttonLabels {
		local buttonX1 = math.round(x + (itIndex-1)*buttonW0)
		local buttonX2 = math.round(x + (itIndex  )*buttonW0)
		local buttonW  = buttonW0

		if lastButtonWidth and itIndex == #buttonLabels {
			buttonX2 = x+w
			buttonW  = buttonX2-buttonX1
		}

		local padding = (style == ButtonStyle.TABS) ? 8 : 3

		local textX = buttonX1 + math.max(math.round((buttonW-fontNormal.getWidth!(it))/2), padding)
		local faded = not (highlightAll or itIndex == selected)

		if hovered and state.mx >= buttonX1 and state.mx < buttonX2
			LG.setColor(1, 1, 1, .45)
		elseif faded
			LG.setColor(1, 1, 1, .15)
		else
			LG.setColor(1, 1, 1, .3)

		if style == ButtonStyle.TABS {
			local inset = math.min(.6*h, buttonW/4)
			LG.polygon(LG.DrawMode.FILL, buttonX1,y+h, buttonX1+inset,y, buttonX2-inset,y, buttonX2,y+h)
		} else {
			LG.rectangle(LG.DrawMode.FILL, buttonX1+1, y+1, buttonX2-buttonX1-2, h-2, 3)
		}

		local scissorX1 = buttonX1+(padding-1)
		local scissorX2 = buttonX2-(padding-1)

		if scissorX2 > scissorX1 {
			LG.setScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
			LG.setColor(1, 1, 1, (faded ? .6 : 1.0))
			LG.print(it, textX, y)
			LG.setScissor()
		}
	}

	state.lastPanelY  = state.panelY
	state.panelY     += h + PANEL_SPACING
	return pressed, pressedIndex
}

export drawPanel :: () {
	local state: PanelState = {
		panelY = PANEL_SPACING,
		fontH  = fontNormal.getHeight!(),
		mx     = love.mouse.getX(),
		my     = love.mouse.getY()-math.round(panelScroll),
	}

	-- Note: Some things may render incorrectly for one frame if the user does
	-- something because we handle mouse input here while rendering.
	LG.setColor(.2, .2, .2)
	LG.rectangle(LG.DrawMode.FILL, 0, 0, PANEL_WIDTH, LG.getHeight())

	LG.translate(0, panelScroll)

	-- Project.
	local project = openProjects[currentProjectIndex]

	do {
		local buttonLabels: []string
		for openProjects  buttonLabels[itIndex] = "(unnamed)" -- Use filenames on tabs.

		insert(buttonLabels, "+")

		local pressed, i = drawPanelButtons(state, "", "", buttonLabels, selected=currentProjectIndex, style=ButtonStyle.TABS, lastButtonWidth=32)
		if pressed == 1 {
			if i < #buttonLabels {
				currentProjectIndex = i
			} else {
				addNewProject()
				currentProjectIndex = #openProjects
			}
			scheduleRecreateCanvases = true
			updateParticleImageFilters()

		} elseif pressed == 3 and i < #buttonLabels {
			-- @UX: Confirm closing project if there are changes.
			remove(openProjects, i)
			if openProjects[1] == NULL
				addNewProject()
			else
				currentProjectIndex = math.min(currentProjectIndex, #openProjects)

			scheduleRecreateCanvases = true
			updateParticleImageFilters()
		}
	}
	do {
		local BUTTON_LABELS :: {"show", "hide"}
		local pressed, i = drawPanelButtons(state, "Settings", "", BUTTON_LABELS, selected=(showProjectSettings ? 1 : 2))
		if pressed == 1  showProjectSettings = (i == 1)
	}
	if showProjectSettings {
		local pressed, i = drawPanelButtons(state, "PixelateWorld", "", BUTTON_LABELS_YES_NO, selected=(project.pixelateWorld ? 1 : 2))
		if pressed == 1 {
			project.pixelateWorld    = (i == 1)
			scheduleRecreateCanvases = true

			if project.pixelateWorld and project.zoomLevel < -1 {
				project.zoomLevel  = -1
				project.zoomSource = project.zoom
				project.zoomTarget = 2^project.zoomLevel
			}
		}
	}
	if showProjectSettings {
		local pressed, i = drawPanelButtons(state, "PixelateTextures", "", BUTTON_LABELS_YES_NO, selected=(project.pixelateTextures ? 1 : 2))
		if pressed == 1 {
			project.pixelateTextures = (i == 1)
			updateParticleImageFilters()
		}
	}
	if showProjectSettings {
		drawPanelSeparator(state)

		local pressed, r,g,b = drawPanelColor(state, "Background", "", project.bgColorR, project.bgColorG, project.bgColorB, nil)

		if pressed == 1 {
			project.bgColorR, project.bgColorG, project.bgColorB = r,g,b
		}
	}

	-- System.
	local system = project.systems[project.systemIndex]
	drawPanelSeparator(state, true)
	do {
		local doRemove = LK.isDown("lalt","ralt")

		local buttonLabels: []string
		for project.systems  buttonLabels[itIndex] = format("%d", itIndex)

		insert(buttonLabels, doRemove?"DEL":"+")

		local pressed, i = drawPanelButtons(state, "ParticleSystem", "", buttonLabels, selected=project.systemIndex, lastButtonWidth=32)
		if pressed ~= 1 {
			-- void

		} elseif i < #buttonLabels {
			project.systemIndex = i

		} elseif doRemove {
			remove(project.systems, project.systemIndex)
			if project.systems[1] == NULL
				addNewSystem(project)
			else
				project.systemIndex = math.min(project.systemIndex, #project.systems)
			system = project.systems[project.systemIndex]

		} else {
			addNewSystem(project)
			project.systemIndex = #project.systems
		}
	}

	-- Misc params.
	local ps = system.particles
	drawPanelSeparator(state, true)
	do {
		local BUTTON_LABELS :: {"top", "bottom", "random"}
		local INSERT_MODE_TO_INDEX: struct { !key:LG.ParticleInsertMode, !value:int } = {
			[LG.ParticleInsertMode.TOP]    = 1,
			[LG.ParticleInsertMode.BOTTOM] = 2,
			[LG.ParticleInsertMode.RANDOM] = 3,
		}
		local pressed, i = drawPanelButtons(state, "Insert", "", BUTTON_LABELS, selected=INSERT_MODE_TO_INDEX[ps.getInsertMode!()])
		if pressed == 1  if i == {
			case 1: ps.setInsertMode!(LG.ParticleInsertMode.TOP)
			case 2: ps.setInsertMode!(LG.ParticleInsertMode.BOTTOM)
			case 3: ps.setInsertMode!(LG.ParticleInsertMode.RANDOM)
		}
	}
	drawPanelSeparator(state)
	do {
		local lifetime = math.max(ps.getEmitterLifetime!(), 0)
		local pressed, ^lifetime = drawPanelSlider(state, "Lifetime", "emitter", 0, 20, lifetime,other=0, 1, (lifetime ? "%.2f sec" : "∞"))
		if pressed == 1 {
			ps.setEmitterLifetime!(lifetime ?: -1.0)
			if not lifetime  ps.start!()
		}
	}
	do {
		local min, max = ps.getParticleLifetime!()
		local pressedMin, ^min = drawPanelSlider(state, "", "particle min", 0, 20, min,other=max, 1, "%.2f sec")
		local pressedMax, ^max = drawPanelSlider(state, "", "particle max", 0, 20, max,other=min, 1, "%.2f sec")
		if pressedMin  max = math.max(min, max)
		if pressedMax  min = math.min(min, max)
		if pressedMin == 1 or pressedMax == 1  ps.setParticleLifetime!(min, max)
	}
	drawPanelSeparator(state, true)
	do {
		local pressed, rate = drawPanelSlider(state, "SpawnRate", "", .1, 1000, ps.getEmissionRate!(),other=0, 1, "%.1f / sec")
		if pressed == 1  ps.setEmissionRate!(rate)
	}
	drawPanelSeparator(state)
	do {
		using LG.AreaSpreadDistribution
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()

		local BUTTON_LABELS :: {"none", "uni", "norm", "ellip", "b.ellip", "b.rect"}
		local DISTRIBUTION_TO_INDEX: struct { !key:LG.AreaSpreadDistribution, !value:int } = {
			[NONE]             = 1,
			[UNIFORM]          = 2,
			[NORMAL]           = 3,
			[ELLIPSE]          = 4,
			[BORDER_ELLIPSE]   = 5,
			[BORDER_RECTANGLE] = 6,
		}
		local pressed1, i = drawPanelButtons(state, "Area", "distribution", BUTTON_LABELS, selected=DISTRIBUTION_TO_INDEX[distribution])
		if pressed1 == 1  if i == {
			case 1: distribution = NONE
			case 2: distribution = UNIFORM
			case 3: distribution = NORMAL
			case 4: distribution = ELLIPSE
			case 5: distribution = BORDER_ELLIPSE
			case 6: distribution = BORDER_RECTANGLE
		}

		if distribution == NONE {
			if pressed1 == 1  ps.setEmissionArea!(distribution, 0,0)

		} else {
			local pressed2, ^dx = drawPanelSlider(state, "", "dx", 0, 1000, dx,other=0, 1, "%d")
			local pressed3, ^dy = drawPanelSlider(state, "", "dy", 0, 1000, dy,other=0, 1, "%d")

			local pressed4, ^angle = drawPanelDirection(state, "", "angle", angle)

			local pressed5, ^i = drawPanelButtons(state, "", "dir relative to center", BUTTON_LABELS_YES_NO, selected=(relative ? 1 : 2))
			if pressed5 == 1  relative = (i == 1)

			if pressed1 == 1 or pressed2 == 1 or pressed3 == 1 or pressed4 == 1 or pressed5 == 1 {
				ps.setEmissionArea!(distribution, dx,dy, angle, relative)
			}
		}
	}
	drawPanelSeparator(state)
	do {
		local pressed, angle = drawPanelDirection(state, "Direction", "", ps.getDirection!(), spreadCcw=ps.getSpread!()/2,spreadCw=ps.getSpread!()/2)
		if pressed == 1  ps.setDirection!(angle)
	}
	do {
		local pressed, angle = drawPanelSlider(state, "", "spread", 0, math.TAU, ps.getSpread!(),other=0, 360/math.TAU, "%d°")
		if pressed == 1  ps.setSpread!(angle)
	}
	drawPanelSeparator(state, true)
	do {
		local min, max = ps.getSpeed!()
		local pressedMin, ^min = drawPanelSlider(state, "Speed", "min", -2000, 2000, min,other=max, 1, "%d / sec")
		local pressedMax, ^max = drawPanelSlider(state, "",      "max", -2000, 2000, max,other=min, 1, "%d / sec")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setSpeed!(min, max)
		}
	}
	drawPanelSeparator(state)
	do {
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		local pressedXmin, ^xmin = drawPanelSlider(state, "AccLinear", "xmin", -10000, 10000, xmin,other=xmax, 1, "%d / sec²")
		local pressedXmax, ^xmax = drawPanelSlider(state, "",          "xmax", -10000, 10000, xmax,other=xmin, 1, "%d / sec²")
		local pressedYmin, ^ymin = drawPanelSlider(state, "",          "ymin", -10000, 10000, ymin,other=ymax, 1, "%d / sec²")
		local pressedYmax, ^ymax = drawPanelSlider(state, "",          "ymax", -10000, 10000, ymax,other=ymin, 1, "%d / sec²")
		if pressedXmin == 1 or pressedXmax == 1 or pressedYmin == 1 or pressedYmax == 1 {
			if pressedXmin  xmax = math.max(xmin, xmax)
			if pressedXmax  xmin = math.min(xmin, xmax)
			if pressedYmin  ymax = math.max(ymin, ymax)
			if pressedYmax  ymin = math.min(ymin, ymax)
			ps.setLinearAcceleration!(xmin,ymin, xmax,ymax)
		}
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getRadialAcceleration!()
		local pressedMin, ^min = drawPanelSlider(state, "AccRadial", "min", -20000, 20000, min,other=max, 1, "%d / sec²")
		local pressedMax, ^max = drawPanelSlider(state, "",          "max", -20000, 20000, max,other=min, 1, "%d / sec²")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setRadialAcceleration!(min, max)
		}
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getTangentialAcceleration!()
		local pressedMin, ^min = drawPanelSlider(state, "AccTangent", "min", -20000, 20000, min,other=max, 1, "%d / sec²")
		local pressedMax, ^max = drawPanelSlider(state, "",           "max", -20000, 20000, max,other=min, 1, "%d / sec²")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setTangentialAcceleration!(min, max)
		}
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getLinearDamping!()
		local pressedMin, ^min = drawPanelSlider(state, "DampLinear", "min", -50, 50, min,other=max, 1, "%.2f")
		local pressedMax, ^max = drawPanelSlider(state, "",           "max", -50, 50, max,other=min, 1, "%.2f")
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setLinearDamping!(min, max)
		}
	}
	drawPanelSeparator(state, true)
	do {
		local min, max = ps.getRotation!()
		local pressedMin, ^min = drawPanelDirection(state, "Rotation", "min/max", min, slot=1, spreadCw=max-min) ; state.panelY = state.lastPanelY
		local pressedMax, ^max = drawPanelDirection(state, "",         "",        max, slot=2, spreadCcw=max-min)
		if pressedMin == 1 or pressedMax == 1 {
			-- if pressedMin  max = math.max(min, max)
			-- if pressedMax  min = math.min(min, max)
			ps.setRotation!(min, max)
		}
	}
	do {
		local pressed, i = drawPanelButtons(state, "", "relative", BUTTON_LABELS_YES_NO, selected=(ps.hasRelativeRotation!() ? 1 : 2))
		if pressed == 1  ps.setRelativeRotation!(i == 1)
	}
	drawPanelSeparator(state)
	do {
		local min, max = ps.getSpin!()
		local pressedMin, ^min = drawPanelSlider(state, "Spin", "at start", -8*math.TAU, 8*math.TAU, min,other=max, 1/math.TAU, "%.2f turns / sec")
		local pressedMax, ^max = drawPanelSlider(state, "",     "at end",   -8*math.TAU, 8*math.TAU, max,other=min, 1/math.TAU, "%.2f turns / sec")
		if pressedMin == 1 or pressedMax == 1  ps.setSpin!(min, max)
	}
	do {
		local pressed, variation = drawPanelSlider(state, "", "variation", 0, 1, ps.getSpinVariation!(),other=0, 100, "%d%%")
		if pressed == 1  ps.setSpinVariation!(variation)
	}
	--[[
	-- @Incomplete:
	ps.setQuads!(quad1,quad2)
	ps.setTexture!(texture)
	ps.setOffset!(x,y)
	ps.setBufferSize!(size) -- Automatically calculate this!
	]]

	-- Sizes.
	drawPanelSeparator(state, true)
	do {
		local sizes    = {ps.getSizesAsVararg!()}
		local doRemove = LK.isDown("lalt","ralt")
		local buttonLabels: []string

		if doRemove {
			for i = 1, #sizes  insert(buttonLabels, format("%d", i))
		} else {
			insert(buttonLabels, "+")
		}

		local pressed, i = drawPanelButtons(state, "Size", (doRemove ? "DEL" : ""), buttonLabels)

		if pressed ~= 1 {
			-- void

		} elseif doRemove {
			remove(sizes, i)
			if sizes[1] == NULL  insert(sizes, 1)
			ps.setSizes!(sizes)

		} elseif sizes[8] == NULL {
			insert(sizes, sizes[#sizes])
			ps.setSizes!(sizes)
		}
	}
	do {
		local sizes      = {ps.getSizesAsVararg!()}
		local anyPressed = false
		local moveAll    = LK.isDown("lctrl","rctrl") and LK.isDown("lshift","rshift")

		for i = 1, #sizes {
			local pressed, size = drawPanelSlider(state, "", format("#%d", i), 0, 8, sizes[i],other=0, 1, "%.2f")
			anyPressed          = anyPressed or pressed == 1

			if pressed ~= 1 {
				-- void
			} elseif not moveAll {
				sizes[i] = size
			} else {
				for j = 1, #sizes  sizes[j] = size
			}
		}
		if anyPressed  ps.setSizes!(sizes)
	}
	do {
		local pressed, variation = drawPanelSlider(state, "", "variation", 0, 1, ps.getSizeVariation!(),other=0, 100, "%d%%")
		if pressed == 1  ps.setSizeVariation!(variation)
	}

	-- Colors + blend mode.
	drawPanelSeparator(state)
	do {
		local colors   = system.colors
		local doRemove = LK.isDown("lalt","ralt")
		local buttonLabels: []string

		if doRemove {
			for i = 1, #colors//4  insert(buttonLabels, format("%d", i))
		} else {
			insert(buttonLabels, "+")
		}

		local pressed, i = drawPanelButtons(state, "Color", (doRemove ? "DEL" : ""), buttonLabels)

		if pressed ~= 1 {
			-- void

		} elseif doRemove {
			local colorIndex = i*4-3
			for 1, 4  remove(colors, colorIndex)

			if colors[1] == NULL {
				for 1, 4  insert(colors, 1)
			}

			ps.setColors!(colors)

		} elseif colors[8*4] == NULL {
			local lastColorIndex = (#colors//4)*4-3
			for 1, 4  insert(colors, colors[lastColorIndex+it-1])
			ps.setColors!(colors)
		}
	}
	do {
		local colors     = system.colors
		local anyPressed = false
		local moveAll    = LK.isDown("lctrl","rctrl") and LK.isDown("lshift","rshift")

		for i = 1, #colors, 4 {
			local pressed, r,g,b,a = drawPanelColor(state, "", format("#%d", (i+3)//4), colors[i], colors[i+1], colors[i+2], colors[i+3])
			anyPressed             = anyPressed or pressed == 1

			if pressed ~= 1 {
				-- void
			} elseif not moveAll {
				colors[i], colors[i+1], colors[i+2], colors[i+3] = r,g,b,a
			} elseif draggedPanelSubItem < 4 {
				for j = 1, #colors, 4  colors[j], colors[j+1], colors[j+2] = r,g,b
			} else {
				for j = 4, #colors, 4  colors[j] = a
			}
		}
		if anyPressed  ps.setColors!(colors)
	}
	do {
		local BUTTON_LABELS :: {"alpha", "add", "screen", "subtract"}
		local BLEND_MODE_TO_INDEX: struct { !key:LG.BlendMode, !value:int } = {
			[LG.BlendMode.ALPHA]    = 1,
			[LG.BlendMode.ADD]      = 2,
			[LG.BlendMode.SCREEN]   = 3,
			[LG.BlendMode.SUBTRACT] = 4,
		}
		local pressed, i = drawPanelButtons(state, "", "blend mode", BUTTON_LABELS, selected=BLEND_MODE_TO_INDEX[system.blendMode])
		if pressed == 1  if i == {
			case 1: system.blendMode = LG.BlendMode.ALPHA
			case 2: system.blendMode = LG.BlendMode.ADD
			case 3: system.blendMode = LG.BlendMode.SCREEN
			case 4: system.blendMode = LG.BlendMode.SUBTRACT
		}
	}
	drawPanelSeparator(state, true)

	pressedOnPanelWithMouseButton = 0
}


