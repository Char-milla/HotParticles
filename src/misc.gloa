--[[============================================================
--=
--=  Misc stuff
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	InputField
	ModifierKey

	addRecent
	compareFilenames
	getModifierKey
	isInside
	limitArray
	newMonochromeImage, newImageUsingPalette
	normalizeDirectoryPath

--============================================================]]



export ModifierKey :: enum { NONE::0, C, A, S, CA, CS, AS, CAS }



export InputField :: !foreign struct {
	Alignment :: enum {
		LEFT  :: "left",
		RIGHT :: "right",
	},
	Side :: enum {
		START :: "start",
		END   :: "end",
	},

	!call :: (initialText="") -> InputField !foreign lua "require'src.InputField'",

	update                 :: (self:InputField, dt:float) !foreign method "update",
	getBlinkPhase          :: (self:InputField) -> float !foreign method "getBlinkPhase",
	resetBlinking          :: (self:InputField) !foreign method "resetBlinking",
	getCursor              :: (self:InputField) -> int !foreign method "getCursor",
	setCursor              :: (self:InputField, pos:int)                        !foreign method "setCursor",
	setCursor              :: (self:InputField, pos:int,    selSideAnchor:Side) !foreign method "setCursor",
	moveCursor             :: (self:InputField, amount:int)                     !foreign method "moveCursor",
	moveCursor             :: (self:InputField, amount:int, selSideAnchor:Side) !foreign method "moveCursor",
	getCursorSelectionSide :: (self:InputField) -> Side !foreign method "getCursorSelectionSide",
	getAnchorSelectionSide :: (self:InputField) -> Side !foreign method "getAnchorSelectionSide",
	getFont                :: (self:InputField) -> LG.Font !foreign method "getFont",
	setFont                :: (self:InputField, font:LG.Font) !foreign method "setFont",
	getScroll              :: (self:InputField) -> (scroll:int) !foreign method "getScroll",
	setScroll              :: (self:InputField, scroll:int) !foreign method "setScroll",
	getSelection           :: (self:InputField) -> (from,to:int) !foreign method "getSelection",
	setSelection           :: (self:InputField, from,to:int, cursorAlign=Alignment.RIGHT) !foreign method "setSelection",
	selectAll              :: (self:InputField) !foreign method "selectAll",
	getSelectedText        :: (self:InputField) -> string !foreign method "getSelectedText",
	getSelectedVisibleText :: (self:InputField) -> string !foreign method "getSelectedVisibleText",
	getText                :: (self:InputField) -> string !foreign method "getText",
	setText                :: (self:InputField, text:string, replaceLastHistoryEntry=false) !foreign method "setText",
	getVisibleText         :: (self:InputField) -> string !foreign method "getVisibleText",
	getTextLength          :: (self:InputField) -> int !foreign method "getTextLength",
	getTextOffset          :: (self:InputField) -> int !foreign method "getTextOffset",
	getCursorOffset        :: (self:InputField) -> int !foreign method "getCursorOffset",
	getSelectionOffset     :: (self:InputField) -> int, int !foreign method "getSelectionOffset",
	getWidth               :: (self:InputField) -> int !foreign method "getWidth",
	setWidth               :: (self:InputField, width:int) !foreign method "setWidth",
	insert                 :: (self:InputField, newText:string) !foreign method "insert",
	replace                :: (self:InputField, newText:string) !foreign method "replace",
	isFontFilteringActive  :: (self:InputField) -> bool !foreign method "isFontFilteringActive",
	setFontFilteringActive :: (self:InputField, state:bool) !foreign method "setFontFilteringActive",
	isPasswordActive       :: (self:InputField) -> bool !foreign method "isPasswordActive",
	setPasswordActive      :: (self:InputField, state:bool) !foreign method "setPasswordActive",
	isEditable             :: (self:InputField) -> bool !foreign method "isEditable",
	setEditable            :: (self:InputField, state:bool) !foreign method "setEditable",
	CharacterFilter        :: (char:string) -> (filterOut:bool),
	getFilter              :: (self:InputField) -> (filter:CharacterFilter) !foreign method "getFilter",
	setFilter              :: (self:InputField, filter:CharacterFilter)     !foreign method "setFilter",
	setFilter              :: (self:InputField)                             !foreign method "setFilter",
	clearHistory           :: (self:InputField) !foreign method "clearHistory",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int)              -> (wasHandled:bool) !foreign method "mousepressed",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int, presses:int) -> (wasHandled:bool) !foreign method "mousepressed",
	mousemoved             :: (self:InputField, mx,my:int) -> (wasHandled:bool) !foreign method "mousemoved",
	mousereleased          :: (self:InputField, mx,my:int, mbutton:int) -> (wasHandled:bool) !foreign method "mousereleased",
	keypressed             :: (self:InputField, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (wasHandled:bool, wasEdited:bool) !foreign method "keypressed",
	textinput              :: (self:InputField, text:string) -> (wasHandled:bool, wasEdited:bool) !foreign method "textinput",
}



export getModifierKey :: () -> ModifierKey {
	local ctrl  = LK.isDown("lctrl","rctrl")
	local alt   = LK.isDown("lalt","ralt")
	local shift = LK.isDown("lshift","rshift")
	return
		ctrl and alt and shift ? ModifierKey.CAS :
		ctrl and alt           ? ModifierKey.CA  :
		ctrl and shift         ? ModifierKey.CS  :
		alt  and shift         ? ModifierKey.AS  :
		ctrl                   ? ModifierKey.C   :
		alt                    ? ModifierKey.A   :
		shift                  ? ModifierKey.S   :
		ModifierKey.NONE
}



export isInside :: (x,y:int, areaX,areaY,areaW,areaH:int) -> bool {
	return x >= areaX and y >= areaY and x < areaX+areaW and y < areaY+areaH
}



export normalizeDirectoryPath :: (path:string) -> (path:string) {
	path = replace(path, "\\", "/")

	-- Note: Network paths or weird paths ("C:foo.png") are not supported.
	local      ok, drive, root, dir =     matchPattern(path, "^(%a:)(/)(.*)")
	if not ok  ok, drive, root, dir =     matchPattern(path, "^(~)(/)(.*)")
	if not ok  drive, ok, root, dir = "", matchPattern(path, "^(/?)(.*)")

	local segments: []string
	for segment in eachPatternMatch(cast(string)dir, "[^/]+") {
		insert(segments, cast(string)segment)
	}
	for #segments, 1, -1 {
		if segments[it] == "."  remove(segments, it)
	}

	local i = 1
	while segments[i] ~= NULL {
		if segments[i+1] == ".." and segments[i] ~= ".." {
			remove(segments, i+1)
			remove(segments, i)
			i = math.max(i-1, 1)
		} else {
			i = i+1
		}
	}

	if segments[1] == NULL  segments[1] = "." -- Prevent an empty string or a trailing slash so it's easy to append stuff to the resulting path.
	return cast(string)drive .. cast(string)root .. concatinate(segments, "/")
}



--[[
	pixelRow: String with single-digit hexadecimal numbers. Invalid characters count as 0.
	Example:
		antialiasedDiagonalLine = Gui.newMonochromeImage{
			" 5F",
			"5F5",
			"F5 ",
		}
]]
export newMonochromeImage :: (pixelRows:[]string) -> LG.Image {
	return newMonochromeImage(pixelRows, 1, 1, 1)
}
export newMonochromeImage :: (pixelRows:[]string, r,g,b:float) -> LG.Image {
	local imageData = love.image.newImageData(#pixelRows[1], #pixelRows)

	for pixelRow, row: pixelRows {
		for col = 1, #pixelRow {
			local ok, pixel = stringToInt(getSubstring(pixelRow, col, col), 16)
			if not ok  pixel = 0

			imageData.setPixel!(col-1, row-1, r,g,b,pixel/15)
		}
	}

	return LG.newImage(imageData)
}

--[[
	pixelRow: String with single-character palette indices. Invalid indices count as transparent pixels.
	palette = { ["char1"]="rgb[a=1]", ... }
	Example:
		doubleWideRainbow = Gui.newImageUsingPalette(
			{
				"rygcbp",
				"rygcbp",
			}, {
				r = "F00", -- Red
				y = "FF0", -- Yellow
				g = "0F0", -- Green
				c = "0FF", -- Cyan
				b = "00F", -- Blue
				p = "F0F", -- Purple
			}
		)
]]
export newImageUsingPalette :: (pixelRows:[]string, palette:struct{!key:string,!value:string}) -> LG.Image {
	local TRANSPARENT: []float : {1,1,1,0}
	local imageData = love.image.newImageData(#pixelRows[1], #pixelRows)

	for pixelRow, row: pixelRows {
		for col = 1, #pixelRow {
			local pixel = palette[getSubstring(pixelRow, col, col)]
			local color = palette[pixel]
			if color == NULL  color = "0000"

			local _,  r = stringToInt(getSubstring(color, 1, 1))
			local _,  g = stringToInt(getSubstring(color, 2, 2))
			local _,  b = stringToInt(getSubstring(color, 3, 3))
			local ok, a = stringToInt(getSubstring(color, 4, 4))
			if not ok  a = 0

			imageData.setPixel!(col-1, row-1, r/15,g/15,b/15,a/15)
		}
	}

	return LG.newImage(imageData)
}



export compareFilenames :: (a,b:string) -> bool {
	for 1, math.min(#a, #b) {
		local aByte = a[it]
		local bByte = b[it]

		-- Case-insensitive ASCII.
		if aByte >= !char "a" and aByte <= !char "z"  aByte = aByte - !char "a" + !char "A"
		if bByte >= !char "a" and bByte <= !char "z"  bByte = bByte - !char "a" + !char "A"

		if aByte ~= bByte {
			local aIsDigit          = (aByte >= !char "0" and aByte <= !char "9")
			local bIsDigit          = (bByte >= !char "0" and bByte <= !char "9")
			local aIsAlphaOrUnicode = aIsDigit or (aByte >= !char "A" and aByte <= !char "Z") or aByte >= 128
			local bIsAlphaOrUnicode = bIsDigit or (bByte >= !char "A" and bByte <= !char "Z") or bByte >= 128

			if aIsAlphaOrUnicode ~= bIsAlphaOrUnicode  return bIsAlphaOrUnicode

			-- Natural sorting for numbers.
			if aIsDigit and bIsDigit {
				local _, aIntStr = matchPattern(a, "^%d+", it)
				local _, bIntStr = matchPattern(b, "^%d+", it)
				local _, aInt    = stringToInt(cast(string)aIntStr)
				local _, bInt    = stringToInt(cast(string)bIntStr)
				return aInt < bInt
			}

			return toLower(getSubstring(a, it, it)) < toLower(getSubstring(b, it, it))
		}
	}
	return toLower(a) < toLower(b)
}



export limitArray :: (array:[]any, maxLength:int) {
	for #array+1, maxLength  array[it] = nil
}



export addRecent :: (list:[]string, item:string, maxItems:int) {
	local found, i = indexOf(list, item)
	if found {
		remove(list, i)
		insert(list, 1, item)
	} else {
		insert(list, 1, item)
		limitArray(list, maxItems)
	}
}



export splitDirectoryAndFilename :: (path:string) -> (dir:string, filename:string) {
	local ok, dir, filename = matchPattern(path, "^(.*)/([^/]+)$")
	if not ok  return  ".", path

	return cast(string)dir, cast(string)filename
}

export splitBasenameAndExtension :: (filename:string, keepDot=false) -> (basename:string, ext:string) {
	local pattern = keepDot ? "^(.+)(%.[^.]+)$" : "^(.+)%.([^.]+)$"

	local ok, basename, ext = matchPattern(filename, pattern)
	if not ok  return  filename, ""

	return cast(string)basename, cast(string)ext
}


