--[[============================================================
--=
--=  Misc stuff
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

export ModifierKey :: enum { NONE::0, C, A, S, CA, CS, AS, CAS }

export InputField :: !foreign struct {
	Alignment :: enum {
		LEFT  :: "left",
		RIGHT :: "right",
	},
	Side :: enum {
		START :: "start",
		END   :: "end",
	},

	!call :: (initialText="") -> InputField !foreign lua "require'src.InputField'",

	update                 :: (self:InputField, dt:float) !foreign method "update",
	getBlinkPhase          :: (self:InputField) -> float !foreign method "getBlinkPhase",
	resetBlinking          :: (self:InputField) !foreign method "resetBlinking",
	getCursor              :: (self:InputField) -> int !foreign method "getCursor",
	setCursor              :: (self:InputField, pos:int)                        !foreign method "setCursor",
	setCursor              :: (self:InputField, pos:int,    selSideAnchor:Side) !foreign method "setCursor",
	moveCursor             :: (self:InputField, amount:int)                     !foreign method "moveCursor",
	moveCursor             :: (self:InputField, amount:int, selSideAnchor:Side) !foreign method "moveCursor",
	getCursorSelectionSide :: (self:InputField) -> Side !foreign method "getCursorSelectionSide",
	getAnchorSelectionSide :: (self:InputField) -> Side !foreign method "getAnchorSelectionSide",
	getFont                :: (self:InputField) -> LG.Font !foreign method "getFont",
	setFont                :: (self:InputField, font:LG.Font) !foreign method "setFont",
	getScroll              :: (self:InputField) -> (scroll:int) !foreign method "getScroll",
	setScroll              :: (self:InputField, scroll:int) !foreign method "setScroll",
	getSelection           :: (self:InputField) -> (from,to:int) !foreign method "getSelection",
	setSelection           :: (self:InputField, from,to:int, cursorAlign=Alignment.RIGHT) !foreign method "setSelection",
	selectAll              :: (self:InputField) !foreign method "selectAll",
	getSelectedText        :: (self:InputField) -> string !foreign method "getSelectedText",
	getSelectedVisibleText :: (self:InputField) -> string !foreign method "getSelectedVisibleText",
	getText                :: (self:InputField) -> string !foreign method "getText",
	setText                :: (self:InputField, text:string, replaceLastHistoryEntry=false) !foreign method "setText",
	getVisibleText         :: (self:InputField) -> string !foreign method "getVisibleText",
	getTextLength          :: (self:InputField) -> int !foreign method "getTextLength",
	getTextOffset          :: (self:InputField) -> int !foreign method "getTextOffset",
	getCursorOffset        :: (self:InputField) -> int !foreign method "getCursorOffset",
	getSelectionOffset     :: (self:InputField) -> int, int !foreign method "getSelectionOffset",
	getWidth               :: (self:InputField) -> int !foreign method "getWidth",
	setWidth               :: (self:InputField, width:int) !foreign method "setWidth",
	insert                 :: (self:InputField, newText:string) !foreign method "insert",
	replace                :: (self:InputField, newText:string) !foreign method "replace",
	isFontFilteringActive  :: (self:InputField) -> bool !foreign method "isFontFilteringActive",
	setFontFilteringActive :: (self:InputField, state:bool) !foreign method "setFontFilteringActive",
	isPasswordActive       :: (self:InputField) -> bool !foreign method "isPasswordActive",
	setPasswordActive      :: (self:InputField, state:bool) !foreign method "setPasswordActive",
	isEditable             :: (self:InputField) -> bool !foreign method "isEditable",
	setEditable            :: (self:InputField, state:bool) !foreign method "setEditable",
	CharacterFilter        :: (char:string) -> (filterOut:bool),
	getFilter              :: (self:InputField) -> (filter:CharacterFilter) !foreign method "getFilter",
	setFilter              :: (self:InputField, filter:CharacterFilter)     !foreign method "setFilter",
	setFilter              :: (self:InputField)                             !foreign method "setFilter",
	clearHistory           :: (self:InputField) !foreign method "clearHistory",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int)              -> (wasHandled:bool) !foreign method "mousepressed",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int, presses:int) -> (wasHandled:bool) !foreign method "mousepressed",
	mousemoved             :: (self:InputField, mx,my:int) -> (wasHandled:bool) !foreign method "mousemoved",
	mousereleased          :: (self:InputField, mx,my:int, mbutton:int) -> (wasHandled:bool) !foreign method "mousereleased",
	keypressed             :: (self:InputField, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (wasHandled:bool, wasEdited:bool) !foreign method "keypressed",
	textinput              :: (self:InputField, text:string) -> (wasHandled:bool, wasEdited:bool) !foreign method "textinput",
}

export getModifierKey :: () -> ModifierKey {
	local ctrl  = LK.isDown("lctrl","rctrl")
	local alt   = LK.isDown("lalt","ralt")
	local shift = LK.isDown("lshift","rshift")
	return
		ctrl and alt and shift ? ModifierKey.CAS :
		ctrl and alt           ? ModifierKey.CA  :
		ctrl and shift         ? ModifierKey.CS  :
		alt  and shift         ? ModifierKey.AS  :
		ctrl                   ? ModifierKey.C   :
		alt                    ? ModifierKey.A   :
		shift                  ? ModifierKey.S   :
		ModifierKey.NONE
}

export isInside :: (x,y:int, areaX,areaY,areaW,areaH:int) -> bool {
	return x >= areaX and y >= areaY and x < areaX+areaW and y < areaY+areaH
}

export normalizeDirectoryPath :: (path:string) -> (path:string) {
	path = replace(path, "\\", "/")

	-- Note: Network paths or weird paths ("C:foo.png") are not supported.
	local      ok, drive, root, dir =     matchPattern(path, "^(%a:)(/)(.*)")
	if not ok  ok, drive, root, dir =     matchPattern(path, "^(~)(/)(.*)")
	if not ok  drive, ok, root, dir = "", matchPattern(path, "^(/?)(.*)")

	local segments: []string
	for segment in eachPatternMatch(cast(string)dir, "[^/]+") {
		insert(segments, cast(string)segment)
	}
	for #segments, 1, -1 {
		if segments[it] == "."  remove(segments, it)
	}

	local i = 1
	while segments[i] ~= NULL {
		if segments[i+1] == ".." and segments[i] ~= ".." {
			remove(segments, i+1)
			remove(segments, i)
			i = math.max(i-1, 1)
		} else {
			i = i+1
		}
	}

	if segments[1] == NULL  segments[1] = "." -- Prevent an empty string or a trailing slash so it's easy to append stuff to the resulting path.
	return cast(string)drive .. cast(string)root .. concatinate(segments, "/")
}
