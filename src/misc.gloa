--[[============================================================
--=
--=  Misc stuff
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	InputField
	ModifierKey

	addRecent
	compareFilenames
	getModifierKey
	isInside
	isPathAbsolute
	limitArray
	newMonochromeImage, newImageUsingPalette
	normalizeDirectoryPath, normalizeFilePath
	prepareSandbox

--============================================================]]



export ModifierKey :: enum { NONE::0, C, A, S, CA, CS, AS, CAS }



export InputField :: !foreign struct {
	Alignment :: enum {
		LEFT  :: "left",
		RIGHT :: "right",
	},
	Side :: enum {
		START :: "start",
		END   :: "end",
	},

	!call :: (initialText="") -> InputField !foreign lua "require'src.InputField'",

	update                 :: (self:InputField, dt:float) !foreign method "update",
	getBlinkPhase          :: (self:InputField) -> float !foreign method "getBlinkPhase",
	resetBlinking          :: (self:InputField) !foreign method "resetBlinking",
	getCursor              :: (self:InputField) -> int !foreign method "getCursor",
	setCursor              :: (self:InputField, pos:int)                        !foreign method "setCursor",
	setCursor              :: (self:InputField, pos:int,    selSideAnchor:Side) !foreign method "setCursor",
	moveCursor             :: (self:InputField, amount:int)                     !foreign method "moveCursor",
	moveCursor             :: (self:InputField, amount:int, selSideAnchor:Side) !foreign method "moveCursor",
	getCursorSelectionSide :: (self:InputField) -> Side !foreign method "getCursorSelectionSide",
	getAnchorSelectionSide :: (self:InputField) -> Side !foreign method "getAnchorSelectionSide",
	getFont                :: (self:InputField) -> LG.Font !foreign method "getFont",
	setFont                :: (self:InputField, font:LG.Font) !foreign method "setFont",
	getScroll              :: (self:InputField) -> (scroll:int) !foreign method "getScroll",
	setScroll              :: (self:InputField, scroll:int) !foreign method "setScroll",
	getSelection           :: (self:InputField) -> (from,to:int) !foreign method "getSelection",
	setSelection           :: (self:InputField, from,to:int, cursorAlign=Alignment.RIGHT) !foreign method "setSelection",
	selectAll              :: (self:InputField) !foreign method "selectAll",
	getSelectedText        :: (self:InputField) -> string !foreign method "getSelectedText",
	getSelectedVisibleText :: (self:InputField) -> string !foreign method "getSelectedVisibleText",
	getText                :: (self:InputField) -> string !foreign method "getText",
	setText                :: (self:InputField, text:string, replaceLastHistoryEntry=false) !foreign method "setText",
	getVisibleText         :: (self:InputField) -> string !foreign method "getVisibleText",
	getTextLength          :: (self:InputField) -> int !foreign method "getTextLength",
	getTextOffset          :: (self:InputField) -> int !foreign method "getTextOffset",
	getCursorOffset        :: (self:InputField) -> int !foreign method "getCursorOffset",
	getSelectionOffset     :: (self:InputField) -> int, int !foreign method "getSelectionOffset",
	getWidth               :: (self:InputField) -> int !foreign method "getWidth",
	setWidth               :: (self:InputField, width:int) !foreign method "setWidth",
	insert                 :: (self:InputField, newText:string) !foreign method "insert",
	replace                :: (self:InputField, newText:string) !foreign method "replace",
	isFontFilteringActive  :: (self:InputField) -> bool !foreign method "isFontFilteringActive",
	setFontFilteringActive :: (self:InputField, state:bool) !foreign method "setFontFilteringActive",
	isPasswordActive       :: (self:InputField) -> bool !foreign method "isPasswordActive",
	setPasswordActive      :: (self:InputField, state:bool) !foreign method "setPasswordActive",
	isEditable             :: (self:InputField) -> bool !foreign method "isEditable",
	setEditable            :: (self:InputField, state:bool) !foreign method "setEditable",
	CharacterFilter        :: (char:string) -> (filterOut:bool),
	getFilter              :: (self:InputField) -> (filter:CharacterFilter) !foreign method "getFilter",
	setFilter              :: (self:InputField, filter:CharacterFilter)     !foreign method "setFilter",
	setFilter              :: (self:InputField)                             !foreign method "setFilter",
	clearHistory           :: (self:InputField) !foreign method "clearHistory",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int)              -> (wasHandled:bool) !foreign method "mousepressed",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int, presses:int) -> (wasHandled:bool) !foreign method "mousepressed",
	mousemoved             :: (self:InputField, mx,my:int) -> (wasHandled:bool) !foreign method "mousemoved",
	mousereleased          :: (self:InputField, mx,my:int, mbutton:int) -> (wasHandled:bool) !foreign method "mousereleased",
	keypressed             :: (self:InputField, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (wasHandled:bool, wasEdited:bool) !foreign method "keypressed",
	textinput              :: (self:InputField, text:string) -> (wasHandled:bool, wasEdited:bool) !foreign method "textinput",
}



export getModifierKey :: () -> ModifierKey {
	local ctrl  = LK.isDown("lctrl","rctrl")
	local alt   = LK.isDown("lalt","ralt")
	local shift = LK.isDown("lshift","rshift")
	return
		ctrl and alt and shift ? ModifierKey.CAS :
		ctrl and alt           ? ModifierKey.CA  :
		ctrl and shift         ? ModifierKey.CS  :
		alt  and shift         ? ModifierKey.AS  :
		ctrl                   ? ModifierKey.C   :
		alt                    ? ModifierKey.A   :
		shift                  ? ModifierKey.S   :
		ModifierKey.NONE
}



export isInside :: (x,y:int, areaX,areaY,areaW,areaH:int) -> bool {
	return x >= areaX and y >= areaY and x < areaX+areaW and y < areaY+areaH
}



export isPathAbsolute :: (path:string) -> bool {
	return findPattern(path, "^%a:") or findPattern(path, "^/") or findPattern(path, "^~")
}



local normalizePath :: (path:string) -> string {
	path = replacePattern(path, "[\\/]+", "/")
	return path
}

export normalizeDirectoryPath :: (path:string) -> (path:string, drive,root,dir:string) {
	-- Note: Network paths are not supported.
	-- Paths like "C:foo.txt" are assumed to be mistyped and become "C:/foo.txt".
	path = normalizePath(path)

	local      ok, drive, rootAndDir = matchPattern(path, "^(%a:)(.*)")
	if not ok  ok, drive, rootAndDir = matchPattern(path, "^(~)(.*)")
	if not ok      drive, rootAndDir = "", path

	local _, root, dir = matchPattern(cast(string)rootAndDir, "^(/?)(.*)")
	if drive ~= "" and root == ""  root = "/"

	local segments: []string
	for segment in eachPatternMatch(cast(string)dir, "[^/]+") {
		insert(segments, cast(string)segment)
	}
	for #segments, 1, -1 {
		if segments[it] == "."  remove(segments, it)
	}

	local i = 1
	while segments[i] ~= NULL {
		if segments[i+1] == ".." and segments[i] ~= ".." {
			remove(segments, i+1)
			remove(segments, i)
			i = math.max(i-1, 1)
		} else {
			i = i+1
		}
	}

	if root ~= "" {
		while segments[1] == ".."  remove(segments, 1)
	}

	if segments[1] == NULL  segments[1] = "." -- Prevent an empty string or a trailing slash so it's easy to append stuff to the resulting path.
	dir = concatinate(segments, "/")

	path = cast(string)drive .. cast(string)root .. cast(string)dir
	return path, cast(string)drive, cast(string)root, cast(string)dir
}

export normalizeFilePath :: (path:string) -> (path:string) {
	path = normalizePath(path)

	local dirSection, filename = splitDirectoryAndFilename(path, keepSlash=true)
	local _, drive, root, dir  = normalizeDirectoryPath(dirSection)

	return drive .. root .. (dir == "." ? filename : dir.."/"..filename)
}

--[[ Path normalization tests:
!run {
	local DIRS :: {
		"C:/foo/bar",             "C:/foo/bar",
		"C:../foo/bar",           "C:/foo/bar",
		"/majestic/doggo/.",      "/majestic/doggo",
		"~/Only trees",           "~/Only trees",
		"My Game/src/",           "My Game/src",
		"./cutest/cat/..",        "cutest",
		"ceiling/cat/../..",      ".",
		"../almighty/cricket/..", "../almighty",
		"",                       ".",
		".",                      ".",
		"..",                     "..",
		"foo/../..",              "..",
		"C:/",                    "C:/.",
		"C/",                     "C",
		"C:foo",                  "C:/foo",
		"/",                      "/.",
	}
	local FILES :: {
		"C:/foo/bar/a.txt",             "C:/foo/bar/a.txt",
		"C:../foo/bar/a.txt",           "C:/foo/bar/a.txt",
		"/majestic/doggo/./a.txt",      "/majestic/doggo/a.txt",
		"~/Only trees/a.txt",           "~/Only trees/a.txt",
		"./cutest/cat/../a.txt",        "cutest/a.txt",
		"ceiling/cat/../../a.txt",      "a.txt",
		"../almighty/cricket/../a.txt", "../almighty/a.txt",
		"",                             "",
		"a.txt",                        "a.txt",
		"./a.txt",                      "a.txt",
		"../a.txt",                     "../a.txt",
		"foo/../../a.txt",              "../a.txt",
		"C:/a.txt",                     "C:/a.txt",
		"C/a.txt",                      "C/a.txt",
		"C:foo/a.txt",                  "C:/foo/a.txt",
		"/a.txt",                       "/a.txt",
	}

	for 1, #DIRS, 2 {
		printf('DIR  IN   "%s"', DIRS[it])
		printf('DIR  OUT  "%s"', (normalizeDirectoryPath(DIRS[it])))
		printf('DIR  WANT "%s"', DIRS[it+1])
		assert(normalizeDirectoryPath(DIRS[it]) == DIRS[it+1])
		print(20 * "-")
	}
	for 1, #FILES, 2 {
		printf('FILE IN   "%s"', FILES[it])
		printf('FILE OUT  "%s"', normalizeFilePath(FILES[it]))
		printf('FILE WANT "%s"', FILES[it+1])
		assert(normalizeFilePath(FILES[it]) == FILES[it+1])
		print(20 * "-")
	}

	print("All tests passed!")
	!import"os".exit(2)
}
--]]



--[[
	pixelRow: String with single-digit hexadecimal numbers. Invalid characters count as 0.
	Example:
		antialiasedDiagonalLine = Gui.newMonochromeImage{
			" 5F",
			"5F5",
			"F5 ",
		}
]]
export newMonochromeImage :: (pixelRows:[]string) -> LG.Image {
	return newMonochromeImage(pixelRows, 1, 1, 1)
}
export newMonochromeImage :: (pixelRows:[]string, r,g,b:float) -> LG.Image {
	local imageData = LI.newImageData(#pixelRows[1], #pixelRows)

	for pixelRow, row: pixelRows {
		for col = 1, #pixelRow {
			local ok, pixel = stringToInt(getSubstring(pixelRow, col, col), 16)
			if not ok  pixel = 0

			imageData.setPixel!(col-1, row-1, r,g,b,pixel/15)
		}
	}

	return LG.newImage(imageData)
}

--[[
	pixelRow: String with single-character palette indices. Invalid indices count as transparent pixels.
	palette = { ["char1"]="rgb[a=1]", ... }
	Example:
		doubleWideRainbow = Gui.newImageUsingPalette(
			{
				"rygcbp",
				"rygcbp",
			}, {
				r = "F00", -- Red
				y = "FF0", -- Yellow
				g = "0F0", -- Green
				c = "0FF", -- Cyan
				b = "00F", -- Blue
				p = "F0F", -- Purple
			}
		)
]]
export newImageUsingPalette :: (pixelRows:[]string, palette:struct{!key:string,!value:string}) -> LG.Image {
	local TRANSPARENT: []float : {1,1,1,0}
	local imageData = LI.newImageData(#pixelRows[1], #pixelRows)

	for pixelRow, row: pixelRows {
		for col = 1, #pixelRow {
			local pixel = palette[getSubstring(pixelRow, col, col)]
			local color = palette[pixel]
			if color == NULL  color = "0000"

			local _,  r = stringToInt(getSubstring(color, 1, 1))
			local _,  g = stringToInt(getSubstring(color, 2, 2))
			local _,  b = stringToInt(getSubstring(color, 3, 3))
			local ok, a = stringToInt(getSubstring(color, 4, 4))
			if not ok  a = 0

			imageData.setPixel!(col-1, row-1, r/15,g/15,b/15,a/15)
		}
	}

	return LG.newImage(imageData)
}



export compareFilenames :: (a,b:string) -> bool {
	for 1, math.min(#a, #b) {
		local aByte = a[it]
		local bByte = b[it]

		-- Case-insensitive ASCII.
		if aByte >= !char "a" and aByte <= !char "z"  aByte = aByte - !char "a" + !char "A"
		if bByte >= !char "a" and bByte <= !char "z"  bByte = bByte - !char "a" + !char "A"

		if aByte ~= bByte {
			local aIsDigit          = (aByte >= !char "0" and aByte <= !char "9")
			local bIsDigit          = (bByte >= !char "0" and bByte <= !char "9")
			local aIsAlphaOrUnicode = aIsDigit or (aByte >= !char "A" and aByte <= !char "Z") or aByte >= 128
			local bIsAlphaOrUnicode = bIsDigit or (bByte >= !char "A" and bByte <= !char "Z") or bByte >= 128

			if aIsAlphaOrUnicode ~= bIsAlphaOrUnicode  return bIsAlphaOrUnicode

			-- Natural sorting for numbers.
			if aIsDigit and bIsDigit {
				local _, aIntStr = matchPattern(a, "^%d+", it)
				local _, bIntStr = matchPattern(b, "^%d+", it)
				local _, aInt    = stringToInt(cast(string)aIntStr)
				local _, bInt    = stringToInt(cast(string)bIntStr)
				return aInt < bInt
			}

			return toLower(getSubstring(a, it, it)) < toLower(getSubstring(b, it, it))
		}
	}
	return toLower(a) < toLower(b)
}



export limitArray :: (array:[]any, maxLength:int) {
	for maxLength+1, #array  array[it] = nil
}



export addRecent :: (list:[]string, item:string, maxItems:int) {
	local found, i = indexOf(list, item)
	if found  remove(list, i)

	insert(list, 1, item)
	limitArray(list, maxItems)
}



export splitDirectoryAndFilename :: (path:string, keepSlash=false) -> (dir:string, filename:string) {
	-- @Robustness: Handle the filename being "." or "..".
	path = replacePattern(path, "/+$", "") -- Trailing slashes are actually an error!

	local pattern = keepSlash ? "^(.*/)([^/]+)$" : "^(.*)/([^/]+)$"

	local ok, dir, filename = matchPattern(path, pattern)
	if ok  return cast(string)dir, cast(string)filename

	-- There's no slash at this point.

	local ^ok, drive, ^filename = matchPattern(path, "^(%a:)(.*)")
	if ok  return (cast(string)drive)..(keepSlash ? "/" : ""), cast(string)filename

	ok, drive, filename = matchPattern(path, "^(~)(.*)")
	if ok  return (cast(string)drive)..(keepSlash ? "/" : ""), cast(string)filename

	return "", path
}

export splitBasenameAndExtension :: (filename:string, keepDot=false) -> (basename:string, ext:string) {
	local pattern = keepDot ? "^(.+)(%.[^.]+)$" : "^(.+)%.([^.]+)$"

	local ok, basename, ext = matchPattern(filename, pattern)
	if not ok  return  filename, ""

	return cast(string)basename, cast(string)ext
}



export trim :: (s:string) -> string {
	return (replacePattern(replacePattern(s, "^%s+", ""), "%s+$", ""))
}



export prepareSandbox :: (globals:table) -> (env:table) {
	local setMetatable :: (t:table, metatable:table) -> table !foreign lua "setmetatable"

	local indexTable: table = {
		_VERSION = cast(any) !foreign lua "_VERSION",
		assert   = cast(any) !foreign lua "assert",
		error    = cast(any) !foreign lua "error",
		ipairs   = cast(any) !foreign lua "ipairs",
		next     = cast(any) !foreign lua "next",
		pairs    = cast(any) !foreign lua "pairs",
		print    = cast(any) !foreign lua "print",
		select   = cast(any) !foreign lua "select",
		tonumber = cast(any) !foreign lua "tonumber",
		tostring = cast(any) !foreign lua "tostring",
		type     = cast(any) !foreign lua "type",
		unpack   = cast(any) !foreign lua "unpack",

		math = {
			abs        = cast(any) !foreign lua "math.abs",
			acos       = cast(any) !foreign lua "math.acos",
			asin       = cast(any) !foreign lua "math.asin",
			atan       = cast(any) !foreign lua "math.atan",
			atan2      = cast(any) !foreign lua "math.atan2",
			ceil       = cast(any) !foreign lua "math.ceil",
			cos        = cast(any) !foreign lua "math.cos",
			cosh       = cast(any) !foreign lua "math.cosh",
			deg        = cast(any) !foreign lua "math.deg",
			exp        = cast(any) !foreign lua "math.exp",
			floor      = cast(any) !foreign lua "math.floor",
			fmod       = cast(any) !foreign lua "math.fmod",
			frexp      = cast(any) !foreign lua "math.frexp",
			huge       = cast(any) !foreign lua "math.huge",
			ldexp      = cast(any) !foreign lua "math.ldexp",
			log        = cast(any) !foreign lua "math.log",
			log10      = cast(any) !foreign lua "math.log10",
			max        = cast(any) !foreign lua "math.max",
			min        = cast(any) !foreign lua "math.min",
			modf       = cast(any) !foreign lua "math.modf",
			pi         = cast(any) !foreign lua "math.pi",
			pow        = cast(any) !foreign lua "math.pow",
			rad        = cast(any) !foreign lua "math.rad",
			random     = cast(any) !foreign lua "math.random",
			randomseed = cast(any) !foreign lua "math.randomseed",
			sin        = cast(any) !foreign lua "math.sin",
			sinh       = cast(any) !foreign lua "math.sinh",
			sqrt       = cast(any) !foreign lua "math.sqrt",
			tan        = cast(any) !foreign lua "math.tan",
			tanh       = cast(any) !foreign lua "math.tanh",
		},

		os = {
			clock    = cast(any) !foreign lua "os.clock",
			date     = cast(any) !foreign lua "os.date",
			difftime = cast(any) !foreign lua "os.difftime",
			getenv   = cast(any) !foreign lua "os.getenv",
			time     = cast(any) !foreign lua "os.time",
		},

		\string = {
			-- Note: Everything in the string metatable should be safe for usercode to access.
			byte    = cast(any) !foreign lua "string.byte",
			char    = cast(any) !foreign lua "string.char",
			dump    = cast(any) !foreign lua "string.dump", -- Should be no problem.
			find    = cast(any) !foreign lua "string.find",
			format  = cast(any) !foreign lua "string.format",
			gmatch  = cast(any) !foreign lua "string.gmatch",
			gsub    = cast(any) !foreign lua "string.gsub",
			len     = cast(any) !foreign lua "string.len",
			lower   = cast(any) !foreign lua "string.lower",
			match   = cast(any) !foreign lua "string.match",
			rep     = cast(any) !foreign lua "string.rep",
			reverse = cast(any) !foreign lua "string.reverse",
			sub     = cast(any) !foreign lua "string.sub",
			upper   = cast(any) !foreign lua "string.upper",
		},

		\table = {
			concat = cast(any) !foreign lua "table.concat",
			insert = cast(any) !foreign lua "table.insert",
			maxn   = cast(any) !foreign lua "table.maxn",
			remove = cast(any) !foreign lua "table.remove",
			sort   = cast(any) !foreign lua "table.sort",
		},
	}

	local env: table
	indexTable._G = env

	for globals  indexTable[itIndex] = it

	setMetatable(env, {
		__newindex = (templateEnv:table, k:any, v:any) {
			errorf(2, "cannot add global '%s' (globals are disabled)", toString(k))
		},
		__index = indexTable,
	})

	return env
}


