--[[============================================================
--=
--=  GUI panels
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	ContextMenu

	blurFocus
	hideContextMenu
	isInsidePanels
	scrollPanels
	pushAuxPanel, popAuxPanel, isAuxPanelVisible
	stopDraggingInPanels
	updatePanels, drawPanels

--============================================================]]

export PROJECT_PANEL_WIDTH :: PROJECT_MAIN_LABEL_WIDTH + 350
export     AUX_PANEL_WIDTH ::     AUX_MAIN_LABEL_WIDTH + 350

local PROJECT_MAIN_LABEL_WIDTH  :: 100
local     AUX_MAIN_LABEL_WIDTH  :: 80

local INNER_LABEL_WIDTH :: 40
local PANEL_SPACING     :: 3

local GUIDE_LINE_OPACITY           :: .14
local HOVER_OUTLINE_OPACITY        :: .3
local HOVER_OUTLINE_OPACITY_STRONG :: .5

local CONTEXT_MENU_MIN_WIDTH :: 120
local CONTEXT_MENU_PADDING_X :: 15
local CONTEXT_MENU_PADDING_Y :: 5

local COLOR_SLIDER_HEIGHT :: 12
local COLOR_PREVIEW_WIDTH :: 24

local ACTION_PASTE_COLOR  :: -1
local ACTION_PASTE_SCALAR :: -2
local ACTION_DELETE       :: -3

local BUTTONS_YES_NO: []Button : {
	{label="yes"},
	{label="no"},
}



export pressedOnPanelWithMouseButton = 0
export shiftScrolledOnPanel          = 0

local focusedPanelItem    = 0
local draggedPanelItem    = 0
local draggedPanelSubItem = 0

local contextMenu: ContextMenu = NULL

local clipboardScalar: float   = NULL
local clipboardAngle:  float   = NULL
local clipboardColor:  []float = NULL -- {h,s,v,a}

local panelItemForContextMenu = 0
local contextMenuAction       = 0 -- E.g. "paste the hue" in a color field.

local tooltipRendered  = false
local tooltipHoverTime = 0.00
local tooltipOpacity   = 0.0

local auxPanelStack: []AuxPanel
local auxPanel = AuxPanel.NONE
local auxPanelData: any
local auxPanelScroll       = 0.0
local auxPanelScrollSource = 0.0
local auxPanelScrollTarget = 0

export focus: struct {
	x: int,
	y: int,
	width: int,
	height: int,
	valueX: int,
	isPressing = false,
	field: InputField = NULL,
} = NULL



export AuxPanel :: enum { NONE::0, EXIT, SAVE_PROJECT_AS, OPEN_PROJECT, CONFIRM_OVERWRITE_FILE }

local Align       :: enum { LEFT, RIGHT, CENTER }
local ButtonStyle :: enum { NORMAL, TABS }

local Button :: struct {
	label   = "",
	tooltip = "",
	image   = "",
	value: any,
}

local Panel :: struct {
	baseX: int,
	baseY: int,
	width: int,
	mainLabelWidth: int,

	isAux: bool,

	x: int,
	y: int,

	maxPanelItemX: int,
	maxPanelItemY: int,

	mx: int,
	my: int,
	myScrolled: int,

	hasScrollableSection = false,
	ignoreMouseAboveY    = 0,

	mod: ModifierKey = NULL,

	panelItem: int,

	showedContextMenuThisFrame = false,
	isHoveringInput            = false,

	!call :: () -> Panel {
		local mx, my = LM.getPosition()
		return {
			mx  = mx,
			my  = my,
			mod = getModifierKey(),
		}
	},

	reset :: (panel:Panel, baseX,baseY:int, width:int, mainLabelWidth:int, isAux:bool) {
		panel.baseX          = baseX
		panel.baseY          = baseY
		panel.width          = width
		panel.mainLabelWidth = mainLabelWidth

		panel.isAux = isAux

		panel.x = baseX + mainLabelWidth + PANEL_SPACING
		panel.y = baseY + PANEL_SPACING

		panel.maxPanelItemX = baseX + mainLabelWidth
		panel.maxPanelItemY = 0

		panel.hasScrollableSection = false
		panel.ignoreMouseAboveY    = 0
		panel.myScrolled           = panel.my
	},
}

export ContextMenu :: struct {
	x:        int,
	y:        int,
	width:    int,
	height:   int,
	items:    []string,
	callback: (choice:int) = NULL,
}

export InputField :: !foreign struct {
	Alignment :: enum {
		LEFT  :: "left",
		RIGHT :: "right",
	},
	Side :: enum {
		START :: "start",
		END   :: "end",
	},

	!call :: (initialText="") -> InputField !foreign lua "require'src.InputField'",

	update                 :: (self:InputField, dt:float) !foreign method "update",
	getBlinkPhase          :: (self:InputField) -> float !foreign method "getBlinkPhase",
	resetBlinking          :: (self:InputField) !foreign method "resetBlinking",
	getCursor              :: (self:InputField) -> int !foreign method "getCursor",
	setCursor              :: (self:InputField, pos:int)                        !foreign method "setCursor",
	setCursor              :: (self:InputField, pos:int,    selSideAnchor:Side) !foreign method "setCursor",
	moveCursor             :: (self:InputField, amount:int)                     !foreign method "moveCursor",
	moveCursor             :: (self:InputField, amount:int, selSideAnchor:Side) !foreign method "moveCursor",
	getCursorSelectionSide :: (self:InputField) -> Side !foreign method "getCursorSelectionSide",
	getAnchorSelectionSide :: (self:InputField) -> Side !foreign method "getAnchorSelectionSide",
	getFont                :: (self:InputField) -> LG.Font !foreign method "getFont",
	setFont                :: (self:InputField, font:LG.Font) !foreign method "setFont",
	getScroll              :: (self:InputField) -> (scroll:int) !foreign method "getScroll",
	setScroll              :: (self:InputField, scroll:int) !foreign method "setScroll",
	getSelection           :: (self:InputField) -> (from,to:int) !foreign method "getSelection",
	setSelection           :: (self:InputField, from,to:int, cursorAlign=Alignment.RIGHT) !foreign method "setSelection",
	selectAll              :: (self:InputField) !foreign method "selectAll",
	getSelectedText        :: (self:InputField) -> string !foreign method "getSelectedText",
	getSelectedVisibleText :: (self:InputField) -> string !foreign method "getSelectedVisibleText",
	getText                :: (self:InputField) -> string !foreign method "getText",
	setText                :: (self:InputField, text:string, replaceLastHistoryEntry=false) !foreign method "setText",
	getVisibleText         :: (self:InputField) -> string !foreign method "getVisibleText",
	getTextLength          :: (self:InputField) -> int !foreign method "getTextLength",
	getTextOffset          :: (self:InputField) -> int !foreign method "getTextOffset",
	getCursorOffset        :: (self:InputField) -> int !foreign method "getCursorOffset",
	getSelectionOffset     :: (self:InputField) -> int, int !foreign method "getSelectionOffset",
	getWidth               :: (self:InputField) -> int !foreign method "getWidth",
	setWidth               :: (self:InputField, width:int) !foreign method "setWidth",
	insert                 :: (self:InputField, newText:string) !foreign method "insert",
	replace                :: (self:InputField, newText:string) !foreign method "replace",
	isFontFilteringActive  :: (self:InputField) -> bool !foreign method "isFontFilteringActive",
	setFontFilteringActive :: (self:InputField, state:bool) !foreign method "setFontFilteringActive",
	isPasswordActive       :: (self:InputField) -> bool !foreign method "isPasswordActive",
	setPasswordActive      :: (self:InputField, state:bool) !foreign method "setPasswordActive",
	isEditable             :: (self:InputField) -> bool !foreign method "isEditable",
	setEditable            :: (self:InputField, state:bool) !foreign method "setEditable",
	CharacterFilter        :: (char:string) -> (filterOut:bool),
	getFilter              :: (self:InputField) -> (filter:CharacterFilter) !foreign method "getFilter",
	setFilter              :: (self:InputField, filter:CharacterFilter)     !foreign method "setFilter",
	setFilter              :: (self:InputField)                             !foreign method "setFilter",
	clearHistory           :: (self:InputField) !foreign method "clearHistory",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int)              -> (wasHandled:bool) !foreign method "mousepressed",
	mousepressed           :: (self:InputField, mx,my:int, mbutton:int, presses:int) -> (wasHandled:bool) !foreign method "mousepressed",
	mousemoved             :: (self:InputField, mx,my:int) -> (wasHandled:bool) !foreign method "mousemoved",
	mousereleased          :: (self:InputField, mx,my:int, mbutton:int) -> (wasHandled:bool) !foreign method "mousereleased",
	keypressed             :: (self:InputField, key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) -> (wasHandled:bool, wasEdited:bool) !foreign method "keypressed",
	textinput              :: (self:InputField, text:string) -> (wasHandled:bool, wasEdited:bool) !foreign method "textinput",
}



local drawChecker :: (x,y,w,h:float, scale=1.0) {
	static quad: LG.Quad = NULL

	if quad == NULL {
		local iw, ih = imageChecker.getDimensions!()
		quad         = LG.newQuad(0, 0, 1, 1, iw, ih)
	}

	quad.setViewport!(0, 0, w/scale, h/scale)
	LG.draw(imageChecker, quad, x, y, 0, scale)
}

local drawCheckerBox :: (x,y,w,h:int) {
	LG.setColor(.15, .15, .15)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h)
	LG.setColor(.27, .27, .27)
	drawChecker(x, y, w, h)
}

local drawLabels :: (panel:Panel, label1,label2:string, x,y:int, large=false) {
	LG.setColor(1, 1, 1)
	if label1 {
		if large  LG.setFont(fontLarge)
		LG.print(label1, panel.baseX+PANEL_SPACING, y)
	}
	if label2 {
		LG.setFont(fontSmall)
		LG.print(label2, x-PANEL_SPACING-fontSmall.getWidth!(label2), y+1)
	}
	LG.setFont(fontNormal)
}

local drawTooltip :: (text:string, x,y:int) {
	local PADDING_Y :: 2

	local w = fontNormal.getWidth!(text) + 2*PANEL_SPACING
	local h = fontNormal.getHeight!()    + 2*PADDING_Y

	x = math.min(x, LG.getWidth()-w)
	y = y-h-1

	LG.pushAll()
	LG.setScissor()

	LG.setColor(.8, .8, .8, tooltipOpacity)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h, 3)
	LG.setColor(0, 0, 0, tooltipOpacity)
	LG.print(text, x+PANEL_SPACING, y+PADDING_Y)

	LG.pop()

	tooltipRendered = true
}



local drawPanelSeparator :: (panel:Panel, thick=false) {
	local w = thick ? 5 : 1

	LG.setColor(0, 0, 0, (thick ? .3 : .2))
	LG.rectangle(LG.DrawMode.FILL, panel.baseX, panel.y, panel.width, w)

	gotoNextRow(panel)
	occupy(panel, panel.width, w)
	gotoNextRow(panel)
}

local drawPanelLabel :: (panel:Panel, label:string, small=false) {
	drawLabels(panel, label, "", panel.x, panel.y, large=(not small))
	occupy(panel, panel.width, (small ? fontNormal : fontLarge).getHeight!())
}

local drawPanelDirection :: (panel:Panel, label1,label2:string, angle:float, spreadCcw,spreadCw=0.0) -> (pressedMouseButton:int, angle:float) {
	panel.panelItem += 1

	local RADIUS :: 25

	local x = panel.x + RADIUS
	local y = panel.y + RADIUS

	local hovered = isHoveringPanelItemCircle(panel, x, y, RADIUS)
	local pressed = hovered ? isPressingOrMayPress(panel) : 0

	if pressed == 1 {
		draggedPanelItem = panel.panelItem
		angle            = math.atan(panel.myScrolled-y, panel.mx-x)
		if panel.mod == ModifierKey.C  angle = math.round(angle * 8/math.TAU) / 8*math.TAU

	} elseif pressed == 2 {
		local ITEMS :: {"Copy angle","Paste angle"}
		local panelItem = panel.panelItem

		showContextMenu(panel, ITEMS, [angle,panelItem] (choice:int) {
			if choice == {
				case 1: clipboardAngle = angle
				case 2: panelItemForContextMenu, contextMenuAction = panelItem, 0
			}
		})

	} elseif panel.panelItem == panelItemForContextMenu {
		if clipboardAngle ~= NULL {
			angle                 = clipboardAngle
			pressed               = 1
			scheduleSaveWorkspace = true
		}

	} elseif hovered and (keysPressedThisFrame.left or keysPressedThisFrame.right) {
		local delta = math.TAU * ((panel.mod == ModifierKey.S) ? 45/360 : (panel.mod == ModifierKey.C) ? 1/360 : 5/360)
		angle       = ((keysPressedThisFrame.left ? angle-delta : angle+delta) + math.PI) % math.TAU - math.PI
		pressed     = 1
		scheduleSaveWorkspace = true
	}

	drawLabels(panel, label1, label2, x-RADIUS, math.round(y-fontNormal.getHeight!()/2))

	LG.setColor(0, 0, 0)
	LG.circle(LG.DrawMode.FILL, x, y, RADIUS)
	LG.setColor(1, 1, 1, .25)
	if spreadCcw  LG.arc(LG.DrawMode.FILL, x, y, .8*RADIUS, angle-spreadCcw, angle, 32)
	if spreadCw   LG.arc(LG.DrawMode.FILL, x, y, .8*RADIUS, angle,  angle+spreadCw, 32)
	LG.setColor(1, 1, 1, GUIDE_LINE_OPACITY)
	LG.line(x-RADIUS+1, y, x+RADIUS-1, y)
	LG.line(x, y-RADIUS+1, x, y+RADIUS-1)
	if hovered {
		LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
		LG.circle(LG.DrawMode.LINE, x, y, RADIUS+.5)
	}
	LG.setColor(1, 1, 1)
	LG.line(x, y, x+RADIUS*math.cos(angle), y+RADIUS*math.sin(angle))

	if showPanelNumbers {
		local text  = format("%d°", angle*360/math.TAU)
		local textX = math.round(x-fontSmall.getWidth!(text)/2)
		local textY = (angle % math.TAU < math.PI) ? panel.y+5 : panel.y+2*RADIUS-5-fontSmall.getHeight!()
		LG.setFont(fontSmall)
		LG.setColor(0, 0, 0)
		LG.print(text, textX+1, textY+1)
		LG.setColor(1, 1, 1)
		LG.print(text, textX, textY)
		LG.setFont(fontNormal)
	}

	occupy(panel, 2*RADIUS, 2*RADIUS)
	return pressed, angle
}

local drawSliderValue :: (sliderX,sliderY:float, sliderW,sliderH:float, value:float, readout:float, readoutFormat:string) {
	if showPanelNumbers and readoutFormat {
		local text = format(readoutFormat, readout)
		local x    = math.round(sliderX+(sliderW-fontSmall.getWidth!(text))/2)
		local y    = math.round(sliderY+(sliderH-fontSmall.getHeight!())/2)
		LG.setFont(fontSmall)
		LG.setColor(0, 0, 0)
		LG.print(text, x+1, y+1)
		LG.setColor(1, 1, 1)
		LG.print(text, x, y)
		LG.setFont(fontNormal)
	}
	do {
		local x = math.round(sliderX + value*(sliderW-4))
		LG.setColor(0, 0, 0)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, 4, sliderH)
		LG.setColor(1, 1, 1)
		LG.rectangle(LG.DrawMode.FILL, x+1, sliderY, 2, sliderH)
	}
}

local drawPanelSlider :: (panel:Panel,
	label1,label2:string, valueMin,valueMax:float, value:float,
	readoutMultiplier:float, readoutFormat:string, other:float|none=nil, enableDelete=false, inset=0, width=0
) -> (
	pressedMouseButton:int, value:float, deleted:bool
) {
	panel.panelItem += 1

	local x = panel.x + inset
	local y = panel.y
	local w = width ?: (panel.baseX+panel.width) - PANEL_SPACING - x
	local h = fontNormal.getHeight!()

	local hovered = isHoveringPanelItemRectangle(panel, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(panel) : 0

	local deleted = false

	if pressed == 1 {
		draggedPanelItem = panel.panelItem
		value            = math.lerp(valueMin, valueMax, math.clamp01((panel.mx-x)/w))
		if panel.mod == ModifierKey.C  value = math.lerp(valueMin, valueMax, math.round(math.clamp01((panel.mx-x)/w)*16)/16)

	} elseif pressed == 2 {
		local panelItem = panel.panelItem

		local items = {
			"Copy value",
			"Paste value",
		}
		if enableDelete  insert(items, "Delete value")

		showContextMenu(panel, items, [value,panelItem] (choice:int) {
			if choice == {
				case 1: clipboardScalar = value
				case 2: panelItemForContextMenu, contextMenuAction = panelItem, ACTION_PASTE_SCALAR
				case 3: panelItemForContextMenu, contextMenuAction = panelItem, ACTION_DELETE
			}
		})

	} elseif panel.panelItem == panelItemForContextMenu {
		if contextMenuAction == ACTION_PASTE_SCALAR {
			if clipboardScalar ~= NULL {
				value                 = math.clamp(clipboardScalar, valueMin, valueMax)
				pressed               = 1
				scheduleSaveWorkspace = true
			}

		} elseif contextMenuAction == ACTION_DELETE {
			deleted = true
			scheduleSaveWorkspace = true
		}

	} elseif hovered and (keysPressedThisFrame.left or keysPressedThisFrame.right) {
		local delta           = (valueMax-valueMin) * ((panel.mod == ModifierKey.S) ? 1/16 : (panel.mod == ModifierKey.C) ? 1/1024 : 1/128)
		value                 = math.clamp((keysPressedThisFrame.left ? value-delta : value+delta), valueMin, valueMax)
		pressed               = 1
		scheduleSaveWorkspace = true
	}

	drawLabels(panel, label1, label2, x, y)

	-- Background.
	LG.setColor(0, 0, 0)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h)

	-- The other value.
	if other ~= nil {
		local valueX = (x+2) + (w-4) * (           (value)-valueMin) / (valueMax-valueMin)
		local otherX = (x+2) + (w-4) * (cast(float)(other)-valueMin) / (valueMax-valueMin)
		LG.setColor(1, 1, 1, .25)
		LG.rectangle(LG.DrawMode.FILL, valueX, y+.25*h, otherX-valueX, h/2)
	}

	-- Hover effect.
	if hovered {
		LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
		LG.rectangle(LG.DrawMode.LINE, x-.5, y-.5, w+1, h+1)
	}

	-- Guide lines.
	LG.setColor(1, 1, 1, GUIDE_LINE_OPACITY)
	LG.rectangle(LG.DrawMode.FILL, x+.25*w, y, 1, h)
	LG.rectangle(LG.DrawMode.FILL, x+.50*w, y, 1, h)
	LG.rectangle(LG.DrawMode.FILL, x+.75*w, y, 1, h)

	-- The actual value.
	drawSliderValue(x, y, w, h, (value-valueMin)/(valueMax-valueMin), value*readoutMultiplier, readoutFormat)

	occupy(panel, inset+w, h)
	return pressed, value, deleted
}

local drawPanelColor :: (panel:Panel,
	label1,label2:string, hue,saturation,value:float,a:float|none, enableDelete=false, showPreview=true
) -> (
	pressedMouseButton:int, hue,saturation,value,a:float, deleted:bool, pressedComponent:int
) {
	panel.panelItem += 1

	local components = (a == nil ? 3 : 4)

	local x = panel.x
	local y = panel.y
	local w = panel.width - panel.mainLabelWidth - COLOR_PREVIEW_WIDTH - 3*PANEL_SPACING
	local h = COLOR_SLIDER_HEIGHT * components

	local hovered = isHoveringPanelItemRectangle(panel, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(panel) : 0

	local component = math.clamp(math.floor(1+(panel.myScrolled-y)/COLOR_SLIDER_HEIGHT), 1, components)

	local deleted = false

	if pressed == 1 {
		draggedPanelItem = panel.panelItem

		if not draggedPanelSubItem  draggedPanelSubItem = component
		component = draggedPanelSubItem

		local theValue = (panel.mx-x)/w
		local steps    = component == 1 ? 24 : 16

		if panel.mod == ModifierKey.C or panel.mod == ModifierKey.CS
			theValue = math.round(math.clamp01((panel.mx-x)/w)*steps)/steps

		theValue = math.clamp01(theValue)

		if component == {
			case 1: hue        = theValue
			case 2: saturation = theValue
			case 3: value      = theValue
			case 4: a          = theValue
		}

	} elseif pressed == 2 {
		local panelItem = panel.panelItem

		local componentTitle: string = NULL
		if component == {
			case 1: componentTitle = "hue"
			case 2: componentTitle = "saturation"
			case 3: componentTitle = "value strength"
			case 4: componentTitle = "opacity"
		}

		local items = {
			"Copy "..componentTitle,
			"Copy color",
			"Paste "..componentTitle,
			"Paste color",
		}
		if enableDelete  insert(items, "Delete color")

		showContextMenu(panel, items, [hue,saturation,value,a,panelItem,component] (choice:int) {
			if choice == {
				case 1:
					if component == {
						case 1: clipboardScalar = hue
						case 2: clipboardScalar = saturation
						case 3: clipboardScalar = value
						case 4: clipboardScalar = cast(float) a
					}
				case 2: clipboardColor = {hue, saturation, value, (a == NULL ? 1.0 : cast(float)a)}
				case 3: panelItemForContextMenu, contextMenuAction = panelItem, component
				case 4: panelItemForContextMenu, contextMenuAction = panelItem, ACTION_PASTE_COLOR
				case 5: panelItemForContextMenu, contextMenuAction = panelItem, ACTION_DELETE
			}
		})

	} elseif panel.panelItem == panelItemForContextMenu {
		if contextMenuAction == ACTION_PASTE_COLOR {
			if clipboardColor ~= NULL {
				hue        = clipboardColor[1]
				saturation = clipboardColor[2]
				value      = clipboardColor[3]
				a          = clipboardColor[4]
				pressed    = 1
				scheduleSaveWorkspace = true
			}

		} elseif contextMenuAction == ACTION_DELETE {
			deleted = true
			scheduleSaveWorkspace = true

		} elseif contextMenuAction > 0 {
			component = contextMenuAction
			if clipboardScalar ~= NULL {
				if component == {
					case 1: hue        = math.clamp01(clipboardScalar)
					case 2: saturation = math.clamp01(clipboardScalar)
					case 3: value      = math.clamp01(clipboardScalar)
					case 4: a          = math.clamp01(clipboardScalar)
				}
				pressed = 1
				scheduleSaveWorkspace = true
			}
		}

	} elseif hovered and (keysPressedThisFrame.left or keysPressedThisFrame.right) {
		local delta = ((panel.mod == ModifierKey.S) ? 16/255 : (panel.mod == ModifierKey.C) ? 1/255 : 4/255)
		if component == {
			case 1: hue        = math.clamp01((keysPressedThisFrame.left ? hue            - delta : hue            + delta))
			case 2: saturation = math.clamp01((keysPressedThisFrame.left ? saturation     - delta : saturation     + delta))
			case 3: value      = math.clamp01((keysPressedThisFrame.left ? value          - delta : value          + delta))
			case 4: a          = math.clamp01((keysPressedThisFrame.left ? cast(float)(a) - delta : cast(float)(a) + delta))
		}
		pressed               = 1
		scheduleSaveWorkspace = true
	}

	drawLabels(panel, label1, label2, x, y)
	-- drawLabels(panel, label1, label2, x, math.round(y+(h-fontNormal.getHeight!())/2))

	-- Preview.
	local r, g, b = hsvToRgb(hue, saturation, value)

	if showPreview {
		local previewX = panel.baseX + panel.width - PANEL_SPACING - COLOR_PREVIEW_WIDTH
		drawCheckerBox(previewX, y, COLOR_PREVIEW_WIDTH, h)
		LG.setColor(r, g, b, (a == nil ? 1.0 : cast(float)a))
		LG.rectangle(LG.DrawMode.FILL, previewX, y, COLOR_PREVIEW_WIDTH, h)
	}

	-- Components.
	do {
		local iw, ih     = imageGradient.getDimensions!()
		local gradientSx = w/iw
		local gradientSy = COLOR_SLIDER_HEIGHT/ih

		iw, ih           = imageRainbow.getDimensions!()
		local rainbowSx  = w/iw
		local rainbowSy  = COLOR_SLIDER_HEIGHT/ih

		local sliderY    = y

		LG.setColor(1, 1, 1)
		LG.draw(imageRainbow, x, sliderY, 0, rainbowSx, rainbowSy)
		drawSliderValue(x, sliderY, w, COLOR_SLIDER_HEIGHT, hue, hue*360, "%d°")
		sliderY += COLOR_SLIDER_HEIGHT

		local r2, g2, b2 = hsvToRgb(hue, 1, 1)
		LG.setColor(.5, .5, .5)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, COLOR_SLIDER_HEIGHT)
		LG.setColor(r2, g2, b2)
		LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
		drawSliderValue(x, sliderY, w, COLOR_SLIDER_HEIGHT, saturation, saturation*100, "%d%%")
		sliderY += COLOR_SLIDER_HEIGHT

		r2, g2, b2 = hsvToRgb(hue, saturation, 1)
		LG.setColor(0, 0, 0)
		LG.rectangle(LG.DrawMode.FILL, x, sliderY, w, COLOR_SLIDER_HEIGHT)
		LG.setColor(r2, g2, b2)
		LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
		drawSliderValue(x, sliderY, w, COLOR_SLIDER_HEIGHT, value, value*100, "%d%%")
		sliderY += COLOR_SLIDER_HEIGHT

		if a ~= nil {
			drawCheckerBox(x, sliderY, w, COLOR_SLIDER_HEIGHT)
			LG.setColor(r, g, b)
			LG.draw(imageGradient, x, sliderY, 0, gradientSx, gradientSy)
			drawSliderValue(x, sliderY, w, COLOR_SLIDER_HEIGHT, cast(float)a, cast(float)(a)*100, "%d%%")
		}

		if hovered {
			LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY_STRONG)
			LG.rectangle(LG.DrawMode.LINE, x-.5, y+(component-1)*COLOR_SLIDER_HEIGHT-.5, w+1, COLOR_SLIDER_HEIGHT+1)
		}
	}

	occupy(panel, w, h)

	return
		pressed,
		hue, saturation, value, cast(float)a, -- 'a' is actually nil if the function was called with a=nil.
		deleted, component
}

local drawPanelButtons :: (panel:Panel,
	label1,label2:string, buttons:[]Button, selected=0, style=ButtonStyle.NORMAL,
	lastButtonWidth=0, showLabels=true, enableDragging=false, inset=0, width=0, height=0, align=Align.CENTER
) -> (
	pressedMouseButton:int, pressedIndex:int, dragged:bool
) {
	local IMAGE_SIZE :: 20 -- @UX: Don't stretch the image.

	panel.panelItem += 1

	local highlightAll = (selected == 0)

	local x = showLabels ? panel.x+inset : panel.baseX+PANEL_SPACING
	local y = panel.y
	local w = width  ?: (panel.baseX+panel.width) - PANEL_SPACING - x
	local h = height ?: fontNormal.getHeight!() + 4

	for buttons  if it.image {
		h = math.max(h, IMAGE_SIZE+2*PANEL_SPACING)
		break
	}

	local buttonW0 = lastButtonWidth ? (w-lastButtonWidth)/(#buttons-1) : w/#buttons

	local hovered = isHoveringPanelItemRectangle(panel, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(panel) : 0

	local pressedIndex: int
	local dragged = false

	if pressed {
		pressedIndex = math.clamp(math.floor(1+(panel.mx-x)/buttonW0), 1, #buttons)

		if enableDragging and pressed == 1 {
			if not draggedPanelItem
				draggedPanelItem = panel.panelItem
			else
				dragged = true
		} else {
			scheduleSaveWorkspace = true
		}
	}

	if showLabels  drawLabels(panel, label1, label2, x, y+math.round((h-fontNormal.getHeight!())/2))

	if style == ButtonStyle.TABS {
		LG.setColor(1, 1, 1, .3)
		LG.rectangle(LG.DrawMode.FILL, panel.baseX, y+h, panel.width, 2)
	}

	for buttons {
		local buttonX1 = math.round(x + (itIndex-1)*buttonW0)
		local buttonX2 = math.round(x + (itIndex  )*buttonW0)
		local buttonW  = buttonW0

		if lastButtonWidth and itIndex == #buttons {
			buttonX2 = x+w
			buttonW  = buttonX2-buttonX1
		}

		local padding = style == ButtonStyle.TABS ? 8 : PANEL_SPACING
		local faded   = not (highlightAll or itIndex == selected)

		local buttonHovered = hovered and panel.mx >= buttonX1 and panel.mx < buttonX2

		-- Button background.
		if buttonHovered
			LG.setColor(1, 1, 1, .45)
		elseif faded
			LG.setColor(1, 1, 1, .15)
		else
			LG.setColor(1, 1, 1, .3)

		if style == ButtonStyle.TABS {
			local topInset = math.min(.6*h, buttonW/4)
			LG.polygon(LG.DrawMode.FILL, buttonX1,y+h, buttonX1+topInset,y, buttonX2-topInset,y, buttonX2,y+h)
		} else {
			LG.rectangle(LG.DrawMode.FILL, buttonX1+1, y+1, buttonX2-buttonX1-2, h-2, 3)
		}

		-- Button image.
		if it.image {
			local image  = particleImages[it.image]
			local iw, ih = image.getDimensions!()
			local sx     = IMAGE_SIZE/iw
			local sy     = IMAGE_SIZE/ih

			LG.setColor(1, 1, 1)
			if it.label
				LG.draw(image, buttonX1+padding, y+PANEL_SPACING, 0, sx, sy)
			else
				LG.draw(image, math.round(buttonX1+(buttonW-IMAGE_SIZE)/2), y+PANEL_SPACING, 0, sx, sy)
		}

		-- Button label.
		if it.label {
			local scissorX1 = buttonX1+(padding-1)
			local scissorX2 = buttonX2-(padding-1)

			if scissorX2 > scissorX1 {
				local textY = y + math.round((h-fontNormal.getHeight!())/2)
				local textX: int

				if it.image {
					textX = buttonX1 + padding + IMAGE_SIZE + PANEL_SPACING
				} else {
					using align
					if align == {
						case LEFT:   textX = buttonX1 + padding
						case RIGHT:  textX = buttonX1 + math.max(math.round(buttonW-padding-fontNormal.getWidth!(it.label)), padding)
						case CENTER: textX = buttonX1 + math.max(math.round((buttonW-fontNormal.getWidth!(it.label))/2), padding)
					}
				}

				LG.pushAll()
				LG.intersectScissor(scissorX1, 0, scissorX2-scissorX1, LG.getHeight())
				LG.setColor(1, 1, 1, (faded ? .6 : 1.0))
				LG.print(it.label, textX, textY)
				LG.pop()
			}
		}

		-- Tooltip.
		if buttonHovered and it.tooltip {
			drawTooltip(it.tooltip, buttonX1, y)
		}
	}

	occupy(panel, inset+w, h+(style == ButtonStyle.TABS ? 2 : 0))
	return pressed, pressedIndex, dragged
}

local drawPanelInput :: (panel:Panel, label1,label2:string, value:string, width=0, showLabels=true) -> (value:string, submitted,cancelled:bool) {
	panel.panelItem += 1

	local x = showLabels ? panel.x : panel.baseX+PANEL_SPACING
	local y = panel.y
	local w = width ?: (panel.baseX+panel.width) - PANEL_SPACING - x
	local h = fontNormal.getHeight!() + 2*PANEL_SPACING

	local valueX = x+PANEL_SPACING

	local hovered = isHoveringPanelItemRectangle(panel, x, y, w, h)
	local pressed = hovered ? isPressingOrMayPress(panel) : 0

	if hovered  panel.isHoveringInput = true

	if pressed == 1 or pressed == 2 {
		if not hasFocus(panel.panelItem)  setFocus(panel.panelItem, value, x, y, w-2*PANEL_SPACING, h, valueX)
		if pressedAnythingThisFrame  focus.field.mousepressed!(panel.mx-valueX, panel.my, pressed, pressCountValueForThisFrame)
	}

	local submitted = false
	local cancelled = false

	local focused = hasFocus(panel.panelItem)
	if focused {
		value = focus.field.getText!()
		if keysPressedThisFrame.\return or keysPressedThisFrame.kpenter {
			submitted = true
			focused   = false
			blurFocus()
		} elseif keysPressedThisFrame.escape {
			cancelled = true
			focused   = false
			blurFocus()
		}
	}

	if showLabels  drawLabels(panel, label1, label2, x, y+math.round((h-fontNormal.getHeight!())/2))

	-- Background.
	LG.setColor(0, 0, 0)
	LG.rectangle(LG.DrawMode.FILL, x, y, w, h, 3)

	LG.pushAll()
	LG.intersectScissor(x, 0, w, LG.getHeight())

	-- Selection.
	if focused {
		local x1, x2 = focus.field.getSelectionOffset!()
		if x2 > x1 {
			LG.setColor(1, 1, 0, .5)
			LG.rectangle(LG.DrawMode.FILL, valueX+x1, y, x2-x1, h)
		}
		LG.setColor(1, 1, 1, math.lerp(.3, .9, math.cos01(focus.field.getBlinkPhase!()*math.TAU/1.00)))
		LG.rectangle(LG.DrawMode.FILL, valueX+focus.field.getCursorOffset!(), y, 1, h)
	}

	-- Value.
	local textOffset = focused ? focus.field.getTextOffset!() : 0
	LG.setColor(1, 1, 1)
	LG.print(value, valueX+textOffset, y+PANEL_SPACING)

	-- Cursor.
	if focused {
		LG.setColor(1, 1, 1, math.lerp(.3, .9, math.cos01(focus.field.getBlinkPhase!()*math.TAU/1.00)))
		LG.rectangle(LG.DrawMode.FILL, valueX+focus.field.getCursorOffset!(), y, 1, h)
	}

	LG.pop()

	-- Hover/focus effect.
	if hovered or focused {
		LG.setColor(1, 1, 1, HOVER_OUTLINE_OPACITY)
		LG.rectangle(LG.DrawMode.LINE, x-.5, y-.5, w+1, h+1, 3)
	}

	occupy(panel, w, h)
	return value, submitted, cancelled
}

local panelStart :: (panel:Panel, baseX,baseY:int, width:int, mainLabelWidth:int, isAux:bool) {
	panel.reset!(baseX,baseY, width, mainLabelWidth, isAux)
	LG.setColor(.2, .2, .2)
	LG.rectangle(LG.DrawMode.FILL, panel.baseX, 0, panel.width, LG.getHeight())
}
local scrollableSectionStart :: (panel:Panel, panelScroll:float) {
	local scissorX = panel.baseX
	local scissorY = panel.y - PANEL_SPACING
	local scissorW = panel.width
	local scissorH = LG.getHeight() - scissorY

	LG.pushAll()
	if scissorW > 0 and scissorH > 0  LG.setScissor(scissorX, scissorY, scissorW, scissorH)
	LG.translate(0, panelScroll)

	panel.hasScrollableSection  = true
	panel.ignoreMouseAboveY     = scissorY
	panel.myScrolled           -= math.round(panelScroll)

	panel.y += 5
}
local panelEnd :: (panel:Panel, panelScroll:float) {
	if not panel.hasScrollableSection  return

	LG.pop()

	-- Shadow at top of the scrollable section.
	local h          = panelScroll ? 30 : 10
	local iw, ih     = imageGradient.getDimensions!()
	local gradientSx = h/ih
	local gradientSy = panel.width/iw

	LG.setColor(0, 0, 0, (panelScroll ? 1.0 : .3))
	LG.draw(imageGradient, panel.baseX, panel.ignoreMouseAboveY+h, -math.TAU/4, gradientSx, gradientSy)
}

export drawPanels :: () {
	-- Note: Some things may render incorrectly for one frame if the user does
	-- something because we handle mouse input here while rendering.

	local panel = Panel()

	panelStart(panel, 0, 0, PROJECT_PANEL_WIDTH, PROJECT_MAIN_LABEL_WIDTH, false)

	-- Project.
	local project = openProjects[currentProjectIndex]

	do {
		local buttons: []Button
		for openProjects  buttons[itIndex] = {label=it.displayedName} -- @Incomplete: Use filenames on tabs.

		insert(buttons, cast(Button){label="+"})

		local pressed, i, dragged = drawPanelButtons(panel, "", "", buttons, selected=currentProjectIndex, style=ButtonStyle.TABS, showLabels=false, lastButtonWidth=32, enableDragging=true) ; gotoNextRow(panel)
		if dragged {
			if i < #buttons {
				remove(openProjects, currentProjectIndex)
				insert(openProjects, i, project)
				currentProjectIndex = i
			}

		} elseif pressed == 1 {
			if i < #buttons {
				currentProjectIndex      = i
				scheduleRecreateCanvases = true
				updateParticleImageFilters()

			} else {
				stopDraggingInPanels()
				addNewProject()
				currentProjectIndex      = #openProjects
				scheduleRecreateCanvases = true
				updateParticleImageFilters()
			}

		} elseif pressed == 3 and i < #buttons {
			-- @UX: Confirm closing project if there are changes.
			remove(openProjects, i)
			if openProjects[1] == NULL
				addNewProject()
			elseif i < currentProjectIndex
				currentProjectIndex -= 1
			else
				currentProjectIndex = math.min(currentProjectIndex, #openProjects)
			scheduleRecreateCanvases = true
			updateParticleImageFilters()
		}
	}
	do {
		local BUTTONS_SHOW_SETTINGS: []Button : {{label="save"},{label="save as..."},{label="open..."},{label="show settings"}}
		local BUTTONS_HIDE_SETTINGS: []Button : {{label="save"},{label="save as..."},{label="open..."},{label="hide settings"}}
		local pressed, i = drawPanelButtons(panel, "", "", (showProjectSettings ? BUTTONS_HIDE_SETTINGS : BUTTONS_SHOW_SETTINGS), showLabels=false) ; gotoNextRow(panel)
		if pressed == 1 {
			if i == {
				case 1: if project.fileIsSaved  saveProject(project, overwrite=true)  else  pushAuxPanel(AuxPanel.SAVE_PROJECT_AS)
				case 2: pushAuxPanel(AuxPanel.SAVE_PROJECT_AS)
				case 3: pushAuxPanel(AuxPanel.OPEN_PROJECT)
				case 4: showProjectSettings = not showProjectSettings ; scheduleSaveWorkspace = true
			}
		}
	}
	if showProjectSettings {
		drawPanelSeparator(panel)
		do {
			local pressed, i = drawPanelButtons(panel, "Pixelate", "world", BUTTONS_YES_NO, selected=(project.pixelateWorld ? 1 : 2), width=140) ; gotoNextColumn(panel)
			if pressed == 1 {
				project.pixelateWorld    = (i == 1)
				scheduleRecreateCanvases = true

				if project.pixelateWorld and project.zoomLevel < -1 {
					project.zoomLevel  = -1
					project.zoomSource = project.zoom
					project.zoomTarget = 2^project.zoomLevel
				}
			}
		}
		do {
			local pressed, i = drawPanelButtons(panel, "", "textures", BUTTONS_YES_NO, selected=(project.pixelateTextures ? 1 : 2), inset=50) ; gotoNextRow(panel)
			if pressed == 1 {
				project.pixelateTextures = (i == 1)
				updateParticleImageFilters()
			}
		}
		drawPanelSeparator(panel)
		do {
			local pressed, h,s,v = drawPanelColor(panel, "Background", "", project.bgColorH, project.bgColorS, project.bgColorV, nil) ; gotoNextRow(panel)

			if pressed == 1 {
				project.bgColorH, project.bgColorS, project.bgColorV = h,s,v
			}
		}
		drawPanelSeparator(panel)
		do {
			using Movement

			local BUTTONS: []Button : {
				{value=NONE,      label="none",      tooltip="No movement"},
				{value=CIRCLE,    label="circle",    tooltip="Circle, or back and forth"},
				{value=EIGHT,     label="eight",     tooltip="Numeral eight"},
				{value=IRREGULAR, label="irregular", tooltip="Irregular movement"},
			}

			local _, i         = indexWith(BUTTONS, "value", project.movementPreset)
			local pressed1, ^i = drawPanelButtons(panel, "EmitterMovem.", "", BUTTONS, selected=i) ; gotoNextRow(panel)
			if pressed1 == 1  project.movementPreset = cast(Movement) BUTTONS[i].value
		}
		do {
			local pressed, scale = drawPanelSlider(panel, "", "scale x", 0, 2, project.movementScaleX, 100, "%d%%", width=100) ; gotoNextColumn(panel)
			if pressed == 1  project.movementScaleX = scale
		}
		do {
			local pressed, speed = drawPanelSlider(panel, "", "speed", -8, 8, project.movementSpeed, 100, "%d%%", inset=INNER_LABEL_WIDTH) ; gotoNextRow(panel)
			if pressed == 1  project.movementSpeed = speed
		}
		do {
			local pressed, scale = drawPanelSlider(panel, "", "scale y", 0, 2, project.movementScaleY, 100, "%d%%", width=100) ; gotoNextRow(panel)
			if pressed == 1  project.movementScaleY = scale
		}
	}

	-- System.
	local system = project.systems[project.systemIndex]
	drawPanelSeparator(panel, true)
	do {
		local buttons: []Button
		for project.systems  buttons[itIndex] = {label=format((it.visible ? "%d" : "(%d)"), itIndex)}

		insert(buttons, cast(Button){label="+"})

		local pressed, i, dragged = drawPanelButtons(panel, "ParticleSystem", "", buttons, selected=project.systemIndex, lastButtonWidth=32, style=ButtonStyle.TABS, enableDragging=true) ; gotoNextRow(panel)
		if dragged {
			if i < #buttons {
				remove(project.systems, project.systemIndex)
				insert(project.systems, i, system)
				project.systemIndex = i
			}

		} elseif pressed == 1 {
			if i < #buttons {
				project.systemIndex = i
			} else {
				stopDraggingInPanels()
				addNewSystem(project)
				project.systemIndex = #project.systems
			}
			system = project.systems[project.systemIndex]

		} elseif pressed == 2 {
			if i < #buttons  project.systems[i].visible = not project.systems[i].visible

		} elseif pressed == 3 and i < #buttons {
			-- @UX: Confirm removal of system.
			remove(project.systems, i)
			if project.systems[1] == NULL
				addNewSystem(project)
			elseif i < project.systemIndex
				project.systemIndex -= 1
			else
				project.systemIndex = math.min(project.systemIndex, #project.systems)
			system = project.systems[project.systemIndex]
		}
	}

	scrollableSectionStart(panel, project.panelScroll)

	-- Misc params.
	local ps = system.particles
	do {
		local buttons: []Button = {{value="light",tooltip="light",image="light"},{value="moon",tooltip="moon",image="moon"}} -- @Incomplete: Dynamically create this list.
		local _, i              = indexWith(buttons, "value", system.textureName)
		local pressed, ^i       = drawPanelButtons(panel, "Texture", "", buttons, selected=i) ; gotoNextRow(panel)
		if pressed == 1 {
			system.textureName = cast(string)buttons[i].value
			ps.setTexture!(particleImages[system.textureName]) -- @Incomplete: Update offset if system.useCustomOffset is set.
		}
	}
	drawPanelSeparator(panel)
	do {
		using LG.ParticleInsertMode

		local BUTTONS: []Button : {
			{value=TOP,    label="top"},
			{value=BOTTOM, label="bottom"},
			{value=RANDOM, label="random"},
		}

		local _, i        = indexWith(BUTTONS, "value", ps.getInsertMode!())
		local pressed, ^i = drawPanelButtons(panel, "InsertMode", "", BUTTONS, selected=i) ; gotoNextRow(panel)
		if pressed == 1  ps.setInsertMode!(cast(LG.ParticleInsertMode) BUTTONS[i].value)
	}
	drawPanelSeparator(panel)
	do {
		local lifetime = math.max(ps.getEmitterLifetime!(), 0)
		local pressed, ^lifetime = drawPanelSlider(panel, "Lifetime", "emitter", 0, 20, lifetime,other=0, 1, (lifetime > 0 ? "%.2f sec" : "∞")) ; gotoNextRow(panel)
		if pressed == 1 {
			ps.setEmitterLifetime!(lifetime > 0 ? lifetime : -1.0)
			if lifetime <= 0  ps.start!()
		}
	}
	do {
		local min, max = ps.getParticleLifetime!()
		local pressedMin, ^min = drawPanelSlider(panel, "", "particle min", 0, 20, min,other=max, 1, "%.2f sec") ; gotoNextRow(panel)
		local pressedMax, ^max = drawPanelSlider(panel, "", "particle max", 0, 20, max,other=min, 1, "%.2f sec") ; gotoNextRow(panel)
		if pressedMin  max = math.max(min, max)
		if pressedMax  min = math.min(min, max)
		if pressedMin == 1 or pressedMax == 1  ps.setParticleLifetime!(min, max)
	}
	drawPanelSeparator(panel, true)
	do {
		local pressed, rate = drawPanelSlider(panel, "SpawnRate", "", .1, 1000, ps.getEmissionRate!(),other=0, 1, "%.1f / sec") ; gotoNextRow(panel)
		if pressed == 1  ps.setEmissionRate!(rate)
	}
	drawPanelSeparator(panel)
	do {
		using LG.AreaSpreadDistribution

		local BUTTONS: []Button : {
			{value=NONE,             label="none",    tooltip="None"},
			{value=NORMAL,           label="norm",    tooltip="Normal"},
			{value=ELLIPSE,          label="ellip",   tooltip="Ellipse"},
			{value=UNIFORM,          label="rect",    tooltip="Rectangle (uniform)"},
			{value=BORDER_ELLIPSE,   label="b.ellip", tooltip="Border ellipse"},
			{value=BORDER_RECTANGLE, label="b.rect",  tooltip="Border rectangle"},
		}

		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()

		local _, i         = indexWith(BUTTONS, "value", distribution)
		local pressed1, ^i = drawPanelButtons(panel, "Area", "distribution", BUTTONS, selected=i) ; gotoNextRow(panel)
		if pressed1 == 1  distribution = cast(LG.AreaSpreadDistribution) BUTTONS[i].value

		if distribution == NONE {
			if pressed1 == 1  ps.setEmissionArea!(distribution, 0,0)

		} else {
			local pressed2, ^angle = drawPanelDirection(panel, "", "angle", angle) ; gotoNextColumn(panel)

			local pressed3, ^dx = drawPanelSlider(panel, "", "dx", 0, 1000, dx,other=0, 1, "%d", inset=INNER_LABEL_WIDTH)
			local pressed4, ^dy = drawPanelSlider(panel, "", "dy", 0, 1000, dy,other=0, 1, "%d", inset=INNER_LABEL_WIDTH)

			local pressed5, ^i = drawPanelButtons(panel, "", "dir relative to center", BUTTONS_YES_NO, selected=(relative ? 1 : 2), inset=INNER_LABEL_WIDTH+69) ; gotoNextRow(panel)
			if pressed5 == 1  relative = (i == 1)

			if pressed1 == 1 or pressed2 == 1 or pressed3 == 1 or pressed4 == 1 or pressed5 == 1 {
				ps.setEmissionArea!(distribution, dx,dy, angle, relative)
			}
		}
	}
	drawPanelSeparator(panel)
	do {
		local pressed, angle = drawPanelDirection(panel, "Direction", "", ps.getDirection!(), spreadCcw=ps.getSpread!()/2,spreadCw=ps.getSpread!()/2) ; gotoNextColumn(panel)
		if pressed == 1  ps.setDirection!(angle)
	}
	do {
		local pressed, angle = drawPanelSlider(panel, "", "spread", 0, math.TAU, ps.getSpread!(),other=0, 360/math.TAU, "%d°", inset=INNER_LABEL_WIDTH) ; gotoNextRow(panel)
		if pressed == 1  ps.setSpread!(angle)
	}
	drawPanelSeparator(panel, true)
	do {
		local min, max = ps.getSpeed!()
		local pressedMin, ^min = drawPanelSlider(panel, "Speed", "min", -2000, 2000, min,other=max, 1, "%d / sec") ; gotoNextRow(panel)
		local pressedMax, ^max = drawPanelSlider(panel, "",      "max", -2000, 2000, max,other=min, 1, "%d / sec") ; gotoNextRow(panel)
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setSpeed!(min, max)
		}
	}
	drawPanelSeparator(panel)
	do {
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		local pressedXmin, ^xmin = drawPanelSlider(panel, "AccLinear", "xmin", -10000, 10000, xmin,other=xmax, 1, "%d / sec²") ; gotoNextRow(panel)
		local pressedXmax, ^xmax = drawPanelSlider(panel, "",          "xmax", -10000, 10000, xmax,other=xmin, 1, "%d / sec²") ; gotoNextRow(panel)
		local pressedYmin, ^ymin = drawPanelSlider(panel, "",          "ymin", -10000, 10000, ymin,other=ymax, 1, "%d / sec²") ; gotoNextRow(panel)
		local pressedYmax, ^ymax = drawPanelSlider(panel, "",          "ymax", -10000, 10000, ymax,other=ymin, 1, "%d / sec²") ; gotoNextRow(panel)
		if pressedXmin == 1 or pressedXmax == 1 or pressedYmin == 1 or pressedYmax == 1 {
			if pressedXmin  xmax = math.max(xmin, xmax)
			if pressedXmax  xmin = math.min(xmin, xmax)
			if pressedYmin  ymax = math.max(ymin, ymax)
			if pressedYmax  ymin = math.min(ymin, ymax)
			ps.setLinearAcceleration!(xmin,ymin, xmax,ymax)
		}
	}
	drawPanelSeparator(panel)
	do {
		local min, max = ps.getRadialAcceleration!()
		local pressedMin, ^min = drawPanelSlider(panel, "AccRadial", "min", -20000, 20000, min,other=max, 1, "%d / sec²") ; gotoNextRow(panel)
		local pressedMax, ^max = drawPanelSlider(panel, "",          "max", -20000, 20000, max,other=min, 1, "%d / sec²") ; gotoNextRow(panel)
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setRadialAcceleration!(min, max)
		}
	}
	drawPanelSeparator(panel)
	do {
		local min, max = ps.getTangentialAcceleration!()
		local pressedMin, ^min = drawPanelSlider(panel, "AccTangent", "min", -20000, 20000, min,other=max, 1, "%d / sec²") ; gotoNextRow(panel)
		local pressedMax, ^max = drawPanelSlider(panel, "",           "max", -20000, 20000, max,other=min, 1, "%d / sec²") ; gotoNextRow(panel)
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setTangentialAcceleration!(min, max)
		}
	}
	drawPanelSeparator(panel)
	do {
		local min, max = ps.getLinearDamping!()
		local pressedMin, ^min = drawPanelSlider(panel, "DampLinear", "min", -50, 50, min,other=max, 1, "%.2f") ; gotoNextRow(panel)
		local pressedMax, ^max = drawPanelSlider(panel, "",           "max", -50, 50, max,other=min, 1, "%.2f") ; gotoNextRow(panel)
		if pressedMin == 1 or pressedMax == 1 {
			if pressedMin  max = math.max(min, max)
			if pressedMax  min = math.min(min, max)
			ps.setLinearDamping!(min, max)
		}
	}
	drawPanelSeparator(panel, true)
	do {
		local min, max = ps.getRotation!()
		local pressedMin, ^min = drawPanelDirection(panel, "Rotation", "min/max", min, spreadCw=max-min)  ; gotoNextColumn(panel)
		local pressedMax, ^max = drawPanelDirection(panel, "",         "",        max, spreadCcw=max-min) ; gotoNextColumn(panel)
		if pressedMin == 1 or pressedMax == 1 {
			-- if pressedMin  max = math.max(min, max)
			-- if pressedMax  min = math.min(min, max)
			ps.setRotation!(min, max)
		}
	}
	do {
		local pressed, i = drawPanelButtons(panel, "", "relative", BUTTONS_YES_NO, selected=(ps.hasRelativeRotation!() ? 1 : 2), inset=INNER_LABEL_WIDTH) ; gotoNextRow(panel)
		if pressed == 1  ps.setRelativeRotation!(i == 1)
	}
	drawPanelSeparator(panel)
	do {
		local min, max = ps.getSpin!()
		local pressedMin, ^min = drawPanelSlider(panel, "Spin", "at start", -8*math.TAU, 8*math.TAU, min,other=max, 1/math.TAU, "%.2f turns / sec") ; gotoNextRow(panel)
		local pressedMax, ^max = drawPanelSlider(panel, "",     "at end",   -8*math.TAU, 8*math.TAU, max,other=min, 1/math.TAU, "%.2f turns / sec") ; gotoNextRow(panel)
		if pressedMin == 1 or pressedMax == 1  ps.setSpin!(min, max)
	}
	do {
		local pressed, variation = drawPanelSlider(panel, "", "variation", 0, 1, ps.getSpinVariation!(),other=0, 100, "%d%%") ; gotoNextRow(panel)
		if pressed == 1  ps.setSpinVariation!(variation)
	}
	--[[
	-- @Incomplete:
	ps.setQuads!(quad1,quad2)
	ps.setOffset!(x,y)
	]]

	-- Sizes.
	drawPanelSeparator(panel, true)
	do {
		local sizes = {ps.getSizesAsVararg!()}
		local buttons: []Button = {{label="+"}}

		local pressed, i = drawPanelButtons(panel, "Size", "", buttons) ; gotoNextRow(panel)

		if pressed == 1 and sizes[8] == NULL {
			insert(sizes, sizes[#sizes])
			ps.setSizes!(sizes)
		}
	}
	do {
		local sizes   = {ps.getSizesAsVararg!()}
		local moveAll = panel.mod == ModifierKey.S or panel.mod == ModifierKey.CS

		local anyPressed    = false
		local indexToDelete = 0
		local indexToShift  = 0

		for i = 1, #sizes {
			local y1 = panel.y

			local pressed, size, deleted = drawPanelSlider(panel, "", format("#%d", i), 0, 8, sizes[i],other=0, 1, "%.2f", enableDelete=true) ; gotoNextRow(panel)
			anyPressed                   = anyPressed or pressed == 1

			local y2 = panel.y-PANEL_SPACING

			if shiftScrolledOnPanel and panel.myScrolled > y1 and panel.myScrolled < y2 {
				indexToShift = i
			} elseif deleted {
				indexToDelete = i
			} elseif pressed ~= 1 {
				-- void
			} else {
				if moveAll
					for j = 1, #sizes  sizes[j] = size
				else
					sizes[i] = size
			}
		}

		if indexToShift {
			if shiftScrolledOnPanel < 0 and indexToShift > 1 {
				sizes[indexToShift], sizes[indexToShift-1] = sizes[indexToShift-1], sizes[indexToShift]
				LM.setPosition(panel.mx, panel.my - fontNormal.getHeight!() - PANEL_SPACING)
			} elseif shiftScrolledOnPanel > 0 and indexToShift < #sizes {
				sizes[indexToShift], sizes[indexToShift+1] = sizes[indexToShift+1], sizes[indexToShift]
				LM.setPosition(panel.mx, panel.my + fontNormal.getHeight!() + PANEL_SPACING)
			}

			scheduleSaveWorkspace = true
			ps.setSizes!(sizes)

		} elseif indexToDelete {
			remove(sizes, indexToDelete)
			if sizes[1] == NULL  insert(sizes, 1)
			ps.setSizes!(sizes)

		} elseif anyPressed {
			ps.setSizes!(sizes)
		}
	}
	do {
		local pressed, variation = drawPanelSlider(panel, "", "variation", 0, 1, ps.getSizeVariation!(),other=0, 100, "%d%%") ; gotoNextRow(panel)
		if pressed == 1  ps.setSizeVariation!(variation)
	}

	-- Colors + blend mode.
	drawPanelSeparator(panel)
	do {
		local BUTTONS: []Button : {{label="+"}}
		local colors     = system.colors
		local pressed, i = drawPanelButtons(panel, "Color", "", BUTTONS) ; gotoNextRow(panel)

		if pressed == 1 and colors[8*4] == NULL {
			local lastColorIndex = (#colors//4)*4-3
			for 1, 4  insert(colors, colors[lastColorIndex+it-1])
			updateParticleColors(ps, colors)
		}
	}
	do {
		local colors  = system.colors
		local moveAll = panel.mod == ModifierKey.S or panel.mod == ModifierKey.CS

		local anyPressed         = false
		local colorIndexToShift  = 0
		local colorIndexToDelete = 0

		local previewY1 = panel.y

		for i = 1, #colors, 4 {
			local y1 = panel.y

			local pressed, h,s,v,a, deleted, component = drawPanelColor(panel, "", format("#%d", (i+3)//4), colors[i],colors[i+1],colors[i+2],colors[i+3], enableDelete=true, showPreview=(colors[5]==NULL)) ; gotoNextRow(panel)
			anyPressed = anyPressed or pressed == 1

			local y2 = panel.y-PANEL_SPACING

			if shiftScrolledOnPanel and panel.myScrolled > y1 and panel.myScrolled < y2 {
				colorIndexToShift = i
			} elseif deleted {
				colorIndexToDelete = i
			} elseif pressed ~= 1 {
				-- void
			} else {
				local theValue = component==1?h : component==2?s : component==3?v : a
				if moveAll
					for j = component, #colors, 4  colors[j] = theValue
				else
					colors[i+component-1] = theValue
			}
		}

		local colorCount = #colors//4

		if colors[5] ~= NULL {
			local previewX  = panel.baseX + panel.width - PANEL_SPACING - COLOR_PREVIEW_WIDTH
			local previewY2 = panel.y - PANEL_SPACING

			static shader: LG.Shader = NULL
			if shader == NULL  shader = LG.newShader("src/particleColorPreview.glsl")

			static colorsForShader: [][]float = {{},{},{},{},{},{},{},{}}

			for i = 1, 8*4, 4 {
				local color = colorsForShader[(i+3)//4]
				if colors[i] == NULL {
					color[1] = 0
					color[2] = 0
					color[3] = 0
					color[4] = 0
				} else {
					color[1], color[2], color[3] = hsvToRgb(colors[i], colors[i+1], colors[i+2])
					color[4]                     = colors[i+3]
				}
			}

			shader.send!("colors",     colorsForShader[1], unpack(colorsForShader, 2))
			shader.send!("colorCount", colorCount)

			drawCheckerBox(previewX, previewY1, COLOR_PREVIEW_WIDTH, previewY2-previewY1)

			LG.setShader(shader)
			LG.draw(imagePixel, previewX, previewY1, 0, COLOR_PREVIEW_WIDTH, previewY2-previewY1)
			LG.setShader()
		}

		if colorIndexToShift {
			local swap :: (colors:[]float, i1,i2:int) {
				colors[i1  ], colors[i2  ] = colors[i2  ], colors[i1  ]
				colors[i1+1], colors[i2+1] = colors[i2+1], colors[i1+1]
				colors[i1+2], colors[i2+2] = colors[i2+2], colors[i1+2]
				colors[i1+3], colors[i2+3] = colors[i2+3], colors[i1+3]
			}

			if shiftScrolledOnPanel < 0 and colorIndexToShift > 1 {
				swap(colors, colorIndexToShift, colorIndexToShift-4)
				LM.setPosition(panel.mx, panel.my-4*COLOR_SLIDER_HEIGHT-PANEL_SPACING)
			} elseif shiftScrolledOnPanel > 0 and colorIndexToShift < colorCount*4-3 {
				swap(colors, colorIndexToShift, colorIndexToShift+4)
				LM.setPosition(panel.mx, panel.my+4*COLOR_SLIDER_HEIGHT+PANEL_SPACING)
			}

			scheduleSaveWorkspace = true
			updateParticleColors(ps, colors)

		} elseif colorIndexToDelete {
			for 1, 4  remove(colors, colorIndexToDelete)

			if colors[1] == NULL {
				colors[1] = 0
				colors[2] = 0
				colors[3] = 1
				colors[4] = 1
			}

			updateParticleColors(ps, colors)

		} elseif anyPressed {
			updateParticleColors(ps, colors)
		}
	}
	do {
		using LG.BlendMode

		local BUTTONS: []Button : {
			{value=ALPHA,    label="alpha"},
			{value=ADD,      label="add"},
			{value=SUBTRACT, label="subtract"},
			{value=SCREEN,   label="screen"},
		}

		local _, i        = indexWith(BUTTONS, "value", system.blendMode)
		local pressed, ^i = drawPanelButtons(panel, "", "blend mode", BUTTONS, selected=i) ; gotoNextRow(panel)
		if pressed == 1  system.blendMode = cast(LG.BlendMode) BUTTONS[i].value
	}
	drawPanelSeparator(panel, true)

	panelEnd(panel, project.panelScroll)

	if auxPanel ~= AuxPanel.NONE {
		LG.setColor(.15, .15, .15, .9)
		LG.rectangle(LG.DrawMode.FILL, 0, 0, LG.getWidth(), LG.getHeight())

		panelStart(panel, (LG.getWidth()-AUX_PANEL_WIDTH)//2, 0, AUX_PANEL_WIDTH, AUX_MAIN_LABEL_WIDTH, true)
		drawAuxPanel[auxPanel](panel, project)
		panelEnd(panel, auxPanelScroll)
	}

	if contextMenu ~= NULL {
		local itemHeight  = fontNormal.getHeight!() + 2*CONTEXT_MENU_PADDING_Y
		local pressedItem = 0

		LG.setColor(.6, .6, .6)
		LG.rectangle(LG.DrawMode.FILL, contextMenu.x, contextMenu.y, contextMenu.width, contextMenu.height)

		for contextMenu.items {
			local x = contextMenu.x
			local y = contextMenu.y + (itIndex-1)*itemHeight

			if isInside(panel.mx, panel.my, x, y, contextMenu.width, itemHeight) {
				if not panel.showedContextMenuThisFrame and pressedOnPanelWithMouseButton == 1
					pressedItem = itIndex

				LG.setColor(.8, .8, .8)
				LG.rectangle(LG.DrawMode.FILL, x, y, contextMenu.width, itemHeight)
			}

			LG.setColor(0, 0, 0)
			LG.print(it, x+CONTEXT_MENU_PADDING_X, y+CONTEXT_MENU_PADDING_Y)
		}

		if pressedItem {
			local _contextMenu = contextMenu
			contextMenu        = NULL
			_contextMenu.callback(pressedItem)

		} elseif pressedAnythingThisFrame and not (panel.showedContextMenuThisFrame or isInsideContextMenu(panel.mx, panel.my)) {
			contextMenu = NULL
		}
	}

	if panel.isHoveringInput
		LM.setCursor(LM.getSystemCursor(LM.CursorType.I_BEAM))
	else
		LM.setCursor()

	do {
		-- Reset these here after the target panel item has handled the action.
		panelItemForContextMenu = 0
		contextMenuAction       = 0
	}

	pressedOnPanelWithMouseButton = 0
	shiftScrolledOnPanel          = 0
}

local drawAuxPanel: struct { !key:AuxPanel, !value:(panel:Panel, project:Project) } = {
	[AuxPanel.EXIT] = (panel:Panel, project:Project) {
		panel.y = LG.getHeight() // 2 - 10

		local BUTTONS: []Button : {{label="exit"},{label="cancel"}}
		local pressed, i = drawPanelButtons(panel, "", "", BUTTONS, showLabels=false, height=30) ; gotoNextRow(panel)

		if pressed ~= 1 {
			-- void
		} elseif i == 1 {
			pushQuitEvent()
		} else {
			popAuxPanel()
		}
	},

	[AuxPanel.SAVE_PROJECT_AS] = (panel:Panel, project:Project) {
		local data = cast(struct {
			editedDir:      string,
			editedFilename: string,
			dir:         string,
			dirFallback: string,
			filename:    string,
		}) auxPanelData

		if data == NULL {
			local path              = project.path
			local ok, dir, filename = matchPattern(path, "^(.+)/([^/]+)$")

			if not ok {
				dir      = LF.getSaveDirectory()
				filename = "my.hotparticles"
			}

			data = {
				editedDir      = cast(string) dir,
				editedFilename = cast(string) filename,
				dir            = cast(string) dir,
				dirFallback    = LF.getSaveDirectory(),
				filename       = cast(string) filename,
			}
			auxPanelData = data
		}

		drawPanelLabel(panel, "Save as") ; gotoNextRow(panel)

		-- Directory.
		do {
			local dir, submitted, cancelled = drawPanelInput(panel, "", "", data.editedDir, showLabels=false) ; gotoNextRow(panel)
			data.editedDir = dir

			if submitted {
				data.editedDir = normalizeDirectoryPath(data.editedDir)
				data.dir       = data.editedDir
			} elseif cancelled {
				data.editedDir = data.dir
			}
		}

		LG.setColor(1, 1, 1, .3)
		LG.rectangle(LG.DrawMode.FILL, panel.baseX, panel.y, panel.width, 2)
		panel.y += 2+PANEL_SPACING

		scrollableSectionStart(panel, auxPanelScroll)

		-- "Got up one dir" button.
		local buttons: []Button : {{}}
		do {
			buttons[1].label = "../"
			local pressed = drawPanelButtons(panel, "", "", buttons, align=Align.LEFT, showLabels=false) ; gotoNextRow(panel)
			if pressed == 1 {
				-- @Robustness: Handle "C:/foo" becoming "C:" or "/foo" becoming "". (Maybe it doesn't matter in practice?)
				data.dir             = replacePattern(data.dir, "/[^/]+$", "")
				data.editedDir       = data.dir
				auxPanelScroll       = 0
				auxPanelScrollSource = 0
				auxPanelScrollTarget = 0
			}
		}

		-- Files and folders in CWD.
		if not connectToRemoteDirectory(data.dir) {
			data.dir = data.dirFallback
			if not connectToRemoteDirectory(data.dir) {
				data.dir = LF.getSaveDirectory()
				if not connectToRemoteDirectory(data.dir) {
					data.dir = LF.getWorkingDirectory()
					assert(connectToRemoteDirectory(data.dir))
				}
			}
			data.editedDir = data.dir
		}
		defer disconnectFromRemoteDirectory()
		data.dirFallback = data.dir

		local dirs:      []string
		local filenames: []string

		for LF.getDirectoryItems("") {
			static info: LF.FileInfo

			if LF.getInfo(it, info) == nil {
				-- void  The file may be a system file or something.
			} if info.type == LF.FileType.DIRECTORY {
				if not findPattern(it, "^%$")  insert(dirs, it)
			} elseif info.type == LF.FileType.FILE {
				if findPattern(it, "%.hotparticles$")  insert(filenames, it)
			}
		}

		local comparer :: (a,b:string) -> bool {
			for 1, math.min(#a, #b) {
				local aByte = a[it]
				local bByte = b[it]

				-- Case-insensitive ASCII.
				if aByte >= !char "a" and aByte <= !char "z"  aByte = aByte - !char "a" + !char "A"
				if bByte >= !char "a" and bByte <= !char "z"  bByte = bByte - !char "a" + !char "A"

				if aByte ~= bByte {
					local aIsDigit          = (aByte >= !char "0" and aByte <= !char "9")
					local bIsDigit          = (bByte >= !char "0" and bByte <= !char "9")
					local aIsAlphaOrUnicode = aIsDigit or (aByte >= !char "a" and aByte <= !char "z") or aByte >= 128
					local bIsAlphaOrUnicode = bIsDigit or (bByte >= !char "a" and bByte <= !char "z") or bByte >= 128

					if aIsAlphaOrUnicode ~= bIsAlphaOrUnicode  return bIsAlphaOrUnicode

					-- Natural sorting for numbers.
					if aIsDigit and bIsDigit {
						local _, aIntStr = matchPattern(a, "^%d+", it)
						local _, bIntStr = matchPattern(b, "^%d+", it)
						local _, aInt    = stringToInt(cast(string)aIntStr)
						local _, bInt    = stringToInt(cast(string)bIntStr)
						return aInt < bInt
					}

					return toLower(getSubstring(a, it, it)) < toLower(getSubstring(b, it, it))
				}
			}
			return toLower(a) < toLower(b)
		}

		sort(dirs,      comparer)
		sort(filenames, comparer)

		for dir: dirs {
			-- @Incomplete: Folder icon on the buttons.
			buttons[1].label = dir.."/"
			local pressed = drawPanelButtons(panel, "", "", buttons, align=Align.LEFT, showLabels=false) ; gotoNextRow(panel)
			if pressed == 1 {
				-- Note: Beware of one-frame delay!
				data.dir             = data.dir.."/"..dir
				data.editedDir       = data.dir
				auxPanelScroll       = 0
				auxPanelScrollSource = 0
				auxPanelScrollTarget = 0
			}
		}
		for filename: filenames {
			buttons[1].label = filename
			local pressed = drawPanelButtons(panel, "", "", buttons, align=Align.LEFT, showLabels=false) ; gotoNextRow(panel)
			if pressed == 1 {
				data.editedFilename = filename
				data.filename       = filename
			}
		}

		-- Filename.
		do {
			local filename, submitted, cancelled = drawPanelInput(panel, "Filename", "", data.editedFilename) ; gotoNextRow(panel)
			data.editedFilename = filename

			if submitted {
				-- @Incomplete: Validate editedFilename.
				data.filename = data.editedFilename
			} elseif cancelled {
				data.editedFilename = data.filename
			}
		}

		-- Actions.
		do {
			local BUTTONS: []Button : {{label="save"},{label="cancel"}}
			local pressed, i = drawPanelButtons(panel, "", "", BUTTONS, showLabels=false) ; gotoNextRow(panel)

			if pressed ~= 1 {
				-- void

			} elseif i ~= 1 {
				popAuxPanel()

			} elseif not data.filename {
				setErrorText("Filename is empty")

			} else {
				if not findPattern(data.filename, "%.hotparticles$")  data.filename = data.filename..".hotparticles"

				project.path = data.dir.."/"..data.filename

				local ok, fileExists = saveProject(project)
				if ok {
					popAuxPanel()

				} elseif fileExists {
					local BUTTONS2: []Button : {{label="overwrite"},{label="cancel"}}
					confirmOverwriteFile_buttons = BUTTONS2

					confirmOverwriteFile_cb = [data,project] (i:int) {
						if i ~= 1  return

						if saveProject(project, overwrite=true)  popAuxPanel()
					}
					pushAuxPanel(AuxPanel.CONFIRM_OVERWRITE_FILE)

				} else {
					-- void  Stay in the dialog.
				}
			}
		}
	},

	[AuxPanel.OPEN_PROJECT] = (panel:Panel, project:Project) {
		drawPanelLabel(panel, "Open project") ; gotoNextRow(panel)
		-- @Incomplete
	},

	[AuxPanel.CONFIRM_OVERWRITE_FILE] = (panel:Panel, project:Project) {scrollableSectionStart(panel, project.panelScroll)
		drawPanelLabel(panel, "Overwrite file") ; gotoNextRow(panel)

		do {
			local pressed, i = drawPanelButtons(panel, "", "", confirmOverwriteFile_buttons, showLabels=false) ; gotoNextRow(panel)

			if pressed == 1 {
				popAuxPanel()
				confirmOverwriteFile_cb(i)
			}
		}
	},
}

local confirmOverwriteFile_buttons: []Button = NULL
local confirmOverwriteFile_cb: (choice:int)  = NULL



local showContextMenu :: (panel:Panel, items:[]string, cb:type_of(ContextMenu.callback)) {
	local w = 0
	local h = #items * (fontNormal.getHeight!() + 2*CONTEXT_MENU_PADDING_Y)

	for items  w = math.max(w, fontNormal.getWidth!(it))
	w = math.max(w+2*CONTEXT_MENU_PADDING_X, CONTEXT_MENU_MIN_WIDTH)

	local x = math.min(panel.mx, LG.getWidth() - w)
	local y = panel.my + 2

	if y+h > LG.getHeight()  y -= h+4

	contextMenu = {
		x        = x,
		y        = y,
		width    = w,
		height   = h,
		items    = items,
		callback = cb,
	}
	panel.showedContextMenuThisFrame = true
}

export hideContextMenu :: () -> (success:bool) {
	if contextMenu == NULL  return false
	contextMenu = NULL
	return true
}

local isInsideContextMenu :: (x,y:int) -> bool {
	return contextMenu ~= NULL
		and x >= contextMenu.x
		and y >= contextMenu.y
		and x <  contextMenu.x + contextMenu.width
		and y <  contextMenu.y + contextMenu.height
}



local isHoveringHelper :: (panel:Panel) -> bool|none {
	if draggedPanelItem == panel.panelItem            return true
	if draggedPanelItem > 0                           return false
	if auxPanel ~= AuxPanel.NONE and not panel.isAux  return false
	if panel.my < panel.ignoreMouseAboveY             return false
	if isInsideContextMenu(panel.mx, panel.my)        return false
	return nil
}
local isHoveringPanelItemRectangle :: (panel:Panel, x,y,w,h:int) -> bool {
	local hovered = isHoveringHelper(panel) ; if hovered ~= nil  return cast(bool) hovered
	return isInside(panel.mx, panel.myScrolled, x, y, w, h)
}
local isHoveringPanelItemCircle :: (panel:Panel, x,y,radius:int) -> bool {
	local hovered = isHoveringHelper(panel) ; if hovered ~= nil  return cast(bool) hovered
	return math.distance(panel.mx,panel.myScrolled, x,y) <= radius
}



local isPressingOrMayPress :: (panel:Panel) -> (pressedMouseButton:int) {
	if panel.panelItem == draggedPanelItem  return 1
	return (draggedPanelItem or panelItemForContextMenu) ? 0 : pressedOnPanelWithMouseButton
}



export stopDraggingInPanels :: () {
	if not draggedPanelItem  return

	draggedPanelItem      = 0
	draggedPanelSubItem   = 0
	scheduleSaveWorkspace = true
}




local occupy :: (panel:Panel, w,h:int) {
	panel.maxPanelItemX  = math.max(panel.maxPanelItemX, panel.x+w)
	panel.maxPanelItemY  = math.max(panel.maxPanelItemY, panel.y+h)
	panel.y             += h + PANEL_SPACING
}

local gotoNextColumn :: (panel:Panel) {
	panel.x = panel.maxPanelItemX + PANEL_SPACING
	panel.y = panel.baseY + PANEL_SPACING
}

local gotoNextRow :: (panel:Panel) {
	panel.baseY         = panel.maxPanelItemY
	panel.x             = panel.baseX + panel.mainLabelWidth + PANEL_SPACING
	panel.y             = panel.baseY + PANEL_SPACING
	panel.maxPanelItemX = panel.baseX + panel.mainLabelWidth
}



export isInsidePanels :: (x,y:int) -> bool {
	if x < PROJECT_PANEL_WIDTH    return true
	if auxPanel ~= AuxPanel.NONE  return true
	if isInsideContextMenu(x, y)  return true
	return false
}



local isInsideAuxPanel :: (x,y:int) -> bool {
	if auxPanel == AuxPanel.NONE  return false

	local auxPanelX = (LG.getWidth()-AUX_PANEL_WIDTH)//2
	return x >= auxPanelX and x < auxPanelX+AUX_PANEL_WIDTH
}

export pushAuxPanel :: (_auxPanel:AuxPanel) {
	assert(_auxPanel ~= AuxPanel.NONE)

	insert(auxPanelStack, auxPanel)

	auxPanel             = _auxPanel
	auxPanelData         = nil
	auxPanelScroll       = 0
	auxPanelScrollSource = 0
	auxPanelScrollTarget = 0
}

export popAuxPanel :: () -> (success:bool) {
	if auxPanel == AuxPanel.NONE  return false

	blurFocus()

	_, auxPanel = remove(auxPanelStack)
	if auxPanel == NULL  auxPanel = AuxPanel.NONE

	auxPanelData         = nil
	auxPanelScroll       = 0
	auxPanelScrollSource = 0
	auxPanelScrollTarget = 0

	return true
}

export isAuxPanelVisible :: () -> bool {
	return auxPanel ~= AuxPanel.NONE
}



export updatePanels :: (dt:float) {
	local project = openProjects[currentProjectIndex]

	project.zoom = math.moveTowards(
		project.zoom,
		project.zoomTarget,
		math.abs(project.zoomTarget - project.zoomSource) * dt / 0.05
	)
	project.panelScroll = math.moveTowards(
		project.panelScroll,
		project.panelScrollTarget,
		math.abs(project.panelScrollTarget - project.panelScrollSource) * dt / 0.05
	)
	auxPanelScroll = math.moveTowards(
		auxPanelScroll,
		auxPanelScrollTarget,
		math.abs(auxPanelScrollTarget - auxPanelScrollSource) * dt / 0.05
	)

	tooltipHoverTime = tooltipRendered ? tooltipHoverTime+dt : .0
	tooltipOpacity   = math.clamp01((tooltipHoverTime-.30)/0.20)
	tooltipRendered  = false

	if hasFocus()  focus.field.update!(dt)
}

export scrollPanels :: (mx,my:int, amount:int) {
	if isInsideContextMenu(mx, my)  return

	if isInsideAuxPanel(mx, my) {
		auxPanelScrollSource = auxPanelScroll
		auxPanelScrollTarget = math.min(auxPanelScrollTarget+50*amount, 0)

	} elseif auxPanel == AuxPanel.NONE {
		local project             = openProjects[currentProjectIndex]
		project.panelScrollSource = project.panelScroll
		project.panelScrollTarget = math.min(project.panelScrollTarget+50*amount, 0)
	}
}



export hasFocus :: () -> bool {
	return focusedPanelItem > 0
}
export hasFocus :: (panelItem:int) -> bool {
	return focusedPanelItem == panelItem
}

local setFocus :: (panelItem:int, value:string, x,y,w,h:int, valueX:int) {
	blurFocus()
	focusedPanelItem = panelItem

	focus = {
		x          = x,
		y          = y,
		width      = w,
		height     = h,
		valueX     = valueX,
		isPressing = true,
		field      = InputField(value),
	}

	focus.field.setFont!(fontNormal)
	focus.field.setWidth!(w)
}

export blurFocus :: () {
	focus            = NULL
	focusedPanelItem = 0
}


