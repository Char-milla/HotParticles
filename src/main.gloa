--[[============================================================
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

local MAX_BUFFER_SIZE :: 16000 -- Default buffer size for ParticleSystem is 1000. @Incomplete: make this configurable.



export !import "basic"
export !import "color"
export !import "string"
export io   :: !import "io"
export math :: !import "math"

export love :: !import "love"
export LD :: love.data
export LE :: love.event
export LF :: love.filesystem
export LG :: love.graphics
export LK :: love.keyboard
export LT :: love.timer

export !self
export !load "src/misc"
export !load "src/panel"
export !load "src/workspace"

!run {
	!import "compiler"
	compile("src/conf.gloa")
}



export fontSmall:  LG.Font  = NULL
export fontNormal: LG.Font  = NULL
export fontLarge:  LG.Font  = NULL

export imageChecker:  LG.Image = NULL
export imageGradient: LG.Image = NULL
export imagePixel:    LG.Image = NULL
export imageRainbow:  LG.Image = NULL

export particleImages: struct { !key:string, !value:LG.Image }

local canvasGui:   LG.Canvas = NULL
local canvasWorld: LG.Canvas = NULL

export actionText      = ""
export actionTextTime  = -9999.00
export messageText     = ""
export messageTextTime = -9999.00

export pressedAnythingThisFrame = false
export isPositioningParticles   = false

export scheduleSaveWorkspace    = false
export scheduleRecreateCanvases = false

export keysPressedThisFrame: struct { !key:LK.KeyConstant, !value:bool }

local particleUpdateTime = 0.00
local particleDrawTime   = 0.00

-- Saved settings.
export openProjects: []Project
export currentProjectIndex = 1

export showProjectSettings = true
export showStats           = true
export showPanelNumbers    = true



export Movement :: enum  { NONE::0, CIRCLE, EIGHT, IRREGULAR }

export Project :: struct {
	-- Saved:
	systems: []System,

	bgColorH = .0,
	bgColorS = .0,
	bgColorV = .15,

	pixelateWorld    = false,
	pixelateTextures = false,

	zoomLevel = 0,

	movementPreset = Movement.NONE,
	movementScaleX = 1.0,
	movementScaleY = 1.0,
	movementSpeed  = 1.0,

	-- Runtime-only:
	systemIndex = 1,

	zoom       = 1.0,
	zoomSource = 1.0,
	zoomTarget = 1.0,

	panelScroll       = 0.0,
	panelScrollSource = 0.0,
	panelScrollTarget = 0,

	displayedName = "",
	path          = "",
	fileIsSaved   = false, -- Saved at least once. It's possible that the file physically don't exist.

	movementPhase    = 0.0,
	movementPhaseAbs = 0.0,
	movementPoint1X  = 0.0, -- For irregular movement.
	movementPoint1Y  = 0.0,
	movementPoint2X  = 0.0,
	movementPoint2Y  = 0.0,
	movementPoint3X  = 0.0,
	movementPoint3Y  = 0.0,
	movementPoint4X  = 0.0,
	movementPoint4Y  = 0.0,

	!call :: () -> Project {
		static n = 0 ; n += 1
		return {displayedName=format("(unnamed %d)", n)}
	}
}

export System :: struct {
	-- Saved:
	particles: LG.ParticleSystem = NULL,

	colors: []float, -- {h1,s1,v1,a1,...}
	blendMode = LG.BlendMode.ALPHA,

	useCustomOffset = false,

	textureName = "light",
	-- textureIsPreset = true,
	-- texturePath     = "",

	-- Runtime-only:
	visible = true,

	!call :: () -> System {
		local system: System

		local ps = LG.newParticleSystem(particleImages.light)
		ps.start!()
		system.particles = ps

		return system
	},
}



export updateParticleColors :: (ps:LG.ParticleSystem, colors:[]float) {
	local colorsRgba: []float

	for i = 1, #colors, 4 {
		local r, g, b = hsvToRgb(colors[i], colors[i+1], colors[i+2])
		insert(colorsRgba, r)
		insert(colorsRgba, g)
		insert(colorsRgba, b)
		insert(colorsRgba, colors[i+3])
	}

	ps.setColors!(colorsRgba)
}

export addNewSystem :: (project:Project) {
	local system = System()
	system.colors    = {0,0,1,0, 0,0,1,1, 0,0,1,.5, 0,0,1,0}
	system.blendMode = LG.BlendMode.ADD
	insert(project.systems, system)

	local ps = system.particles
	ps.setEmissionRate!(20)
	ps.setDirection!(-math.TAU/4)
	ps.setSpread!(.05*math.TAU)
	ps.setParticleLifetime!(1.8, 2.2)
	ps.setSpeed!(90, 100)
	updateParticleColors(ps, system.colors)

	if project.systems[2] ~= NULL {
		local x, y = project.systems[1].particles.getPosition!()
		ps.setPosition!(x, y)
	}
}

export addNewProject :: () {
	local project = Project()
	insert(openProjects, project)

	addNewSystem(project)

	currentProjectIndex = #openProjects
}

export createCanvases :: () {
	local ww, wh = LG.getDimensions()

	if canvasGui ~= NULL {
		canvasGui  .release!()
		canvasWorld.release!()
	}

	local SETTINGS: LG.CanvasSettings : {msaa=2^2}
	canvasGui   = LG.newCanvas(ww, wh, SETTINGS)
	canvasWorld = LG.newCanvas(math.max(ww-MAIN_PANEL_WIDTH, 1), wh)

	if openProjects[currentProjectIndex].pixelateWorld {
		canvasWorld.setFilter!(LG.FilterMode.NEAREST, LG.FilterMode.NEAREST)
	}
}

export updateParticleImageFilters :: () {
	local filter = openProjects[currentProjectIndex].pixelateTextures ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR

	for cast(table) particleImages {
		LG.Image.setFilter(cast(LG.Image)it, filter, filter)
	}
}

export moveEmittersTo :: (x,y:float) {
	for openProjects[currentProjectIndex].systems  it.particles.moveTo!(x, y)
}



export onLoad :: (args:[]string, argsRaw:[]string) {
	io.disableBuffering(io.STDOUT)
	io.disableBuffering(io.STDERR)

	print("Running Hot Particles")

	LF.setIdentity("Hot Particles")
	LK.setKeyRepeat(true)

	fontSmall  = LG.newFont(10)
	fontNormal = LG.newFont(12)
	fontLarge  = LG.newFont(20)

	imageChecker  = LG.newImage("gfx/checker.png") ; imageChecker.setWrap!(LG.WrapMode.REPEAT, LG.WrapMode.REPEAT)
	imageGradient = LG.newImage("gfx/gradient.png")
	imagePixel    = LG.newImage("gfx/pixel.png")
	imageRainbow  = LG.newImage("gfx/rainbow.png")

	particleImages.light = LG.newImage("gfx/light.png")
	particleImages.moon  = LG.newImage("gfx/moon.png")

	local ok, gotError, projects = loadWorkspace()
	if ok {
		openProjects        = projects
		currentProjectIndex = 1
	} else {
		if gotError {
			messageText     = "Could not load previous workspace"
			messageTextTime = LT.getTime()
		}
		addNewProject()
	}

	createCanvases()
	updateParticleImageFilters()
}



export onKeyPressed :: (key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) {
	if love.mouse.isGrabbed()  return

	keysPressedThisFrame[key] = true

	local mod     = getModifierKey()
	local project = openProjects[currentProjectIndex]

	if key == {
		case "escape":
			if not hideContextMenu() {
				saveWorkspace()
				LE.quit(0)
			}

		case "tab":
			if mod == {
				case ModifierKey.NONE: project.systemIndex = (project.systemIndex-0) % #project.systems + 1 ; scheduleRecreateCanvases = true
				case ModifierKey.S:    project.systemIndex = (project.systemIndex-2) % #project.systems + 1 ; scheduleRecreateCanvases = true
				case ModifierKey.C:    currentProjectIndex = (currentProjectIndex-0) % #openProjects    + 1
				case ModifierKey.CS:   currentProjectIndex = (currentProjectIndex-2) % #openProjects    + 1
			}

		case "r":
			if mod == {
				case ModifierKey.NONE:
					for project.systems { it.particles.reset!() ; it.particles.start!() }
			}

		case "h":
			if mod == {
				case ModifierKey.NONE:
					local system   = project.systems[project.systemIndex]
					system.visible = not system.visible
			}

		case "f1":
			if mod == {
				case ModifierKey.NONE:
					showStats             = not showStats
					scheduleSaveWorkspace = true
			}

		case "f2":
			if mod == {
				case ModifierKey.NONE:
					showPanelNumbers      = not showPanelNumbers
					scheduleSaveWorkspace = true
			}

		case "f10":
			if mod == {
				case ModifierKey.C:
					saveWorkspace()
					LE.restart()
			}
	}
}

export onMousePressed :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	pressedAnythingThisFrame = true

	if love.mouse.isGrabbed()  return

	if isInsidePanels(mx, my)  pressedOnPanelWithMouseButton = mbutton

	if mbutton == 1 {
		if not pressedOnPanelWithMouseButton {
			isPositioningParticles = true
			onMouseMoved(mx,my, 0,0, isTouch)
		}
		love.mouse.setGrabbed(true)
	}
}
export onMouseMoved :: (mx,my:int, dx,dy:int, isTouch:bool) {
	if isPositioningParticles {
		local project = openProjects[currentProjectIndex]

		local x = (mx - (LG.getWidth()+MAIN_PANEL_WIDTH)/2) / project.zoom
		local y = (my - (LG.getHeight()                )/2) / project.zoom

		moveEmittersTo(x, y)
	}
}
export onMouseReleased :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if mbutton == 1 {
		stopDraggingInPanels()
		isPositioningParticles = false
		love.mouse.setGrabbed(false)
	}
}
export onMouseWheel :: (dx,dy:int) {
	if love.mouse.isGrabbed()  return

	local mod = getModifierKey()
	if mod == ModifierKey.S {
		shiftScrolledOnPanel = -dy
		return
	}
	if mod ~= ModifierKey.NONE  return

	local mx, my = love.mouse.getPosition()

	if isInsidePanels(mx, my) {
		scrollPanels(mx,my, dy)

	} else {
		local project = openProjects[currentProjectIndex]

		project.zoomLevel  = math.clamp(project.zoomLevel+dy, (project.pixelateWorld ? -1 : -4), 6)
		project.zoomSource = project.zoom
		project.zoomTarget = 2^project.zoomLevel

		actionText     = format("Zoom: %d%%", project.zoomTarget*100)
		actionTextTime = LT.getTime()
	}
}



export onUpdate :: (dt:float) {
	local project = openProjects[currentProjectIndex]

	do {
		local systemsActive = false

		local time = LT.getTime()
		for project.systems  it.particles.update!(dt)
		particleUpdateTime = LT.getTime()-time

		for project.systems {
			local ps         = it.particles
			local bufferSize = ps.getBufferSize!()

			systemsActive = systemsActive or ps.isActive!() or ps.getCount!() > 0

			if ps.getCount!() > bufferSize-10 and bufferSize < MAX_BUFFER_SIZE {
				ps.setBufferSize!(2*bufferSize)

				actionText     = "Increased buffer size"
				actionTextTime = LT.getTime()
			}
		}

		if not systemsActive {
			for project.systems  it.particles.start!()
		}
	}

	if scheduleSaveWorkspace     saveWorkspace() -- @UX: Maybe wait a little while before saving?
	if scheduleRecreateCanvases  createCanvases()

	if not isPositioningParticles {
		local MOVEMENT_BASE :: 250

		-- project.movementSpeed = LK.isDown"." ? .04 : 1.0 -- DEBUG

		local lastMovementPhaseAbs  = project.movementPhaseAbs
		project.movementPhase      +=         (project.movementSpeed) * dt
		project.movementPhaseAbs   += math.abs(project.movementSpeed) * dt

		using project.movementPreset
		if !complete project.movementPreset == {
			case NONE:
				-- void

			case CIRCLE:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE * project.movementScaleY * math.sin(angle)
				)

			case EIGHT:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE   * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE/2 * project.movementScaleY * math.sin(angle*2)
				)

			case IRREGULAR:
				if math.floor(project.movementPhaseAbs) ~= math.floor(lastMovementPhaseAbs) or lastMovementPhaseAbs == 0 {
					local dx       = project.movementPoint3X - project.movementPoint4X
					local dy       = project.movementPoint3Y - project.movementPoint4Y
					local angleOld = math.atan(-dy, -dx)

					project.movementPoint1X = project.movementPoint4X
					project.movementPoint1Y = project.movementPoint4Y
					project.movementPoint2X = project.movementPoint4X - dx
					project.movementPoint2Y = project.movementPoint4Y - dy
					project.movementPoint4X = .8*MOVEMENT_BASE * (2*love.math.random()-1)
					project.movementPoint4Y = .8*MOVEMENT_BASE * (2*love.math.random()-1)

					dx             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					dy             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					local angleNew = math.atan(dy, dx)

					if math.angleDistance(angleNew, angleOld) > math.TAU/4 {
						dx = -dx
						dy = -dy
					}

					project.movementPoint3X = project.movementPoint4X + dx
					project.movementPoint3Y = project.movementPoint4Y + dy
				}

				local phase    = project.movementPhaseAbs % 1
				local phaseOld =     math.sin  (phase * math.TAU/4)
				local phaseNew = 1 - math.cos  (phase * math.TAU/4)
				local phaseMid = 1 - math.cos01(phase * math.TAU/2)

				moveEmittersTo(
					project.movementScaleX * math.lerp(
						math.lerp(project.movementPoint1X, project.movementPoint2X, phaseOld),
						math.lerp(project.movementPoint3X, project.movementPoint4X, phaseNew),
						phaseMid
					),
					project.movementScaleY * math.lerp(
						math.lerp(project.movementPoint1Y, project.movementPoint2Y, phaseOld),
						math.lerp(project.movementPoint3Y, project.movementPoint4Y, phaseNew),
						phaseMid
					)
				)
		}
	}

	updatePanels(dt)
}



export onDraw :: () {
	local ww, wh  = LG.getDimensions()
	local project = openProjects[currentProjectIndex]

	LG.reset()

	-- GUI.
	do {
		LG.setCanvas(canvasGui)
		LG.clear()

		LG.setFont(fontNormal)

		-- Stats.
		if showStats {
			local particleCountTotal = 0
			for project.systems  particleCountTotal += it.particles.getCount!()

			local fontH = fontNormal.getHeight!()

			local x = MAIN_PANEL_WIDTH+5
			local y = 5

			local r, g, b          = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
			local _, _, brightness = rgbToHsp(r, g, b)
			if brightness < .5
				LG.setColor(1, 1, 1, .7)
			else
				LG.setColor(0, 0, 0, .7)

			local drawStatsLine = [x,y,fontH] (s:string, ...:int|float|string) {
				LG.print(format(s, ...), x, y)
				y += fontH+1
			}

			drawStatsLine("FPS: %d", LT.getFPS())
			drawStatsLine("ParticleSystemUpdateTime: %.3f ms", 1000*particleUpdateTime)
			drawStatsLine("ParticleSystemDrawTime: %.3f ms",   1000*particleDrawTime)
			drawStatsLine("ParticleCountTotal: %d",            particleCountTotal)
			for project.systems  drawStatsLine("ParticleCount_%d: %d", itIndex, it.particles.getCount!())
			drawStatsLine("(hide this with F1)")
		}

		-- Panel(s).
		drawPanels()

		-- HUD texts.
		LG.origin()
		LG.setFont(fontLarge)

		local visibility = 1 - (LT.getTime() - messageTextTime) / 8.00
		if visibility > 0 {
			local x = math.round((ww+MAIN_PANEL_WIDTH-fontLarge.getWidth!(messageText))/2)
			local y = math.round(.1*wh)
			local a = visibility^.5
			LG.setColor(0, 0, 0, a)
			LG.print(messageText, x+1, y+1)
			LG.setColor(1, 1, 1, a)
			LG.print(messageText, x, y)
		}

		visibility = 1 - (LT.getTime() - actionTextTime) / 0.60
		if visibility > 0 {
			local x = math.round((ww+MAIN_PANEL_WIDTH-fontLarge.getWidth!(actionText))/2)
			local y = math.round(.1*wh+fontLarge.getHeight!())
			local a = visibility^.5
			LG.setColor(0, 0, 0, a)
			LG.print(actionText, x+1, y+1)
			LG.setColor(1, 1, 1, a)
			LG.print(actionText, x, y)
		}

		-- Mouse stuff.
		--[[
		local mx, my = love.mouse.getPosition()
		if isPositioningParticles {
			LG.setColor(1, 0, 0)
			LG.line(mx-50, my, mx+50, my)
			LG.line(mx, my-50, mx, my+50)
		}
		--]]

		LG.reset()
	}

	-- World.
	do {
		LG.setCanvas(canvasWorld)

		local r, g, b = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
		LG.clear(r, g, b)

		LG.translate((ww-MAIN_PANEL_WIDTH)/2, wh/2)
		if not project.pixelateWorld  LG.scale(project.zoom)

		local time = LT.getTime()

		for project.systems {
			if it.visible {
				LG.setBlendMode(it.blendMode)
				LG.draw(it.particles)
			}
		}
		LG.setBlendMode(LG.BlendMode.ALPHA)

		particleDrawTime = LT.getTime()-time -- Not sure how accurate this actually is. This value is still very low even while the actual FPS is tanking a lot.

		--[[ DEBUG
		LG.setColor(1, 1, 1, .15)
		LG.line(project.movementPoint1X, project.movementPoint1Y, project.movementPoint2X, project.movementPoint2Y)
		LG.line(project.movementPoint2X, project.movementPoint2Y, project.movementPoint3X, project.movementPoint3Y)
		LG.line(project.movementPoint3X, project.movementPoint3Y, project.movementPoint4X, project.movementPoint4Y)
		LG.setColor(1, 1, 1, .3)
		LG.print("1", project.movementPoint1X, project.movementPoint1Y)
		LG.print("2", project.movementPoint2X, project.movementPoint2Y)
		LG.print("3", project.movementPoint3X, project.movementPoint3Y)
		LG.print("4", project.movementPoint4X, project.movementPoint4Y)
		--]]

		LG.reset()
	}

	-- Put stuff on the screen!
	LG.clear()
	LG.setBlendMode(LG.BlendMode.ALPHA, LG.BlendAlphaMode.PREMULTIPLIED)

	if project.pixelateWorld {
		LG.draw(canvasWorld, (ww+MAIN_PANEL_WIDTH)/2,wh/2, 0, project.zoom,project.zoom, (ww-MAIN_PANEL_WIDTH)/2, wh/2)
	} else {
		LG.draw(canvasWorld, MAIN_PANEL_WIDTH,0)
	}

	LG.draw(canvasGui)

	-- We have to reset these here instead of in onUpdate() as a bunch of update stuff happen while we draw things.
	keysPressedThisFrame     = {}
	pressedAnythingThisFrame = false
}



export onResize :: (w,h:int) {
	createCanvases()
}



export main :: () {
	!import "utils"
	local loveTable: table : !foreign lua "love"

	loveTable.load          = wrapFunctionInGloaErrorHandler(onLoad)
	loveTable.keypressed    = wrapFunctionInGloaErrorHandler(onKeyPressed)
	loveTable.mousepressed  = wrapFunctionInGloaErrorHandler(onMousePressed)
	loveTable.mousemoved    = wrapFunctionInGloaErrorHandler(onMouseMoved)
	loveTable.mousereleased = wrapFunctionInGloaErrorHandler(onMouseReleased)
	loveTable.wheelmoved    = wrapFunctionInGloaErrorHandler(onMouseWheel)
	loveTable.update        = wrapFunctionInGloaErrorHandler(onUpdate)
	loveTable.draw          = wrapFunctionInGloaErrorHandler(onDraw)
	loveTable.resize        = wrapFunctionInGloaErrorHandler(onResize)
	loveTable.errhand       = nil
	loveTable.errorhandler  = nil
}


