--[[============================================================
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

export MAX_BUFFER_SIZE      :: 16000 -- Default buffer size for ParticleSystem is 1000. @Incomplete: make this configurable.
export MAIN_PANEL_WIDTH     :: 450
export DIALOG_WIDTH         :: 400
export WORKSPACE_SAVE_DELAY :: 1.00
export MAX_RECENT_FILES     :: 20
export MAX_RECENT_FOLDERS   :: 4



local isDev :: () -> bool {
	!import"utils"
	return (indexOf(getProgramArguments(), "--dev"))
}
export DEV :: !run isDev()



export !import "basic"
export !import "color"
export !import "string"
export io     :: !import "io"
export math   :: !import "math"
export physfs :: !import "love/physfs"

export love :: !import "love"
export LD :: love.data
export LF :: love.filesystem
export LG :: love.graphics
export LK :: love.keyboard
export LM :: love.mouse
export LT :: love.timer
local  LE :: love.event

export !self
export !load "src/misc"
export !load "src/workspace"
export gui :: !load "src/gui"
!load "src/guiSetup"

!run {
	!import "compiler"
	compile("src/conf.gloa")
}



export fontSmall:  LG.Font = NULL
export fontNormal: LG.Font = NULL
export fontLarge:  LG.Font = NULL

export imageChecker:  LG.Image = NULL
export imageGradient: LG.Image = NULL
export imagePixel:    LG.Image = NULL
export imageRainbow:  LG.Image = NULL

export particleImageNames: []string
export particleImages: struct { !key:string, !value:LG.Image }
export guiImages:      struct { !key:string, !value:LG.Image }

local canvasGui:   LG.Canvas = NULL
local canvasWorld: LG.Canvas = NULL

local actionText          = ""
local actionTextTime      = -9999.00
local actionTextDuration :: 0.60
local messageText         = ""
local messageTextTime     = -9999.00
local messageTextDuration = 1.00

export isPositioningParticles = false

export workspaceSaveScheduled = false
export workspaceSaveDelay     = 0.00
export workspaceSaveTime      = -9999.00

export scheduleRecreateCanvases = false

local particleUpdateTime = 0.00
local particleDrawTime   = 0.00
local presentTime        = 0.00

local defaultSearchPaths: []string = NULL

export guiState: gui.State

local freezeDtThisFrame = false

local zoomTime = -9999.00

export app: App



export App :: struct {
	-- Saved workspace data:

	projects: []Project,
	currentProjectIndex = 1,

	showProjectSettings = false,
	showStats           = false,
	showPanelNumbers    = true,

	recentFiles:   []string,
	recentFolders: []string,

	bookmarkedFolders: []string,
}



export Movement :: enum  { NONE::0, CIRCLE, EIGHT, IRREGULAR }

export Project :: struct {
	-- Saved:
	systems: []System,

	bgColorH  = .0,
	bgColorS  = .0,
	bgColorV  = .15,
	bgChecker = 0.0,

	pixelateWorld    = false,
	pixelateTextures = false,

	zoomLevel = 0,

	movementPreset = Movement.NONE,
	movementScaleX = 1.0,
	movementScaleY = 1.0,
	movementSpeed  = 1.0,

	path = "",

	-- Runtime-only:
	systemIndex = 1,

	zoom       = 1.0,
	zoomSource = 1.0,
	zoomTarget = 1.0,

	displayedName = "",
	fileIsSaved   = false, -- Saved at least once (or loaded from a saved file). It's possible that the file physically don't exist (maybe deleted or moved).
	preview       = false,

	movementPhase    = 0.0,
	-- For irregular movement:
	movementPhaseAbs = 0.0,
	movementPoint1X  = 0.0,
	movementPoint1Y  = 0.0,
	movementPoint2X  = 0.0,
	movementPoint2Y  = 0.0,
	movementPoint3X  = 0.0,
	movementPoint3Y  = 0.0,
	movementPoint4X  = 0.0,
	movementPoint4Y  = 0.0,

	!call :: () -> Project {
		static n = 0 ; n += 1
		return {displayedName=format("(untitled %d)", n)}
	}
}

export System :: struct {
	-- Saved:
	particles: LG.ParticleSystem = NULL,

	colors: []float, -- {h1,s1,v1,a1,...}
	blendMode = LG.BlendMode.ALPHA,

	useCustomOffset = false,

	texturePath = "",
	textureName = "light", -- Preset fallback to texturePath.

	-- Runtime-only:
	visible = true,

	!call :: () -> System {
		local system: System

		local ps = LG.newParticleSystem(particleImages.light)
		ps.start!()
		system.particles = ps

		return system
	},
}



export updateParticleColors :: (ps:LG.ParticleSystem, colors:[]float) {
	local colorsRgba: []float

	for i = 1, #colors, 4 {
		local r, g, b = hsvToRgb(colors[i], colors[i+1], colors[i+2])
		insert(colorsRgba, r)
		insert(colorsRgba, g)
		insert(colorsRgba, b)
		insert(colorsRgba, colors[i+3])
	}

	ps.setColors!(colorsRgba)
}

export updateParticleImageFilters :: () {
	local filter = app.projects[app.currentProjectIndex].pixelateTextures ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR

	for particleImageNames {
		LG.Image.setFilter(particleImages[it], filter, filter)
	}
}



export addNewSystem :: (project:Project) {
	local system = System()
	system.colors    = {0,0,1,0, 0,0,1,1, 0,0,1,.5, 0,0,1,0}
	system.blendMode = LG.BlendMode.ADD
	insert(project.systems, system)

	local ps = system.particles
	ps.setEmissionRate!(20)
	ps.setDirection!(-math.TAU/4)
	ps.setSpread!(.05*math.TAU)
	ps.setParticleLifetime!(1.8, 2.2)
	ps.setSpeed!(90, 100)
	updateParticleColors(ps, system.colors)

	if project.systems[2] ~= NULL {
		local x, y = project.systems[1].particles.getPosition!()
		ps.setPosition!(x, y)
	}
}

export addNewProject :: () -> Project {
	local project = Project()
	insert(app.projects, project)

	addNewSystem(project)

	return project
}



export createCanvases :: () {
	local ww, wh = LG.getDimensions()

	if canvasGui ~= NULL {
		canvasGui  .release!()
		canvasWorld.release!()
	}

	local SETTINGS: LG.CanvasSettings : {msaa=2^2}
	canvasGui   = LG.newCanvas(ww, wh, SETTINGS)
	canvasWorld = LG.newCanvas(math.max(ww-MAIN_PANEL_WIDTH, 1), wh)

	if app.projects[app.currentProjectIndex].pixelateWorld {
		canvasWorld.setFilter!(LG.FilterMode.NEAREST, LG.FilterMode.NEAREST)
	}

	scheduleRecreateCanvases = false
}



export moveEmittersTo :: (x,y:float) {
	for app.projects[app.currentProjectIndex].systems  it.particles.moveTo!(x, y)
}



export pushQuitEvent :: () {
	saveWorkspace()
	LE.quit(0)
}



export connectToRemoteDirectory :: (dir:string) -> (success:bool) {
	if not physfs.setWriteDirectory(dir)  return false

	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it))

	assert(physfs.mountReadDirectory(dir)) -- If we can write then we should be able to read too.
	return true
}

export disconnectFromRemoteDirectory :: () {
	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it))
	for defaultSearchPaths       assert(physfs.mountReadDirectory(it, true))

	assert(physfs.setWriteDirectory(LF.getSaveDirectory()))
}



export setActionText :: (s:string) {
	actionText     = s
	actionTextTime = LT.getTime()
	messageText    = "" -- Good?
}
export setActionText :: (s:string, v,...:int|float|string) {
	setActionText(format(s, v, ...))
}

export setMessageText :: (s:string) {
	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 3.00
}
export setMessageText :: (s:string, v,...:int|float|string) {
	setMessageText(format(s, v, ...))
}

export setErrorText :: (s:string) {
	messageText         = "Error: "..s
	messageTextTime     = LT.getTime()
	messageTextDuration = 8.00
}
export setErrorText :: (s:string, v,...:int|float|string) {
	setErrorText(format(s, v, ...))
}



export onRun :: () -> (mainLoop:()->int|none) {
	local LOVE: struct { !key:string, !value:(...:love.Variant) } : !foreign lua "love"

	local argsRaw = !import"utils".getCommandLineArguments()
	LOVE.load(love.arg.parseGameArguments(argsRaw), argsRaw)

	LT.step()
	local dt = .0

	return [dt] () -> int|none {
		LE.pump()
		for name, a,b,c,d,e,f in LE.poll() {
			if name == LE.Event.QUIT {
				-- if not (cast(()->bool)cast(any)LOVE.quit)() {
					return a == NULL ? 0 : cast(int)a
				-- }
			}
			local HANDLERS: struct { !key:LE.Event, !value:(...:love.Variant) } : !foreign lua "love.handlers"
			HANDLERS[name](a,b,c,d,e,f)
		}

		dt = LT.step()
		LOVE.update(dt)

		if LG.isActive()  LOVE.draw()

		LT.sleep(0.001)
		return nil
	}
}



export onLoad :: (args:[]string, argsRaw:[]string) {
	io.disableBuffering(io.STDOUT)
	io.disableBuffering(io.STDERR)

	print("Running Hot Particles")
	!if DEV  love.window.setTitle(love.window.getTitle().." [DEBUG]")

	LK.setKeyRepeat(true)

	defaultSearchPaths = physfs.getSearchPaths()

	LF.createDirectory("projects")

	fontSmall  = LG.newFont(10)
	fontNormal = LG.newFont(12)
	fontLarge  = LG.newFont(16)

	imageChecker  = LG.newImage("gfx/checker.png") ; imageChecker.setWrap!(LG.WrapMode.REPEAT, LG.WrapMode.REPEAT) ; imageChecker.setFilter!(LG.FilterMode.NEAREST, LG.FilterMode.NEAREST)
	imageGradient = LG.newImage("gfx/gradient.png")
	imagePixel    = LG.newImage("gfx/pixel.png")
	imageRainbow  = LG.newImage("gfx/rainbow.png")

	!load "src/icons"
	generateIcons()

	for LF.getDirectoryItems"gfx/particles" {
		local found, name = matchPattern(it, "^(.+)%.png$")

		if found {
			local image = LG.newImage("gfx/particles/"..it)

			particleImages[cast(string)name] = image
			guiImages[cast(string)name]      = image

			insert(particleImageNames, cast(string)name)
		}
	}

	local ok, gotError, _app = loadWorkspace("workspace")
	if ok {
		app = _app
		assert(app.projects[1] ~= NULL)
	} else {
		if gotError  setErrorText("Could not load previous workspace")
		addNewProject()
	}

	love.window.setVSync(app.showStats ? 0 : 1)

	setupGuiFrames()
	setupGuiCallbacks()
	gui.refreshAll(guiState)

	setCurrentProject(app.currentProjectIndex, force=true)
}



export onKeyPressed :: (key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) {
	local mod     = getModifierKey()
	local project = app.projects[app.currentProjectIndex]

	-- Global keys.
	if not LM.isGrabbed()  if key == {
		case "q":
			if mod == {
				case ModifierKey.C: pushQuitEvent() ; return
			}

		case "f10":
			if mod == {
				case ModifierKey.C: saveWorkspace() ; LE.restart() ; return
			}

		case "f1":
			if mod == {
				case ModifierKey.NONE:
					app.showStats = not app.showStats
					love.window.setVSync(app.showStats ? 0 : 1)
					scheduleSaveWorkspace()
					return
			}

		case "f2":
			if mod == {
				case ModifierKey.NONE:
					app.showPanelNumbers = not app.showPanelNumbers
					scheduleSaveWorkspace()
					return
			}
	}

	if gui.onKeyPressed(guiState, key, scancode, isRepeat)  return
	if LM.isGrabbed()  return

	-- Context-sensitive global keys.
	if key == {
		case "escape":
			if not popPanel()  pushPanel("exit")
			return

		case "r":
			if mod == {
				case ModifierKey.NONE:
					for project.systems {
						it.particles.reset!()
						it.particles.start!()
					}
					return
			}
	}

	if panelStack  return

	-- Keys in normal view.
	if key == {
		case "tab":
			if mod == {
				case ModifierKey.NONE: setCurrentSystem ((project.systemIndex-0) % #project.systems + 1)
				case ModifierKey.S:    setCurrentSystem ((project.systemIndex-2) % #project.systems + 1)
				case ModifierKey.C:    setCurrentProject((app.currentProjectIndex-0) % #app.projects    + 1)
				case ModifierKey.CS:   setCurrentProject((app.currentProjectIndex-2) % #app.projects    + 1)
			}

		case "h":
			if mod == {
				case ModifierKey.NONE:
					local system   = project.systems[project.systemIndex]
					system.visible = not system.visible
			}

		case "s":
			if mod == {
				case ModifierKey.C:  if project.fileIsSaved  saveProject(project, overwrite=true)  else  pushPanel("saveProjectAs")
				case ModifierKey.CS: pushPanel("saveProjectAs")
			}

		case "o":
			if mod == {
				case ModifierKey.C: pushPanel("openProject")
			}

		case "p":
			if mod == {
				case ModifierKey.NONE: gui.setActive(guiState, "main", not gui.getElement(guiState, "main", gui.Frame).active)
			}
	}
}

export onKeyReleased :: (key:LK.KeyConstant, scancode:LK.Scancode) {
	gui.onKeyReleased(guiState, key, scancode)
}

export onTextInput :: (text:string) {
	if gui.onTextInput(guiState, text)  return
}

export onMousePressed :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch         return
	if LM.isGrabbed()  return

	if gui.onMousePressed(guiState, mx, my, mbutton, presses)  return

	if mbutton == 1 {
		isPositioningParticles = true
		LM.setGrabbed(true)
		LK.setKeyRepeat(false)
		onMouseMoved(mx,my, 0,0, false)
	}
}

export onMouseMoved :: (mx,my:int, dx,dy:int, isTouch:bool) {
	if isTouch  return

	if isPositioningParticles {
		local project = app.projects[app.currentProjectIndex]

		local x = (mx - (LG.getWidth()+MAIN_PANEL_WIDTH)/2) / project.zoom
		local y = (my - (LG.getHeight()                )/2) / project.zoom

		moveEmittersTo(x, y)
		return
	}

	gui.onMouseMoved(guiState, mx, my, dx, dy)
}

export onMouseReleased :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch  return

	if isPositioningParticles and mbutton == 1 {
		isPositioningParticles = false
		LM.setGrabbed(false)
		LK.setKeyRepeat(true)
		gui.onMouseMoved(guiState, mx, my, 0, 0)
		return
	}

	gui.onMouseReleased(guiState, mx, my, mbutton, presses)
}

export onMouseWheel :: (dx,dy:int) {
	if LM.isGrabbed()                      return
	if gui.onMouseWheel(guiState, dx, dy)  return
	if not dy                              return

	local mx, my = LM.getPosition()
	if gui.isOverGui(guiState, mx, my)  return

	local mod = getModifierKey()
	if mod ~= ModifierKey.NONE  return

	local project   = app.projects[app.currentProjectIndex]
	local zoomLevel = project.zoomLevel
	local now       = LT.getTime()

	for 1, math.abs(dy) {
		-- Stick slightly to 100% zoom.
		if zoomLevel == 0 and now-zoomTime < 0.15  break

		zoomLevel = math.clamp(zoomLevel + math.getSign(dy), (project.pixelateWorld ? -1 : -4), 6)
	}

	zoomTime = now

	if zoomLevel == project.zoomLevel  return

	project.zoomLevel  = zoomLevel
	project.zoomSource = project.zoom
	project.zoomTarget = 2 ^ project.zoomLevel

	setActionText("Zoom: %d%%", project.zoomTarget * 100)
}



export onUpdate :: (dt:float) {
	if freezeDtThisFrame {
		dt                = 0
		freezeDtThisFrame = false
	}

	local project = app.projects[app.currentProjectIndex]

	if gui.getTopmostActiveModal(guiState) == NULL {
		local systemsActive = false

		local time = LT.getTime()
		for project.systems  it.particles.update!(dt)
		particleUpdateTime = LT.getTime()-time

		-- F for fast-forward!
		if not guiState.focusId and LK.isDown"f" and getModifierKey() == ModifierKey.NONE {
			for 2, 10 {
				for project.systems  it.particles.update!(dt)
			}
		}

		for project.systems {
			local ps         = it.particles
			local bufferSize = ps.getBufferSize!()

			systemsActive = systemsActive or ps.isActive!() or ps.getCount!() > 0

			if ps.getCount!() > bufferSize-10 and bufferSize < MAX_BUFFER_SIZE {
				ps.setBufferSize!(2*bufferSize)
				setActionText("Increased buffer size")
			}
		}

		if not systemsActive {
			for project.systems  it.particles.start!()
		}
	}

	if workspaceSaveScheduled {
		workspaceSaveDelay -= dt
		if workspaceSaveDelay <= 0  saveWorkspace()
	}

	if scheduleRecreateCanvases  createCanvases()

	if not isPositioningParticles {
		local MOVEMENT_BASE :: 250

		-- project.movementSpeed = LK.isDown"." ? .04 : 1 -- DEBUG

		local lastMovementPhaseAbs  = project.movementPhaseAbs
		project.movementPhase      +=         (project.movementSpeed) * dt
		project.movementPhaseAbs   += math.abs(project.movementSpeed) * dt

		using project.movementPreset
		if !complete project.movementPreset == {
			case NONE:
				-- void

			case CIRCLE:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE * project.movementScaleY * math.sin(angle)
				)

			case EIGHT:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE   * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE/2 * project.movementScaleY * math.sin(angle*2)
				)

			case IRREGULAR:
				if math.floor(project.movementPhaseAbs) ~= math.floor(lastMovementPhaseAbs) or lastMovementPhaseAbs == 0 {
					local dx       = project.movementPoint3X - project.movementPoint4X
					local dy       = project.movementPoint3Y - project.movementPoint4Y
					local angleOld = math.atan(-dy, -dx)

					project.movementPoint1X = project.movementPoint4X
					project.movementPoint1Y = project.movementPoint4Y
					project.movementPoint2X = project.movementPoint4X - dx
					project.movementPoint2Y = project.movementPoint4Y - dy
					project.movementPoint4X = .8*MOVEMENT_BASE * (2*love.math.random()-1)
					project.movementPoint4Y = .8*MOVEMENT_BASE * (2*love.math.random()-1)

					dx             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					dy             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					local angleNew = math.atan(dy, dx)

					if math.angleDistance(angleNew, angleOld) > math.TAU/4 {
						dx = -dx
						dy = -dy
					}

					project.movementPoint3X = project.movementPoint4X + dx
					project.movementPoint3Y = project.movementPoint4Y + dy
				}

				local phase    = project.movementPhaseAbs % 1
				local phaseOld =     math.sin  (phase * math.TAU/4)
				local phaseNew = 1 - math.cos  (phase * math.TAU/4)
				local phaseMid = 1 - math.cos01(phase * math.TAU/2)

				moveEmittersTo(
					project.movementScaleX * math.lerp(
						math.lerp(project.movementPoint1X, project.movementPoint2X, phaseOld),
						math.lerp(project.movementPoint3X, project.movementPoint4X, phaseNew),
						phaseMid
					),
					project.movementScaleY * math.lerp(
						math.lerp(project.movementPoint1Y, project.movementPoint2Y, phaseOld),
						math.lerp(project.movementPoint3Y, project.movementPoint4Y, phaseNew),
						phaseMid
					)
				)
		}
	}

	project.zoom = math.moveTowards(
		project.zoom,
		project.zoomTarget,
		math.abs(project.zoomTarget - project.zoomSource) * dt / 0.05
	)

	gui.update(guiState, dt)
}



export onDraw :: () {
	static statsAll:   LG.Stats
	static statsWorld: LG.Stats

	local ww, wh  = LG.getDimensions()
	local project = app.projects[app.currentProjectIndex]

	LG.reset()

	-- World.
	do {
		LG.setCanvas(canvasWorld)

		local r, g, b = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
		LG.clear(r, g, b)

		if project.bgChecker {
			if project.bgChecker > 0
				LG.setColor(1, 1, 1, project.bgChecker)
			else
				LG.setColor(0, 0, 0, -project.bgChecker)
			gui.drawChecker(0, 0, ww, wh, 2)
		}

		LG.translate((ww-MAIN_PANEL_WIDTH)/2, wh/2)
		if not project.pixelateWorld  LG.scale(project.zoom)

		local time = LT.getTime()

		LG.setColor(1, 1, 1)
		for project.systems {
			if it.visible {
				LG.setBlendMode(it.blendMode)
				LG.draw(it.particles)
			}
		}

		particleDrawTime = LT.getTime()-time -- Not sure how accurate this actually is. This value is still very low even while the actual FPS is tanking a lot.
		-- !if DEV  LG.getStats(statsWorld)

		--[[ DEBUG
		LG.setColor(1, 1, 1, .15)
		LG.line(project.movementPoint1X, project.movementPoint1Y, project.movementPoint2X, project.movementPoint2Y)
		LG.line(project.movementPoint2X, project.movementPoint2Y, project.movementPoint3X, project.movementPoint3Y)
		LG.line(project.movementPoint3X, project.movementPoint3Y, project.movementPoint4X, project.movementPoint4Y)
		LG.setColor(1, 1, 1, .3)
		LG.print("1", project.movementPoint1X, project.movementPoint1Y)
		LG.print("2", project.movementPoint2X, project.movementPoint2Y)
		LG.print("3", project.movementPoint3X, project.movementPoint3Y)
		LG.print("4", project.movementPoint4X, project.movementPoint4Y)
		--]]

		LG.reset()
	}

	-- GUI.
	do {
		LG.setCanvas(canvasGui)
		LG.clear()

		LG.setFont(fontNormal)

		-- Stats.
		if app.showStats {
			local particleCountTotal = 0
			for project.systems  particleCountTotal += it.particles.getCount!()

			local fontH = fontNormal.getHeight!()

			local x = MAIN_PANEL_WIDTH+5
			local y = 5

			local r, g, b          = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
			local _, _, brightness = rgbToHsp(r, g, b)
			if brightness < .5
				LG.setColor(1, 1, 1, .7)
			else
				LG.setColor(0, 0, 0, .7)

			local drawStatsLine = [x,y,fontH] (pre:string, s:string, ...:int|float|string) {
				LG.print(pre, x, y)
				if s  LG.print(format(s, ...), x+fontNormal.getWidth!(pre), y)
				y += fontH+1
			}

			local _, _, windowMode = love.window.getMode()
			local ratio            = 1 / presentTime / windowMode.refreshrate

			drawStatsLine("FPS: ", "%d", LT.getFPS())

			!if DEV {
				local stats = statsAll
				if stats ~= NULL {
					drawStatsLine("drawcalls (batched): ",    "%d (%d)",  stats.drawcalls, stats.drawcallsbatched)
					drawStatsLine("switches canvas/shader: ", "%d/%d",    stats.canvasswitches, stats.shaderswitches)
					drawStatsLine("texture memory: ",         "%.2f MiB", stats.texturememory/1024^2)
					drawStatsLine("images/fonts/canvases: ",  "%d/%d/%d", stats.images, stats.fonts, stats.canvases)
				}
			}

			drawStatsLine("ParticleSystemUpdateTime: ", "%.3f ms", 1000*particleUpdateTime)
			drawStatsLine("ParticleSystemDrawTime: ",   "%.3f ms", 1000*particleDrawTime)

			if not windowMode.refreshrate {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms", 1000*presentTime)
			} elseif ratio >= 10 {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.0f.0 x framerate)", 1000*presentTime, ratio)
			} elseif ratio >= 2 {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.1f0 x framerate)",  1000*presentTime, ratio)
			} else {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.2f x framerate)",   1000*presentTime, ratio)
			}

			drawStatsLine("ParticleCountTotal: ", "%d", particleCountTotal)

			for project.systems  drawStatsLine("ParticleCount_", "%d: %d", itIndex, it.particles.getCount!())

			!if not DEV  drawStatsLine("(hide this with F1)", "")
		}

		-- Panel(s).
		gui.draw(guiState)

		-- GUI texts.
		local drawGuiText :: (text:string, time:float, duration:float, y:int) {
			local PADDING_X :: 15
			local PADDING_Y :: 3

			local visibility = 1 - (LT.getTime() - time) / duration
			if visibility <= 0  return

			local w = fontLarge.getWidth!(text)
			local x = math.round((LG.getWidth() + MAIN_PANEL_WIDTH - w) / 2)
			local a = visibility^.5

			LG.setColor(0, 0, 0, a)
			LG.print(text, x+1, y+1)

			LG.setColor(1, 1, 1, a)
			LG.print(text, x, y)
		}

		local anyInfiniteEmitter = false
		local anyFiniteEmitter   = false

		for project.systems {
			if it.particles.getEmitterLifetime!() < 0
				anyInfiniteEmitter = true
			else
				anyFiniteEmitter   = true
		}

		LG.origin()
		LG.setFont(fontLarge)

		if anyFiniteEmitter and anyInfiniteEmitter {
			drawGuiText("Warning: Mixing infinite and finite emitters", 0, math.HUGE, 20)
		}
		drawGuiText(messageText, messageTextTime, messageTextDuration, 20+1*(5+fontLarge.getHeight!()))
		drawGuiText(actionText,  actionTextTime,  actionTextDuration,  20+2*(5+fontLarge.getHeight!()))

		-- Dev/debug stuff.
		!if DEV {
			local visibility = 1 - (LT.getTime() - workspaceSaveTime) / 0.40
			if visibility > 0 {
				LG.setColor(1, 1, 1, .4*visibility^.5)
				LG.circle(LG.DrawMode.FILL, ww-10, 10, 4, 8)
			}

			-- LG.setColor(1, 1, 1)
			-- LG.print(format("%d", LT.getFPS()))
		}

		--[[ Mouse stuff.
		local mx, my = LM.getPosition()
		if isPositioningParticles {
			LG.setColor(1, 0, 0)
			LG.line(mx-50, my, mx+50, my)
			LG.line(mx, my-50, mx, my+50)
		}
		--]]

		LG.reset()
	}

	-- Put stuff on the screen!
	LG.clear()
	LG.setBlendMode(LG.BlendMode.ALPHA, LG.BlendAlphaMode.PREMULTIPLIED)

	if project.pixelateWorld {
		LG.draw(canvasWorld, (ww+MAIN_PANEL_WIDTH)/2,wh/2, 0, project.zoom,project.zoom, (ww-MAIN_PANEL_WIDTH)/2, wh/2)
	} else {
		LG.draw(canvasWorld, MAIN_PANEL_WIDTH,0)
	}

	LG.draw(canvasGui)

	!if DEV  LG.getStats(statsAll)

	local time = LT.getTime()
	LG.present()
	presentTime = LT.getTime()-time
}



export onResize :: (w,h:int) {
	createCanvases()
	guiState.layoutNeedsUpdate = true
	freezeDtThisFrame          = true -- Fixes things jumping forward like crazy (in Windows at least).
}



export main :: () {
	!import "utils"
	local LOVE: table : !foreign lua "love"

	LOVE.run           = wrapFunctionInGloaErrorHandler(onRun)
	LOVE.load          = wrapFunctionInGloaErrorHandler(onLoad)
	LOVE.keypressed    = wrapFunctionInGloaErrorHandler(onKeyPressed)
	LOVE.keyreleased   = wrapFunctionInGloaErrorHandler(onKeyReleased)
	LOVE.textinput     = wrapFunctionInGloaErrorHandler(onTextInput)
	LOVE.mousepressed  = wrapFunctionInGloaErrorHandler(onMousePressed)
	LOVE.mousemoved    = wrapFunctionInGloaErrorHandler(onMouseMoved)
	LOVE.mousereleased = wrapFunctionInGloaErrorHandler(onMouseReleased)
	LOVE.wheelmoved    = wrapFunctionInGloaErrorHandler(onMouseWheel)
	LOVE.update        = wrapFunctionInGloaErrorHandler(onUpdate)
	LOVE.draw          = wrapFunctionInGloaErrorHandler(onDraw)
	LOVE.resize        = wrapFunctionInGloaErrorHandler(onResize)
	LOVE.errorhandler  = nil
	LOVE.errhand       = nil
}



export setCurrentProject :: (i:int, force=false) {
	if app.currentProjectIndex == i and not force  return

	app.currentProjectIndex = i
	gui.getElement(guiState, "projects", gui.Tabs).index = i

	gui.refreshRecursively(guiState, "projectSettings")
	gui.refreshRecursively(guiState, "systems")

	scheduleRecreateCanvases = true
	updateParticleImageFilters()

	setCurrentSystem(app.projects[i].systemIndex, force=true)
}

export setCurrentSystem :: (i:int, force=true) {
	local project = app.projects[app.currentProjectIndex]
	if project.systemIndex == i and not force  return

	project.systemIndex = i
	gui.getElement(guiState, "systems", gui.Tabs).index = i

	gui.refreshRecursively(guiState, "system")
}



export scheduleSaveWorkspace :: () {
	workspaceSaveScheduled = true
	workspaceSaveDelay     = WORKSPACE_SAVE_DELAY
}



export openProject :: (path:string) -> (success:bool) {
	local dir, filename = splitDirectoryAndFilename(path)
	dir                 = normalizeDirectoryPath(dir)

	for app.projects  if it.path == path {
		setCurrentProject(itIndex)
		return true
	}

	if not connectToRemoteDirectory(dir) {
		setErrorText("Could not access folder '%s'", dir)
		return false
	}
	defer disconnectFromRemoteDirectory()

	addRecent(app.recentFolders, dir, MAX_RECENT_FOLDERS)

	local ok, gotError, _app = loadWorkspace(filename)
	if not ok {
		setErrorText("Could not load '%s'", filename)
		return false
	}

	local project = _app.projects[1]
	if project == NULL {
		setErrorText("File is missing data")
		return false
	}

	addRecent(app.recentFiles, path, MAX_RECENT_FILES)

	project.path          = path
	project.displayedName = filename
	insert(app.projects, project)

	gui.refreshRecursively(guiState, "projects")
	setCurrentProject(#app.projects)
	return true
}


