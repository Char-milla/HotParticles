--[[============================================================
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

export MAX_BUFFER_SIZE      :: 16000 -- Default buffer size for ParticleSystem is 1000.  @Incomplete: Make this configurable.
export MAIN_PANEL_WIDTH     :: 450
export DIALOG_WIDTH         :: 400
export WORKSPACE_SAVE_DELAY :: 1.00
export MAX_RECENT_FILES     :: 15
export MAX_RECENT_FOLDERS   :: 4



local isDev :: () -> bool {
	!import "utils"
	return (indexOf(getProgramArguments(), "--dev"))
}
export DEV :: !run isDev()



export !import "basic"
export !import "color"
export !import "string"
export !import "io/path"
export io     :: !import "io"
export math   :: !import "math"
export physfs :: !import "love/physfs"

export love :: !import "love"
export LD :: love.data
export LF :: love.filesystem
export LG :: love.graphics
export LI :: love.image
export LK :: love.keyboard
export LM :: love.mouse
export LT :: love.timer
local  LE :: love.event

export !self
export !load "src/misc"
export !load "src/workspace"
export gui :: !load "src/gui"
!load "src/guiSetup"

!run {
	!import "compiler"
	compile("src/conf.gloa")
}



export fontSmall:  LG.Font = NULL
export fontNormal: LG.Font = NULL
export fontLarge:  LG.Font = NULL

export imageBoxGradient: LG.Image = NULL
export imageChecker:     LG.Image = NULL
export imageGradient:    LG.Image = NULL
export imagePixel:       LG.Image = NULL
export imageRainbow:     LG.Image = NULL

export particleImageNames: []string
export particleImageDatas: struct { !key:string, !value:LF.FileData } -- FileData, not ImageData! The latter is problematic when we export textures.
export particleImages:     struct { !key:string, !value:LG.Image    }
export guiImages:          struct { !key:string, !value:LG.Image    }

local canvasGui:   LG.Canvas = NULL
local canvasWorld: LG.Canvas = NULL

local actionText          = ""
local actionTextTime      = -9999.00
local actionTextDuration :: 0.60
local messageText         = ""
local messageTextTime     = -9999.00
local messageTextDuration = 1.00

export isPositioningParticles = false

export workspaceSaveScheduled = false
export workspaceSaveDelay     = 0.00
export workspaceSaveTime      = -9999.00

export scheduleRecreateCanvases = false

local particleUpdateTime = 0.00
local particleDrawTime   = 0.00
local presentTime        = 0.00

local defaultSearchPaths: []string = NULL

export app: App
export guiState: gui.State

local freezeDtThisFrame      = false
local forcePixelatedTextures = false

local zoomTime = -9999.00



export App :: struct {
	-- Saved workspace data:

	projects: []Project,
	currentProjectIndex = 1,

	showProjectSettings = false,
	showStats           = false,
	showPanelNumbers    = true,

	recentFiles:   []string,
	recentFolders: []string,

	bookmarkedFolders: []string,
}



export Movement :: enum  { NONE::0, CIRCLE, EIGHT, IRREGULAR }

export Project :: struct {
	-- Saved:
	systems: []System,

	bgColorH  = .0,
	bgColorS  = .0,
	bgColorV  = .15,
	bgChecker = 0.0,

	pixelateWorld    = false,
	pixelateTextures = false,

	zoomLevel = 0,

	movementPreset = Movement.NONE,
	movementScaleX = 1.0,
	movementScaleY = 1.0,
	movementSpeed  = 1.0,

	path = "", -- Only save in workspace.

	exportBaseDirectory      = "",
	exportParticles          = true,
	exportParticlesOverwrite = false,
	exportParticlesPath      = "",
	exportParticlesTemplate  = "defaultLuaModule",
	exportTextures           = false,
	exportTexturesOverwrite  = false,
	exportTexturesDirectory  = "",
	exportClipboardTemplate  = "defaultLuaClipboard",

	guiLimits: struct { !key:string, !value:float },

	-- Runtime-only:
	systemIndex = 1,

	zoom       = 1.0,
	zoomSource = 1.0,
	zoomTarget = 1.0,

	displayedName = "",
	fileIsSaved   = false, -- Saved at least once (or loaded from a saved file). It's possible that the file physically don't exist (maybe deleted or moved).
	preview       = false,

	movementPhase    = 0.0,
	-- For irregular movement:
	movementPhaseAbs = 0.0,
	movementPoint1X  = 0.0,
	movementPoint1Y  = 0.0,
	movementPoint2X  = 0.0,
	movementPoint2Y  = 0.0,
	movementPoint3X  = 0.0,
	movementPoint3Y  = 0.0,
	movementPoint4X  = 0.0,
	movementPoint4Y  = 0.0,

	_init :: (project:Project) {
		static n = 0 ; n += 1
		project.displayedName = format("(untitled %d)", n)
	},

	!call :: () -> Project {
		local project: Project
		_init(project)
		return project
	},

	clone :: (source:Project) -> Project {
		local project: Project = {
			bgColorH         = source.bgColorH,
			bgColorS         = source.bgColorS,
			bgColorV         = source.bgColorV,
			bgChecker        = source.bgChecker,
			pixelateWorld    = source.pixelateWorld,
			pixelateTextures = source.pixelateTextures,
			zoomLevel        = source.zoomLevel,
			movementPreset   = source.movementPreset,
			movementScaleX   = source.movementScaleX,
			movementScaleY   = source.movementScaleY,
			movementSpeed    = source.movementSpeed,
			zoom             = source.zoom,
			zoomTarget       = source.zoomTarget,
		}
		_init(project)

		for source.systems  project.systems[itIndex] = it.clone!()

		updateParticles(project)
		return project
	},
}

export System :: struct {
	-- Saved:
	particles: LG.ParticleSystem = NULL,

	colors: []float = {0,0,1,1}, -- {h1,s1,v1,a1,...}
	blendMode = LG.BlendMode.ADD,

	texturePath = "",
	textureName = "light", -- Preset fallback to texturePath.
	offsetX = .5,
	offsetY = .5,

	frames: []AnimationFrame,

	gui: struct { !key:string, !value:string },

	-- Runtime-only:
	visible = true,

	currentImageData: LF.FileData = NULL,
	currentImage:     LG.Image    = NULL,

	!call :: () -> System {
		local system: System

		system.currentImageData = particleImageDatas.light
		system.currentImage     = particleImages    .light

		local ps = LG.newParticleSystem(system.currentImage)
		ps.start!()
		system.particles = ps

		return system
	},

	clone :: (source:System) -> System {
		local system: System = {
			particles   = source.particles.clone!(),
			colors      = {unpack(source.colors)},
			blendMode   = source.blendMode,
			texturePath = source.texturePath,
			textureName = source.textureName,
			offsetX     = source.offsetX,
			offsetY     = source.offsetY,
		}

		for source.frames {
			system.frames[itIndex] = {x=it.x, y=it.y, w=it.w, h=it.h}
		}

		for cast(table) source.gui {
			system.gui[cast(string) itIndex] = cast(string) it
		}

		return system
	},
}

export AnimationFrame :: struct { x=0.0, y=0.0, w=0.0, h=0.0 }



export updateParticles :: (project:Project) {
	for project.systems {
		updateParticleColors(it)
		updateParticleTexture(project, it)
	}
}

export updateParticleColors :: (system:System) {
	local colors = system.colors
	local colorsRgba: []float

	for i = 1, #colors, 4 {
		local r, g, b = hsvToRgb(colors[i], colors[i+1], colors[i+2])
		insert(colorsRgba, r)
		insert(colorsRgba, g)
		insert(colorsRgba, b)
		insert(colorsRgba, colors[i+3])
	}

	system.particles.setColors!(colorsRgba)
}

export updateParticleTextures :: (project:Project) {
	for project.systems  updateParticleTexture(project, it)
}

export updateParticleTexture :: (project:Project, system:System) {
	local loadParticleTexture :: (project:Project, system:System) -> LF.FileData, LG.Image {
		local ok, path, isDangling = getTextureFullPath(project, system)
		if not ok {
			if isDangling
				setErrorText("Relative paths require the project to be saved: %s", path)
			else
				setErrorText("Bad texture path '%s'", path)
			return NULL, NULL
		}

		local ^ok, dir, filename = Path(path).getDirectoryAndFilename!()
		assert(ok)

		if not connectToRemoteDirectory(dir) {
			setErrorText("Could not access folder '%s'", dir)
			return NULL, NULL
		}
		defer disconnectFromRemoteDirectory()

		local imageData, err = LF.newFileData(filename)

		if imageData == NULL {
			setErrorText(err)
			return NULL, NULL
		}

		local image = LG.newImage(filename)

		return cast(LF.FileData)imageData, image
	}

	local imageData: LF.FileData = NULL
	local image:     LG.Image    = NULL

	if system.texturePath  imageData, image = loadParticleTexture(project, system) -- @Speed: Don't reload the texture if there's no change.

	if imageData == NULL {
		imageData = particleImageDatas[system.textureName]
		image     = particleImages    [system.textureName]
	}

	system.currentImageData = imageData
	system.currentImage     = image

	system.particles.setTexture!(image)
	updateParticleAnimation(system)

	local filter = project.pixelateTextures ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR
	image.setFilter!(filter, filter)
}

export updateParticleAnimation :: (system:System) {
	if system.frames {
		local iw, ih = system.currentImage.getDimensions!()
		local quads: []LG.Quad

		for system.frames {
			insert(quads, LG.newQuad(it.x, it.y, it.w, it.h, iw, ih))
		}

		system.particles.setQuads!(quads)

	} else {
		system.particles.setQuads!()
	}
	updateParticleTextureOffset(system)
}

export updateParticleTextureOffset :: (system:System) {
	if system.frames {
		local animFrame1 = system.frames[1]
		system.particles.setOffset!(animFrame1.w*system.offsetX, animFrame1.h*system.offsetY)
	} else {
		local iw, ih = system.currentImage.getDimensions!()
		system.particles.setOffset!(iw*system.offsetX, ih*system.offsetY)
	}
}



export updateParticleImageFilters :: () {
	local project = app.projects[app.currentProjectIndex]
	local filter  = (project.pixelateTextures or forcePixelatedTextures) ? LG.FilterMode.NEAREST : LG.FilterMode.LINEAR

	for particleImageNames {
		particleImages[it].setFilter!(filter, filter)
	}

	local system = project.systems[project.systemIndex]
	system.currentImage.setFilter!(filter, filter) -- In case this is a custom texture.
}



export addNewSystem :: (project:Project, showcase=false) {
	local system = System()
	local ps     = system.particles
	insert(project.systems, system)

	if showcase {
		system.colors = {0,0,1,0, 0,0,1,1, 0,0,1,.5, 0,0,1,0}
		ps.setEmissionRate!(20)
		ps.setDirection!(-math.TAU/4)
		ps.setSpread!(.05*math.TAU)
		ps.setParticleLifetime!(1.8, 2.2)
		ps.setSpeed!(90, 100)
	} else {
		ps.setEmissionRate!(1)
		ps.setParticleLifetime!(1)
	}
	updateParticleColors(system)

	if project.systems[2] ~= NULL {
		local x, y = project.systems[1].particles.getPosition!()
		ps.setPosition!(x, y)
	}
}

export addNewProject :: () -> Project {
	local project = Project()
	insert(app.projects, project)

	addNewSystem(project, showcase=true)

	return project
}



export createCanvases :: () {
	local ww, wh = LG.getDimensions()

	if canvasGui ~= NULL {
		canvasGui  .release!()
		canvasWorld.release!()
	}

	local SETTINGS: LG.CanvasSettings : {msaa=2^2}
	canvasGui   = LG.newCanvas(ww, wh, SETTINGS)
	canvasWorld = LG.newCanvas(math.max(ww-MAIN_PANEL_WIDTH, 1), wh)

	if app.projects[app.currentProjectIndex].pixelateWorld {
		canvasWorld.setFilter!(LG.FilterMode.NEAREST, LG.FilterMode.NEAREST)
	}

	scheduleRecreateCanvases = false
}



export moveEmittersTo :: (x,y:float) {
	for app.projects[app.currentProjectIndex].systems  it.particles.moveTo!(x, y)
}



export pushQuitEvent :: () {
	saveWorkspace()
	LE.quit(0)
}



export connectToRemoteDirectory :: (dir:string) -> (success:bool) {
	if not physfs.setWriteDirectory(dir)  return false

	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it))

	assert(physfs.mountReadDirectory(dir)) -- If we can write then we should be able to read too.
	return true
}

export disconnectFromRemoteDirectory :: () {
	for physfs.getSearchPaths()  assert(physfs.unmountReadDirectory(it))
	for defaultSearchPaths       assert(physfs.mountReadDirectory(it, true))

	assert(physfs.setWriteDirectory(LF.getSaveDirectory()))
}



export setActionText :: (s:string) {
	actionText     = s
	actionTextTime = LT.getTime()
	messageText    = "" -- Good?
}
export setActionText :: (s:string, v,...:int|float|string) {
	setActionText(format(s, v, ...))
}

export setMessageText :: (s:string) {
	if messageText ~= s  print(s)

	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 3.00
}
export setMessageText :: (s:string, v,...:int|float|string) {
	setMessageText(format(s, v, ...))
}

export setErrorText :: (s:string) {
	s = "Error: "..s
	if messageText ~= s  print(s)

	messageText         = s
	messageTextTime     = LT.getTime()
	messageTextDuration = 8.00
}
export setErrorText :: (s:string, v,...:int|float|string) {
	setErrorText(format(s, v, ...))
}



export onRun :: () -> (mainLoop:()->int|none) {
	local LOVE: struct { !key:string, !value:(...:love.Variant) } : !foreign lua "love"

	local argsRaw = !import"utils".getCommandLineArguments()
	LOVE.load(love.arg.parseGameArguments(argsRaw), argsRaw)

	LT.step()
	local dt = .0

	return [dt] () -> int|none {
		LE.pump()
		for name, a,b,c,d,e,f in LE.poll() {
			if name == LE.Event.QUIT {
				-- if not (cast(()->bool)cast(any)LOVE.quit)() {
					return a == NULL ? 0 : cast(int)a
				-- }
			}
			local HANDLERS: struct { !key:LE.Event, !value:(...:love.Variant) } : !foreign lua "love.handlers"
			HANDLERS[name](a,b,c,d,e,f)
		}

		dt = LT.step()
		LOVE.update(dt)

		if LG.isActive()  LOVE.draw()

		LT.sleep(0.001)
		return nil
	}
}



export onLoad :: (args:[]string, argsRaw:[]string) {
	io.disableBuffering(io.STDOUT)
	io.disableBuffering(io.STDERR)

	print("Running Hot Particles")
	!if DEV  love.window.setTitle(love.window.getTitle().." [DEBUG]")

	LK.setKeyRepeat(true)

	defaultSearchPaths = physfs.getSearchPaths()

	LF.createDirectory("projects")

	fontSmall  = LG.newFont(10)
	fontNormal = LG.newFont(12)
	fontLarge  = LG.newFont(16)

	imageBoxGradient = LG.newImage("gfx/boxGradient.png")
	imageChecker     = LG.newImage("gfx/checker.png") ; imageChecker.setWrap!(LG.WrapMode.REPEAT, LG.WrapMode.REPEAT) ; imageChecker.setFilter!(LG.FilterMode.NEAREST, LG.FilterMode.NEAREST)
	imageGradient    = LG.newImage("gfx/gradient.png")
	imagePixel       = LG.newImage("gfx/pixel.png")
	imageRainbow     = LG.newImage("gfx/rainbow.png")

	!load "src/icons"
	generateIcons()

	for LF.getDirectoryItems"gfx/particles" {
		local found, name = matchPattern(it, "^(.+)%.png$")

		if found {
			local path      = "gfx/particles/"..it
			local imageData = LF.newFileData(path)
			local image     = LG.newImage(path)

			particleImageDatas[cast(string)name] = imageData
			particleImages    [cast(string)name] = image
			guiImages         [cast(string)name] = image

			insert(particleImageNames, cast(string)name)
		}
	}

	local ok, gotError, _app = loadWorkspace("workspace")
	if ok {
		app = _app
		assert(app.projects[1] ~= NULL)
	} else {
		if gotError  setErrorText("Could not load previous workspace")
		addNewProject()
	}

	for app.projects  updateParticles(it)

	love.window.setVSync(app.showStats ? 0 : 1)

	setupGuiFrames()
	setupGuiCallbacks()
	gui.refreshAll(guiState)

	setCurrentProject(app.currentProjectIndex, force=true)
}



export onKeyPressed :: (key:LK.KeyConstant, scancode:LK.Scancode, isRepeat:bool) {
	local mod     = getModifierKey()
	local project = app.projects[app.currentProjectIndex]

	-- Global keys.
	if not LM.isGrabbed()  if key == {
		case "q":
			if mod == {
				case ModifierKey.C: pushQuitEvent() ; return
			}

		case "f10":
			if mod == {
				case ModifierKey.C: saveWorkspace() ; LE.restart() ; return
			}

		case "f1":
			if mod == {
				case ModifierKey.NONE:
					app.showStats = not app.showStats
					love.window.setVSync(app.showStats ? 0 : 1)
					scheduleSaveWorkspace()
					return
			}

		case "f2":
			if mod == {
				case ModifierKey.NONE:
					app.showPanelNumbers = not app.showPanelNumbers
					scheduleSaveWorkspace()
					return
			}
	}

	if gui.onKeyPressed(guiState, key, scancode, isRepeat)  return
	if LM.isGrabbed()  return

	-- Context-sensitive global keys.
	if key == {
		case "escape":
			if not popPanel() {
				local BUTTONS: []gui.Button : {{label="Exit"},{label="Cancel"}}

				pushTempChoiceDialog("", "", BUTTONS, submitIndex=1, (i:int) {
					if i == 1  pushQuitEvent()
				})
			}
			return

		case "r":
			if mod == {
				case ModifierKey.NONE:
					for project.systems {
						it.particles.reset!()
						it.particles.start!()
					}
					return
			}

		case "o":
			if mod == {
				case ModifierKey.CS:
					local ok, dir = Path(app.projects[app.currentProjectIndex].path).getDirectory!()
					if ok  love.system.openURL("file://"..dir)
					return
			}
	}

	if panelStack  return

	-- Keys in normal view.
	if key == {
		case "tab":
			if mod == {
				case ModifierKey.NONE: setCurrentSystem ((project.systemIndex-0) % #project.systems + 1)
				case ModifierKey.S:    setCurrentSystem ((project.systemIndex-2) % #project.systems + 1)
				case ModifierKey.C:    setCurrentProject((app.currentProjectIndex-0) % #app.projects    + 1)
				case ModifierKey.CS:   setCurrentProject((app.currentProjectIndex-2) % #app.projects    + 1)
			}

		case "h":
			if mod == {
				case ModifierKey.NONE:
					local system   = project.systems[project.systemIndex]
					system.visible = not system.visible
			}

		case "s":
			if mod == {
				case ModifierKey.C:  if project.fileIsSaved  saveProject(project, overwrite=true)  else  pushPanel("saveProjectAs")
				case ModifierKey.CS: pushPanel("saveProjectAs")
			}

		case "e":
			if mod == {
				case ModifierKey.C: pushPanel("exportProject")
			}

		case "o":
			if mod == {
				case ModifierKey.C: pushPanel("openProject")
			}

		case "p":
			if mod == {
				case ModifierKey.NONE: gui.setActive(guiState, "main", not gui.getElement(guiState, "main").active)
			}
	}
}

export onKeyReleased :: (key:LK.KeyConstant, scancode:LK.Scancode) {
	gui.onKeyReleased(guiState, key, scancode)
}

export onTextInput :: (text:string) {
	if gui.onTextInput(guiState, text)  return
}

export onMousePressed :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch         return
	if LM.isGrabbed()  return

	if gui.onMousePressed(guiState, mx, my, mbutton, presses)  return

	local showTextureOffset, showAnimationFrames, showWorld = getVisibilityFlags()
	if not showWorld  return

	if mbutton == 1 {
		isPositioningParticles = true
		LM.setGrabbed(true)
		LK.setKeyRepeat(false)
		onMouseMoved(mx,my, 0,0, false)
	}
}

export onMouseMoved :: (mx,my:int, dx,dy:int, isTouch:bool) {
	if isTouch  return

	if isPositioningParticles {
		local project = app.projects[app.currentProjectIndex]

		local x = (mx - (LG.getWidth()+MAIN_PANEL_WIDTH)/2) / project.zoom
		local y = (my - (LG.getHeight()                )/2) / project.zoom

		moveEmittersTo(x, y)
		return
	}

	gui.onMouseMoved(guiState, mx, my, dx, dy)
}

export onMouseReleased :: (mx,my:int, mbutton:int, isTouch:bool, presses:int) {
	if isTouch  return

	if isPositioningParticles and mbutton == 1 {
		isPositioningParticles = false
		LM.setGrabbed(false)
		LK.setKeyRepeat(true)
		gui.onMouseMoved(guiState, mx, my, 0, 0)
		return
	}

	gui.onMouseReleased(guiState, mx, my, mbutton, presses)
}

export onMouseWheel :: (dx,dy:int) {
	if LM.isGrabbed()                      return
	if gui.onMouseWheel(guiState, dx, dy)  return
	if not dy                              return

	local showTextureOffset, showAnimationFrames, showWorld = getVisibilityFlags()
	if not showWorld  return

	local mx, my = LM.getPosition()
	if gui.isOverGui(guiState, mx, my)  return

	local mod = getModifierKey()
	if mod ~= ModifierKey.NONE  return

	local project   = app.projects[app.currentProjectIndex]
	local zoomLevel = project.zoomLevel
	local now       = LT.getTime()

	for 1, math.abs(dy) {
		-- Stick slightly to 100% zoom.
		if zoomLevel == 0 and now-zoomTime < 0.15  break

		zoomLevel = math.clamp(zoomLevel + math.getSign(dy), (project.pixelateWorld ? -1 : -4), 6)
	}

	zoomTime = now

	if zoomLevel == project.zoomLevel  return

	project.zoomLevel  = zoomLevel
	project.zoomSource = project.zoom
	project.zoomTarget = 2 ^ project.zoomLevel

	setActionText("Zoom: %d%%", project.zoomTarget * 100)
}



export onUpdate :: (dt:float) {
	if freezeDtThisFrame {
		dt                = 0
		freezeDtThisFrame = false
	}

	local project = app.projects[app.currentProjectIndex]

	if gui.getTopmostActiveModal(guiState) == NULL {
		local systemsActive = false

		local time = LT.getTime()
		for project.systems  it.particles.update!(dt)
		particleUpdateTime = LT.getTime()-time

		-- F for fast-forward!
		if not guiState.focusId and LK.isDown"f" and getModifierKey() == ModifierKey.NONE {
			for 2, 10 {
				for project.systems  it.particles.update!(dt)
			}
		}

		for project.systems {
			local ps         = it.particles
			local bufferSize = ps.getBufferSize!()

			systemsActive = systemsActive or ps.isActive!() or ps.getCount!() > 0

			if ps.getCount!() > bufferSize-10 and bufferSize < MAX_BUFFER_SIZE {
				ps.setBufferSize!(2*bufferSize)
				setActionText("Increased buffer size")
			}
		}

		if not systemsActive {
			for project.systems  it.particles.start!()
		}
	}

	if workspaceSaveScheduled {
		workspaceSaveDelay -= dt
		if workspaceSaveDelay <= 0  saveWorkspace()
	}

	if scheduleRecreateCanvases  createCanvases()

	if not isPositioningParticles {
		local MOVEMENT_BASE :: 250

		-- project.movementSpeed = LK.isDown"." ? .04 : 1 -- DEBUG

		local lastMovementPhaseAbs  = project.movementPhaseAbs
		project.movementPhase      +=         (project.movementSpeed) * dt
		project.movementPhaseAbs   += math.abs(project.movementSpeed) * dt

		using project.movementPreset
		if !complete project.movementPreset == {
			case NONE:
				-- void

			case CIRCLE:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE * project.movementScaleY * math.sin(angle)
				)

			case EIGHT:
				local angle = project.movementPhase*math.TAU/5.00
				moveEmittersTo(
					MOVEMENT_BASE   * project.movementScaleX * math.cos(angle),
					MOVEMENT_BASE/2 * project.movementScaleY * math.sin(angle*2)
				)

			case IRREGULAR:
				if math.floor(project.movementPhaseAbs) ~= math.floor(lastMovementPhaseAbs) or lastMovementPhaseAbs == 0 {
					local dx       = project.movementPoint3X - project.movementPoint4X
					local dy       = project.movementPoint3Y - project.movementPoint4Y
					local angleOld = math.atan(-dy, -dx)

					project.movementPoint1X = project.movementPoint4X
					project.movementPoint1Y = project.movementPoint4Y
					project.movementPoint2X = project.movementPoint4X - dx
					project.movementPoint2Y = project.movementPoint4Y - dy
					project.movementPoint4X = .8*MOVEMENT_BASE * (2*love.math.random()-1)
					project.movementPoint4Y = .8*MOVEMENT_BASE * (2*love.math.random()-1)

					dx             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					dy             = .8*MOVEMENT_BASE * (2*math.lerp(.6, 1, love.math.random())-1)
					local angleNew = math.atan(dy, dx)

					if math.angleDistance(angleNew, angleOld) > math.TAU/4 {
						dx = -dx
						dy = -dy
					}

					project.movementPoint3X = project.movementPoint4X + dx
					project.movementPoint3Y = project.movementPoint4Y + dy
				}

				local phase    = project.movementPhaseAbs % 1
				local phaseOld =     math.sin  (phase * math.TAU/4)
				local phaseNew = 1 - math.cos  (phase * math.TAU/4)
				local phaseMid = 1 - math.cos01(phase * math.TAU/2)

				moveEmittersTo(
					project.movementScaleX * math.lerp(
						math.lerp(project.movementPoint1X, project.movementPoint2X, phaseOld),
						math.lerp(project.movementPoint3X, project.movementPoint4X, phaseNew),
						phaseMid
					),
					project.movementScaleY * math.lerp(
						math.lerp(project.movementPoint1Y, project.movementPoint2Y, phaseOld),
						math.lerp(project.movementPoint3Y, project.movementPoint4Y, phaseNew),
						phaseMid
					)
				)
		}
	}

	project.zoom = math.moveTowards(
		project.zoom,
		project.zoomTarget,
		math.abs(project.zoomTarget - project.zoomSource) * dt / 0.05
	)

	gui.update(guiState, dt)
}



local getVisibilityFlags :: () -> bool, bool, bool {
	static wasHoveringTextureOffset = false
	static textureOffsetHoverTime   = -9999.00

	local isHoveringTextureOffset
		=  math.max(guiState.activeId, guiState.hoveredId) == gui.getElement(guiState, "textureOffsetX").id
		or math.max(guiState.activeId, guiState.hoveredId) == gui.getElement(guiState, "textureOffsetY").id

	if isHoveringTextureOffset ~= wasHoveringTextureOffset {
		wasHoveringTextureOffset = isHoveringTextureOffset
		textureOffsetHoverTime   = LT.getTime()
	}

	local showTextureOffset   = (isHoveringTextureOffset and LT.getTime() - textureOffsetHoverTime > 4/60)
	local showAnimationFrames = gui.getElement(guiState, "animation").active
	local showWorld           = not (showTextureOffset or showAnimationFrames)

	static didShowWorld = true

	if showWorld ~= didShowWorld {
		didShowWorld           = showWorld
		forcePixelatedTextures = not showWorld -- A bit misplaced... @Cleanup
		updateParticleImageFilters()
	}

	return showTextureOffset, showAnimationFrames, showWorld
}

export onDraw :: () {
	static statsAll:   LG.Stats
	static statsWorld: LG.Stats

	local ww, wh  = LG.getDimensions()
	local project = app.projects[app.currentProjectIndex]

	local showTextureOffset, showAnimationFrames, showWorld = getVisibilityFlags()

	LG.reset()

	-- World.
	do {
		LG.setCanvas(canvasWorld)

		local r, g, b = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
		LG.clear(r, g, b)

		if project.bgChecker {
			if project.bgChecker > 0
				LG.setColor(1, 1, 1, project.bgChecker)
			else
				LG.setColor(0, 0, 0, -project.bgChecker)
			gui.drawChecker(0, 0, ww, wh, 2)
		}

		if showWorld {
			LG.translate((ww-MAIN_PANEL_WIDTH)/2, wh/2)
			if not project.pixelateWorld  LG.scale(project.zoom)

			local time = LT.getTime()

			LG.setColor(1, 1, 1)
			for project.systems {
				if it.visible {
					LG.setBlendMode(it.blendMode)
					LG.draw(it.particles)
				}
			}

			particleDrawTime = LT.getTime()-time -- Not sure how accurate this actually is. This value is still very low even while the actual FPS is tanking a lot.
			-- !if DEV  LG.getStats(statsWorld)

			--[[ DEBUG
			LG.setColor(1, 1, 1, .15)
			LG.line(project.movementPoint1X, project.movementPoint1Y, project.movementPoint2X, project.movementPoint2Y)
			LG.line(project.movementPoint2X, project.movementPoint2Y, project.movementPoint3X, project.movementPoint3Y)
			LG.line(project.movementPoint3X, project.movementPoint3Y, project.movementPoint4X, project.movementPoint4Y)
			LG.setColor(1, 1, 1, .3)
			LG.print("1", project.movementPoint1X, project.movementPoint1Y)
			LG.print("2", project.movementPoint2X, project.movementPoint2Y)
			LG.print("3", project.movementPoint3X, project.movementPoint3Y)
			LG.print("4", project.movementPoint4X, project.movementPoint4Y)
			--]]

			LG.reset()
		}
	}

	-- GUI.
	do {
		LG.setCanvas(canvasGui)
		LG.clear()

		LG.setFont(fontNormal)

		-- Texture offset/animation frames.
		if showTextureOffset or showAnimationFrames {
			local PADDING :: 20

			local system = project.systems[project.systemIndex]
			local ps     = system.particles
			local image  = system.currentImage
			local iw, ih = image.getDimensions!()

			local scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/iw, (wh-2*PADDING)/ih)

			local x0 = (ww - iw*scale + MAIN_PANEL_WIDTH) // 2
			local y0 = (wh - ih*scale                   ) // 2

			if showTextureOffset {
				local w = iw
				local h = ih

				if system.frames {
					local quads        = ps.getQuads!()
					local quad         = getQuadForAnimationPreview(ps, quads)
					local _, _, qw, qh = quads[1].getViewport!()

					w = math.round(qw)
					h = math.round(qh)

					scale = math.min((ww-2*PADDING-MAIN_PANEL_WIDTH)/w, (wh-2*PADDING)/h)

					x0 = (ww - w*scale + MAIN_PANEL_WIDTH) // 2
					y0 = (wh - h*scale                   ) // 2

					LG.setColor(1, 1, 1)
					LG.draw(image, quad, x0, y0, 0, scale)

				} else {
					LG.setColor(1, 1, 1)
					LG.draw(image, x0, y0, 0, scale)
				}

				local HALF_WIDTH  :: 3
				local HALF_LENGTH :: 20
				local x = math.round(x0 + w*scale*system.offsetX)
				local y = math.round(y0 + h*scale*system.offsetY)
				LG.setColor(0, 0, 0, .9)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH-1, y-HALF_LENGTH-1, 2*HALF_WIDTH+2, 2*HALF_LENGTH+2)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH-1, y-HALF_WIDTH-1, 2*HALF_LENGTH+2, 2*HALF_WIDTH+2)
				LG.setColor(1, 1, 1)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_WIDTH, y-HALF_LENGTH, 2*HALF_WIDTH, 2*HALF_LENGTH)
				LG.rectangle(LG.DrawMode.FILL, x-HALF_LENGTH, y-HALF_WIDTH, 2*HALF_LENGTH, 2*HALF_WIDTH)
			}

			if showAnimationFrames {
				LG.setColor(1, 1, 1)
				LG.draw(image, x0, y0, 0, scale)

				LG.setColor(0, 1, 0)

				for system.frames {
					local x1 = math.round(x0 + scale * (it.x       ))
					local y1 = math.round(y0 + scale * (it.y       ))
					local x2 = math.round(x0 + scale * (it.x + it.w))
					local y2 = math.round(y0 + scale * (it.y + it.h))
					LG.rectangle(LG.DrawMode.LINE, x1+.5, y1+.5, x2-x1-1, y2-y1-1)
				}

				local occupiedCoords: Table(int, bool)

				for system.frames {
					local text = format("%d", itIndex)
					local x    = math.round(x0 + scale * it.x) + 2
					local y    = math.round(y0 + scale * it.y)

					while occupiedCoords[y*iw+x]  y += fontNormal.getHeight!()
					occupiedCoords[y*iw+x] = true

					LG.setColor(0, 0, 0)
					LG.print(text, x+1, y+1)
					LG.setColor(0, 1, 0)
					LG.print(text, x, y)
				}

				local mx, my = LM.getPosition()

				if love.window.hasMouseFocus() and not (guiState.activeId or gui.isOverGui(guiState, mx, my)) {
					local text = format(
						"[%d, %d]",
						math.clamp(math.floor((mx-x0)/scale), 0, iw),
						math.clamp(math.floor((my-y0)/scale), 0, ih)
					)
					local x = math.min(mx, ww-fontNormal.getWidth!(text)-2)
					local y = my+20
					if y+fontNormal.getHeight!() > wh-2  y = my-10-fontNormal.getHeight!()
					LG.setColor(0, 0, 0)
					LG.print(text, x+1, y+1)
					LG.setColor(1, 1, 1)
					LG.print(text, x, y)
				}
			}
		}

		-- Stats.
		if app.showStats {
			local particleCountTotal = 0
			for project.systems  particleCountTotal += it.particles.getCount!()

			local fontH = fontNormal.getHeight!()

			local x = MAIN_PANEL_WIDTH+5
			local y = 5

			local r, g, b          = hsvToRgb(project.bgColorH, project.bgColorS, project.bgColorV)
			local _, _, brightness = rgbToHsp(r, g, b)
			if brightness < .5
				LG.setColor(1, 1, 1, .7)
			else
				LG.setColor(0, 0, 0, .7)

			local drawStatsLine = [x,y,fontH] (pre:string, s:string, ...:int|float|string) {
				LG.print(pre, x, y)
				if s  LG.print(format(s, ...), x+fontNormal.getWidth!(pre), y)
				y += fontH+1
			}

			local _, _, windowMode = love.window.getMode()
			local ratio            = 1 / presentTime / windowMode.refreshrate

			drawStatsLine("FPS: ", "%d", LT.getFPS())

			!if DEV {
				local stats = statsAll
				if stats ~= NULL {
					drawStatsLine("drawcalls (batched): ",    "%d (%d)",  stats.drawcalls, stats.drawcallsbatched)
					drawStatsLine("switches canvas/shader: ", "%d/%d",    stats.canvasswitches, stats.shaderswitches)
					drawStatsLine("texture memory: ",         "%.2f MiB", stats.texturememory/1024^2)
					drawStatsLine("images/fonts/canvases: ",  "%d/%d/%d", stats.images, stats.fonts, stats.canvases)
				}
			}

			drawStatsLine("ParticleSystemUpdateTime: ", "%.3f ms", 1000*particleUpdateTime)
			drawStatsLine("ParticleSystemDrawTime: ",   "%.3f ms", 1000*particleDrawTime)

			if not windowMode.refreshrate {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms", 1000*presentTime)
			} elseif ratio >= 10 {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.0f.0 x framerate)", 1000*presentTime, ratio)
			} elseif ratio >= 2 {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.1f0 x framerate)",  1000*presentTime, ratio)
			} else {
				drawStatsLine("LoveGraphicsPresentTime: ", "%.3f ms (%.2f x framerate)",   1000*presentTime, ratio)
			}

			drawStatsLine("ParticleCountTotal: ", "%d", particleCountTotal)

			for project.systems  drawStatsLine("ParticleCount_", "%d: %d", itIndex, it.particles.getCount!())

			!if not DEV  drawStatsLine("(hide this with F1)", "")
		}

		-- Panel(s).
		gui.draw(guiState)

		-- GUI texts.
		local drawGuiText :: (text:string, time:float, duration:float, y:int) {
			local PADDING_X :: 15
			local PADDING_Y :: 3

			local visibility = 1 - (LT.getTime() - time) / duration
			if visibility <= 0  return

			local w = fontLarge.getWidth!(text)
			local x = (LG.getWidth() + (gui.getTopmostActiveModal(guiState) == NULL ? MAIN_PANEL_WIDTH : 0) - w) // 2
			local a = visibility ^ .5

			LG.setColor(0, 0, 0, a)
			LG.print(text, x+1, y+1)

			LG.setColor(1, 1, 1, a)
			LG.print(text, x, y)
		}

		local anyInfiniteEmitter = false
		local anyFiniteEmitter   = false

		for project.systems {
			if it.particles.getEmitterLifetime!() < 0
				anyInfiniteEmitter = true
			else
				anyFiniteEmitter   = true
		}

		LG.origin()
		LG.setFont(fontLarge)

		local dist = fontLarge.getHeight!() + 5

		if project.preview {
			drawGuiText("PREVIEW", 0, math.HUGE, 10)
		}
		if anyFiniteEmitter and anyInfiniteEmitter {
			drawGuiText("Warning: Mixing infinite and finite emitters", 0, math.HUGE, 10+1*dist)
		}
		drawGuiText(messageText, messageTextTime, messageTextDuration, 10+2*dist)
		drawGuiText(actionText,  actionTextTime,  actionTextDuration,  10+3*dist)

		-- Dev/debug stuff.
		!if DEV {
			local visibility = 1 - (LT.getTime() - workspaceSaveTime) / 0.40
			if visibility > 0 {
				LG.setColor(1, 1, 1, .4*visibility^.5)
				LG.circle(LG.DrawMode.FILL, ww-10, 10, 4, 8)
			}

			-- LG.setColor(1, 1, 1)
			-- LG.print(format("%d", LT.getFPS()))
		}

		--[[ Mouse stuff.
		local mx, my = LM.getPosition()
		if isPositioningParticles {
			LG.setColor(1, 0, 0)
			LG.line(mx-50, my, mx+50, my)
			LG.line(mx, my-50, mx, my+50)
		}
		--]]

		LG.reset()
	}

	-- Put stuff on the screen!
	LG.clear(0, 0, 0, 1)
	LG.setBlendMode(LG.BlendMode.ALPHA, LG.BlendAlphaMode.PREMULTIPLIED)

	if project.pixelateWorld {
		LG.draw(canvasWorld, (ww+MAIN_PANEL_WIDTH)/2,wh/2, 0, project.zoom,project.zoom, (ww-MAIN_PANEL_WIDTH)/2, wh/2)
	} else {
		LG.draw(canvasWorld, MAIN_PANEL_WIDTH,0)
	}

	LG.draw(canvasGui)

	!if DEV  LG.getStats(statsAll)

	local time = LT.getTime()
	LG.present()
	presentTime = LT.getTime()-time
}



export onResize :: (w,h:int) {
	createCanvases()
	guiState.layoutNeedsUpdate = true
	freezeDtThisFrame          = true -- Fixes things jumping forward like crazy (in Windows at least).
}



export main :: () {
	!import "utils"
	local LOVE: table : !foreign lua "love"

	LOVE.run           = wrapFunctionInGloaErrorHandler(onRun)
	LOVE.load          = wrapFunctionInGloaErrorHandler(onLoad)
	LOVE.keypressed    = wrapFunctionInGloaErrorHandler(onKeyPressed)
	LOVE.keyreleased   = wrapFunctionInGloaErrorHandler(onKeyReleased)
	LOVE.textinput     = wrapFunctionInGloaErrorHandler(onTextInput)
	LOVE.mousepressed  = wrapFunctionInGloaErrorHandler(onMousePressed)
	LOVE.mousemoved    = wrapFunctionInGloaErrorHandler(onMouseMoved)
	LOVE.mousereleased = wrapFunctionInGloaErrorHandler(onMouseReleased)
	LOVE.wheelmoved    = wrapFunctionInGloaErrorHandler(onMouseWheel)
	LOVE.update        = wrapFunctionInGloaErrorHandler(onUpdate)
	LOVE.draw          = wrapFunctionInGloaErrorHandler(onDraw)
	LOVE.resize        = wrapFunctionInGloaErrorHandler(onResize)
	LOVE.errorhandler  = nil
	LOVE.errhand       = nil
}



export setCurrentProject :: (i:int, force=false) {
	if app.currentProjectIndex == i and not force  return

	app.currentProjectIndex = i
	gui.getElement(guiState, "projects", gui.Tabs).index = i

	gui.refreshRecursively(guiState, "projectSettings")
	gui.refreshRecursively(guiState, "systems")

	scheduleRecreateCanvases = true
	updateParticleImageFilters()

	setCurrentSystem(app.projects[i].systemIndex, force=true)
}

export setCurrentSystem :: (i:int, force=true) {
	local project = app.projects[app.currentProjectIndex]
	if project.systemIndex == i and not force  return

	project.systemIndex = i
	gui.getElement(guiState, "systems", gui.Tabs).index = i

	gui.refreshRecursively(guiState, "system")
}



export scheduleSaveWorkspace :: () {
	workspaceSaveScheduled = true
	workspaceSaveDelay     = WORKSPACE_SAVE_DELAY
}



export openProject :: (path:string, asPreview=false) -> (success:bool, project:Project) {
	local pathObj = Path(path)

	local ok, dir, filename = pathObj.getDirectoryAndFilename!()
	if not ok {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Bad project path '%s'", path)
		return false, NULL
	}

	path = pathObj.toString!()

	for app.projects  if it.path == path {
		setCurrentProject(itIndex)
		return true, it
	}

	if not connectToRemoteDirectory(dir) {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Could not access folder '%s'", dir)
		return false, NULL
	}
	defer disconnectFromRemoteDirectory()

	addRecent(app.recentFolders, dir, MAX_RECENT_FOLDERS)

	local ^ok, gotError, _app = loadWorkspace(filename)
	if not ok {
		removeRecent(app.recentFiles, path)
		if not asPreview  setErrorText("Could not load '%s'", filename)
		return false, NULL
	}

	local project = _app.projects[1]
	if project == NULL {
		if not asPreview  setErrorText("File is missing data")
		return false, NULL
	}

	addRecent(app.recentFiles, path, MAX_RECENT_FILES)

	project.path          = path
	project.displayedName = filename
	project.fileIsSaved   = true
	project.preview       = asPreview
	insert(app.projects, project)

	updateParticles(project)

	gui.refreshRecursively(guiState, "projects")
	setCurrentProject(#app.projects)

	return true, project
}



export getGuiValue :: (system:System, name:string) -> (success:bool, value:string) {
	local value = system.gui[name]
	if value == NULL  return false, ""
	return true, value
}

export setGuiValue :: (system:System, name:string, value:string) {
	system.gui[name] = value
	scheduleSaveWorkspace()
}



export getQuadForAnimationPreview :: (ps:LG.ParticleSystem, quads:[]LG.Quad) -> (quad:LG.Quad--[[may be NULL]], progress:float) {
	local min, max = ps.getParticleLifetime!()
	local lifetime = math.max((min + max) / 2, .0001)
	local progress = (LT.getTime() / lifetime) % 1
	local i        = math.clamp(math.floor(1 + progress * #quads), 1, #quads)
	return quads[i], progress
}



export getTextureFullPath :: (project:Project, system:System) -> (success:bool, path:string, isDanglingRelativePath:bool) {
	local path = system.texturePath

	if not path {
		return true, format("%s/gfx/particles/%s.png", getAppDirectory(), system.textureName), false

	} elseif Path(path).isAbsolute {
		if not Path(path).getFilename!()  return false, "", false
		return true, path, false

	} elseif project.fileIsSaved {
		local pathObj = Path(project.path)
		pathObj.pop!() -- @Robustness: Should we check if the path empty after this?
		pathObj.append!(path)
		return true, pathObj.toString!(), false

	} else {
		return false, "", true
	}
}


