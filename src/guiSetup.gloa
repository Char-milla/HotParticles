--[[============================================================
--=
--=  GUI setup
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]

local BIG_BUTTON_HEIGHT :: 40



export setupGuiFrames :: () {
	guiState.frames = {
		guiState.frame!({ name="main", width=MAIN_PANEL_WIDTH,
			guiState.tabs!({ name="projects", specialLastTab=true }),

			guiState.buttons!({ name="saveOpenBar",
				buttons = {
					{label="Open...",    tooltip="Ctrl+O"},
					{label="Save",       tooltip="Ctrl+S"},
					{label="Save as...", tooltip="Ctrl+Shift+S"},
					{}, -- Show/hide settings.
				},
			}),

			guiState.vbox!({ name="projectSettings",
				guiState.separator!({ thick=false }),

				guiState.section!({ label="Pixelate",
					guiState.hbox!({
						guiState.checkbox!({ name="pixelateWorld",    label="world"    }),
						guiState.checkbox!({ name="pixelateTextures", label="textures" }),
					}),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ label="Background",
					guiState.hbox!({
						guiState.color!({ name="bgColor", alpha=false, weight=1 }),
						guiState.colorPreview!({ linkColors={"bgColor"} }),
					}),
					guiState.slider!({ name="bgChecker", labelLeft="checker opacity", min=-1, max=1, readoutMulti=100, readout="%d%%" }),
				}),

				guiState.separator!({ thick=false }),

				guiState.section!({ label="EmitterMovem.",
					guiState.radio!({ name="emitterMovement",
						buttons = {
							{value=Movement.NONE,      label="none",      tooltip="No movement"},
							{value=Movement.CIRCLE,    label="circle",    tooltip="Circle, or back and forth"},
							{value=Movement.EIGHT,     label="eight",     tooltip="Numeral eight"},
							{value=Movement.IRREGULAR, label="irregular", tooltip="Irregular movement"},
						}
					}),
					guiState.hbox!({
						guiState.vbox!({ weight=1,
							guiState.slider!({ name="emitterMovementSx", labelLeft="scale x", min=0, max=2, readoutMulti=100, readout="%d%%", linkMultiDrag={"emitterMovementSy"} }),
							guiState.slider!({ name="emitterMovementSy", labelLeft="scale y", min=0, max=2, readoutMulti=100, readout="%d%%", linkMultiDrag={"emitterMovementSx"} }),
						}),
						guiState.slider!({ name="emitterMovementSpeed", labelLeft="speed", inset=40, min=-8, max=8, readoutMulti=100, readout="%d%%", weight=2 }),
					}),
				}),
			}),

			guiState.separator!({ thick=true }),

			guiState.vbox!({ name="system",
				guiState.tabs!({ name="systems", specialLastTab=true }),

				guiState.scrollable!({
					guiState.section!({ label="Texture",
						guiState.radio!({ name="textureName", labelLeft="preset" }),
						guiState.inputText!({ name="texturePath", labelLeft="texture path" }),
						guiState.hbox!({
							guiState.slider!({ name="textureOffsetX", value=.5, min=0, max=1, weight=1, readoutMulti=100, readout="%d%%", labelLeft="texture offset x/y" }),
							guiState.slider!({ name="textureOffsetY", value=.5, min=0, max=1, weight=1, readoutMulti=100, readout="%d%%" }),
							guiState.buttons!({ name="util_pushPanel", data="animation", buttons={{label="Animation"}} }),
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="SpawnLayer",
						guiState.radio!({ name="insertMode",
							buttons = {
								{value=LG.ParticleInsertMode.TOP,    label="front",  tooltip="Insert at top"},
								{value=LG.ParticleInsertMode.BOTTOM, label="back",   tooltip="Insert at bottom"},
								{value=LG.ParticleInsertMode.RANDOM, label="random", tooltip="Insert randomly"},
							}
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="SpawnRate",
						guiState.slider!({ name="emissionRate", min=0, max=1024, readout="%.1f / sec" }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="Lifetime",
						guiState.slider!({ name="emitterLifetime",     labelLeft="emitter",     min=0, max=16, readout="%.2f sec", readoutZero="∞" }),
						guiState.slider!({ name="particleLifetimeMin", labelLeft="paricle min", min=0, max=16, readout="%.2f sec", linkMultiDrag={"particleLifetimeMax"} }),
						guiState.slider!({ name="particleLifetimeMax", labelLeft="paricle max", min=0, max=16, readout="%.2f sec", linkMultiDrag={"particleLifetimeMin"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ label="Area",
						guiState.radio!({ name="areaDistribution", labelLeft="distribution",
							buttons = {
								{value=LG.AreaSpreadDistribution.NONE,             label="none",    tooltip="None"},
								{value=LG.AreaSpreadDistribution.NORMAL,           label="norm",    tooltip="Normal"},
								{value=LG.AreaSpreadDistribution.ELLIPSE,          label="ellip",   tooltip="Ellipse"},
								{value=LG.AreaSpreadDistribution.UNIFORM,          label="rect",    tooltip="Rectangle (uniform)"},
								{value=LG.AreaSpreadDistribution.BORDER_ELLIPSE,   label="b.ellip", tooltip="Border ellipse"},
								{value=LG.AreaSpreadDistribution.BORDER_RECTANGLE, label="b.rect",  tooltip="Border rectangle"},
							},
						}),
						guiState.hbox!({ name="areaParams", active=false,
							guiState.direction!({ name="areaAngle", labelLeft="angle" }),
							guiState.vbox!({ weight=1,
								guiState.slider!({ name="areaDx", labelLeft="dx", inset=30, min=0, max=1000, readout="%d", linkMultiDrag={"areaDy"} }),
								guiState.slider!({ name="areaDy", labelLeft="dy", inset=30, min=0, max=1000, readout="%d", linkMultiDrag={"areaDx"} }),
								guiState.checkbox!({ name="areaRelative", label="direction relative to area center", inset=14, weight=1 }),
							}),
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="Direction",
						guiState.hbox!({
							guiState.direction!({ name="direction", linkSpread="directionSpread" }),
							guiState.slider!({ name="directionSpread", labelLeft="spread", min=0, max=math.TAU, readoutMulti=360/math.TAU, readout="%d°", weight=1, inset=50 }),
						}),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ label="Speed",
						guiState.slider!({ name="speedMin", labelLeft="min", min=-2000, max=2000, readout="%d / sec", linkMultiDrag={"speedMax"} }),
						guiState.slider!({ name="speedMax", labelLeft="max", min=-2000, max=2000, readout="%d / sec", linkMultiDrag={"speedMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="AccLinear",
						guiState.slider!({ name="accLinearXmin", labelLeft="xmin", min=-10000, max=10000, readout="%d / sec²", linkMultiDrag={"accLinearXmax"} }),
						guiState.slider!({ name="accLinearXmax", labelLeft="xmax", min=-10000, max=10000, readout="%d / sec²", linkMultiDrag={"accLinearXmin"} }),
						guiState.slider!({ name="accLinearYmin", labelLeft="ymin", min=-10000, max=10000, readout="%d / sec²", linkMultiDrag={"accLinearYmax"} }),
						guiState.slider!({ name="accLinearYmax", labelLeft="ymax", min=-10000, max=10000, readout="%d / sec²", linkMultiDrag={"accLinearYmin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="AccRadial",
						guiState.slider!({ name="radialAccelerationMin", labelLeft="min", min=-20000, max=20000, readout="%d / sec²", linkMultiDrag={"radialAccelerationMax"} }),
						guiState.slider!({ name="radialAccelerationMax", labelLeft="max", min=-20000, max=20000, readout="%d / sec²", linkMultiDrag={"radialAccelerationMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="AccTangent",
						guiState.slider!({ name="tangentialAccelerationMin", labelLeft="min", min=-20000, max=20000, readout="%d / sec²", linkMultiDrag={"tangentialAccelerationMax"} }),
						guiState.slider!({ name="tangentialAccelerationMax", labelLeft="max", min=-20000, max=20000, readout="%d / sec²", linkMultiDrag={"tangentialAccelerationMin"} }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="Damping",
						guiState.slider!({ name="linearDampingMin", labelLeft="min", min=-50, max=50, readout="%.2f", linkMultiDrag={"linearDampingMax"} }),
						guiState.slider!({ name="linearDampingMax", labelLeft="max", min=-50, max=50, readout="%.2f", linkMultiDrag={"linearDampingMin"} }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ label="Rotation",
						guiState.hbox!({
							guiState.direction!({ name="rotationMin", linkOther="rotationMax", linkMultiDrag={"rotationMax"}, labelLeft="min/max" }),
							guiState.direction!({ name="rotationMax", linkOther="rotationMin", linkMultiDrag={"rotationMin"}, }),
							guiState.checkbox!({ name="rotationRelative", label="rotation relative to direction", inset=10 }),
						}),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="Spin",
						guiState.slider!({ name="spinMin", labelLeft="at start", min=-8*math.TAU, max=8*math.TAU, readoutMulti=1/math.TAU, readout="%.2f turns / sec", linkMultiDrag={"spinMax"} }),
						guiState.slider!({ name="spinMax", labelLeft="at end",   min=-8*math.TAU, max=8*math.TAU, readoutMulti=1/math.TAU, readout="%.2f turns / sec", linkMultiDrag={"spinMin"} }),
						guiState.slider!({ name="spinVariation", labelLeft="variation", min=0, max=1, readoutMulti=100, readout="%d%%" }),
					}),

					guiState.separator!({ thick=true }),

					guiState.section!({ name="sizes", label="Size",
						guiState.hbox!({ name="sizeContainer1", data=1, labelLeft="#1",
							guiState.buttons!({ data=1, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size1", data=1, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer2", data=2, labelLeft="#2", active=false,
							guiState.buttons!({ data=2, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size2", data=2, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer3", data=3, labelLeft="#3", active=false,
							guiState.buttons!({ data=3, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size3", data=3, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer4", data=4, labelLeft="#4", active=false,
							guiState.buttons!({ data=4, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size4", data=4, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer5", data=5, labelLeft="#5", active=false,
							guiState.buttons!({ data=5, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size5", data=5, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer6", data=6, labelLeft="#6", active=false,
							guiState.buttons!({ data=6, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size6", data=6, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer7", data=7, labelLeft="#7", active=false,
							guiState.buttons!({ data=7, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size7", data=7, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.hbox!({ name="sizeContainer8", data=8, labelLeft="#8", active=false,
							guiState.buttons!({ data=8, buttons={{name="sizeRemove",image="iconDelete",tooltip="Remove size"},{name="sizeAdd",image="iconAdd",tooltip="Add/duplicate size"}} }),
							guiState.slider!({ name="size8", data=8, min=0, max=8, readout="%.2f", weight=1 }),
						}),
						guiState.slider!({ labelLeft="variation", min=0, max=1, readoutMulti=100, readout="%d%%" }),
					}),

					guiState.separator!({ thick=false }),

					guiState.section!({ label="Color",
						guiState.hbox!({
							guiState.vbox!({ name="colors", weight=1,
								guiState.hbox!({ name="colorContainer1", labelLeft="#1",
									guiState.buttons!({ data=1, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=1, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color1", data=1, weight=1, linkMultiDrag={"color2","color3","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer2", labelLeft="#2", active=false,
									guiState.buttons!({ data=2, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=2, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color2", data=2, weight=1, linkMultiDrag={"color1","color3","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer3", labelLeft="#3", active=false,
									guiState.buttons!({ data=3, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=3, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color3", data=3, weight=1, linkMultiDrag={"color1","color2","color4","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer4", labelLeft="#4", active=false,
									guiState.buttons!({ data=4, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=4, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color4", data=4, weight=1, linkMultiDrag={"color1","color2","color3","color5","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer5", labelLeft="#5", active=false,
									guiState.buttons!({ data=5, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=5, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color5", data=5, weight=1, linkMultiDrag={"color1","color2","color3","color4","color6","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer6", labelLeft="#6", active=false,
									guiState.buttons!({ data=6, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=6, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color6", data=6, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color7","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer7", labelLeft="#7", active=false,
									guiState.buttons!({ data=7, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=7, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color7", data=7, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color6","color8"} }),
								}),
								guiState.hbox!({ name="colorContainer8", labelLeft="#8", active=false,
									guiState.buttons!({ data=8, buttons={{name="colorRemove",image="iconDelete",tooltip="Remove color"},{name="colorMove",image="iconMoveV",tooltip="Move color (drag)",draggable=true}}, vertical=true }),
									guiState.buttons!({ data=8, buttons={{name="colorAdd",image="iconAdd",tooltip="Add/duplicate color"}}, vertical=true }),
									guiState.color!({ name="color8", data=8, weight=1, linkMultiDrag={"color1","color2","color3","color4","color5","color6","color7"} }),
								}),
							}),
							guiState.colorPreview!({ name="colorPreview", linkColors={"color1","color2","color3","color4","color5","color6","color7","color8"} }),
						}),
						guiState.radio!({ name="blendMode", labelLeft="blend mode",
							buttons = {
								{value=LG.BlendMode.ALPHA,    label="alpha"},
								{value=LG.BlendMode.ADD,      label="add"},
								{value=LG.BlendMode.SUBTRACT, label="subtract"},
								{value=LG.BlendMode.SCREEN,   label="screen"},
							},
						}),
					}),
				}),
			}),
		}),

		guiState.frame!({ name="saveProjectAs", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ text="Save as", large=true }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Recent", weight=1 }),
				guiState.buttons!({ name="saveProjectAs_clearRecent", buttons={{label="Clear",tooltip="Clear history"}} }),
			}),
			guiState.separator!({ thick=false }),
			guiState.buttons!({ name="saveProjectAs_recent", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Bookmarks", weight=1 }),
				guiState.buttons!({ name="saveProjectAs_addBookmark", buttons={{image="iconAdd",tooltip="Add current folder to bookmarks"}} }),
			}),
			guiState.scrollable!({ height=80,
				guiState.buttons!({ name="saveProjectAs_bookmarks", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="saveProjectAs_directory" }),
			guiState.scrollable!({
				guiState.buttons!({ name="saveProjectAs_items", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST, buttonMinHeight=16 }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="saveProjectAs_filename" }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="saveProjectAs_save",label="Save"},{name="util_popPanel",label="Cancel"}},
			}),
		}),

		guiState.frame!({ name="openProject", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ text="Open", large=true }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Recent", weight=1 }),
				guiState.buttons!({ name="openProject_clearRecent", buttons={{label="Clear",tooltip="Clear history"}} }),
			}),
			guiState.separator!({ thick=false }),
			guiState.buttons!({ name="openProject_recent", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),

			guiState.separator!({ thick=true }),
			guiState.hbox!({
				guiState.text!({ text="Bookmarks", weight=1 }),
				guiState.buttons!({ name="openProject_addBookmark", buttons={{image="iconAdd",tooltip="Add current folder to bookmarks"}} }),
			}),
			guiState.scrollable!({ height=80,
				guiState.buttons!({ name="openProject_bookmarks", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="openProject_directory" }),
			guiState.scrollable!({
				guiState.buttons!({ name="openProject_items", vertical=true, align=gui.Alignment.LEFT, style=gui.Style.LIST, buttonMinHeight=16 }),
			}),

			guiState.separator!({ thick=true }),
			guiState.inputText!({ name="openProject_filename" }),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="openProject_open",label="Open"},{name="util_popPanel",label="Cancel"}},
			}),
		}),

		guiState.frame!({ name="animation", width=MAIN_PANEL_WIDTH, active=false,
			guiState.text!({ text="Animation", large=true }),
			guiState.separator!({ thick=true }),
			guiState.buttons!({ buttons={{name="animation_empty",label="Remove all frames"}} }),
			guiState.separator!({ thick=true }),
			guiState.section!({ label="Sequence",
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_frameSize",    labelLeft="frame size", value="10 10", inset=25, weight=1.5, tooltip="Format: [width height] or [size]." }),
					guiState.inputText!({ name="animation_sequence_framePadding", labelLeft="padding",    value="0",     inset=45, weight=1,   tooltip="Padding around each frame. Format: [paddingX paddingY] or [padding]." }),
					guiState.inputText!({ name="animation_sequence_frameSpacing", labelLeft="spacing",    value="0",     inset=45, weight=1,   tooltip="Space between frames. Format: [spacingX spacingY] or [spacing]." }),
				}),
				guiState.hbox!({
					guiState.inputText!({ name="animation_sequence_areaPosition", labelLeft="area x/y",  value="0 0", inset=25, weight=1, tooltip="Format: [x y]. Non-positive means from bottom/right corner." }),
					guiState.inputText!({ name="animation_sequence_areaSize",     labelLeft="area size", value="0 0", inset=55, weight=1, tooltip="Format: [width height] or [size]. Non-positive means from bottom/right corner." }),
					guiState.buttons!({ buttons={{name="animation_sequence_generate",label="Generate"}} }),
				}),
			}),
			guiState.scrollable!({
				guiState.vbox!({ name="animation_frames", inset=25 }),
			}),
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="util_popPanel",label="Close"}},
			}),
		}),

		guiState.frame!({ name="exit", width=DIALOG_WIDTH, layout=gui.Layout.FLOATING, modal=true, active=false,
			guiState.buttons!({ height=BIG_BUTTON_HEIGHT,
				buttons = {{name="exit_exit",label="Exit"},{name="util_popPanel",label="Cancel"}},
			}),
		}),
	}
}



export panelStack: []string

export pushPanel :: (name:string) {
	assert(not indexOf(panelStack, name))
	if not gui.setActive(guiState, name, true)  return

	insert(panelStack, name)
}

export pushTempDialog :: (title:string, text:string, buttonList:[]gui.Button, cb:(choice:int)) {
	static tempN = 0 ; tempN += 1

	local name        = format("temp%d", tempN)
	local nameButtons = name.."_buttons"

	local frame: gui.Frame = guiState.frame!({ name=name, temp=true, layout=gui.Layout.FLOATING, modal=true, width=DIALOG_WIDTH, active=false,
		guiState.text!({ text=title, large=true }),
		guiState.separator!({ thick=true }),
		guiState.text!({ text=text }),
		guiState.separator!({ thick=false }),
		guiState.buttons!({ name=nameButtons, height=BIG_BUTTON_HEIGHT, buttons={ unpack(buttonList) } }),
	})
	insert(guiState.frames, frame)

	guiState.onAction[nameButtons] = [cb,nameButtons] (buttons:gui.Buttons, choice:int) {
		guiState.onAction[nameButtons]   = NULL
		guiState.onInactive[nameButtons] = NULL
		popPanel()
		cb(choice)
	}
	guiState.onInactive[name] = [cb,nameButtons] (frame:gui.Frame) {
		guiState.onAction[nameButtons]   = NULL
		guiState.onInactive[nameButtons] = NULL
		cb(0)
	}

	pushPanel(name)
}

export popPanel :: (nameForAssert="") -> (success:bool) {
	local ok, name = remove(panelStack)
	if nameForAssert  assert(name == nameForAssert)
	if not ok  return false

	local frame = gui.getElement(guiState, name, gui.Frame)
	gui.setActive(guiState, frame, false)

	if frame.temp  gui.delete(guiState, frame)
	return true
}



export setupGuiCallbacks :: () {
	--==============================================================
	--= Main/project
	--==============================================================

	-- Tabs.
	guiState.onRefresh.projects = (tabs:gui.Tabs) {
		tabs.buttons = {}

		for app.projects {
			insert(tabs.buttons, cast(gui.Button){ label=it.displayedName, tooltip=it.path, draggable=true })
		}
		insert(tabs.buttons, cast(gui.Button){ image="iconAdd", tooltip="New project" })

		tabs.index = app.currentProjectIndex
	}
	guiState.onAction.projects = (tabs:gui.Tabs, i:int) {
		if i < #tabs.buttons {
			setCurrentProject(i)
			return
		}

		local project = addNewProject()

		insert(tabs.buttons, #tabs.buttons, cast(gui.Button){ label=project.displayedName, draggable=true })
		guiState.layoutNeedsUpdate = true

		setCurrentProject(#app.projects)
	}
	guiState.onOption.projects = (tabs:gui.Tabs, projectIndex:int) {
		gui.showContextMenu(guiState, {"Close","Duplicate"}, [projectIndex] (i:int) {
			if i == {
				case 1:
					closeProject(projectIndex)

				case 2:
					local project = app.projects[projectIndex].clone!()
					insert(app.projects, projectIndex+1, project)

					gui.refreshRecursively(guiState, "projects")
					setCurrentProject(projectIndex+1, force=true)
			}
		})
	}
	guiState.onClose.projects = (tabs:gui.Tabs, i:int) {
		if i < #tabs.buttons  closeProject(i)
	}
	local closeProject :: (i:int) {
		local isCurrent = (i == app.currentProjectIndex)

		-- @UX: Confirm closing project if there are changes.
		local _, project = remove(app.projects, i)

		if project.path  addRecent(app.recentFiles, project.path, MAX_RECENT_FILES)

		if app.projects[1] == NULL
			addNewProject()
		elseif i < app.currentProjectIndex
			app.currentProjectIndex -= 1
		else
			app.currentProjectIndex = math.min(app.currentProjectIndex, #app.projects)

		gui.refreshRecursively(guiState, "projects")
		if isCurrent  setCurrentProject(app.currentProjectIndex, force=true)
	}
	guiState.onDrag.projects = (tabs:gui.Tabs, i:int, mx,my:int) {
		local targetIndex = math.clamp(math.floor(1 + (mx - tabs.layoutX) / tabs.buttonWidth), 1, #app.projects)
		if targetIndex == i  return

		local isCurrent = (i == app.currentProjectIndex)

		local _, project = remove(app.projects, i)
		local _, button  = remove(tabs.buttons, i)
		insert(app.projects, targetIndex, project)
		insert(tabs.buttons, targetIndex, button)

		if isCurrent
			app.currentProjectIndex = targetIndex
		elseif i > app.currentProjectIndex and targetIndex <= app.currentProjectIndex
			app.currentProjectIndex += 1
		elseif i < app.currentProjectIndex and targetIndex >= app.currentProjectIndex
			app.currentProjectIndex -= 1

		tabs.index = app.currentProjectIndex

		guiState.activeSubid  = targetIndex
		guiState.hoveredSubid = targetIndex
	}

	-- Menu.
	guiState.onRefresh.saveOpenBar = (buttons:gui.Buttons) {
		buttons.buttons[4].label = app.showProjectSettings ? "Hide settings" : "Show settings"
		gui.setActive(guiState, "projectSettings", app.showProjectSettings)
	}
	guiState.onAction.saveOpenBar = (buttons:gui.Buttons, i:int) {
		local project = app.projects[app.currentProjectIndex]
		if i == {
			case 1: pushPanel("openProject")
			case 2: if project.fileIsSaved  saveProject(project, overwrite=true)  else  pushPanel("saveProjectAs")
			case 3: pushPanel("saveProjectAs")

			case 4:
				app.showProjectSettings  = not app.showProjectSettings
				buttons.buttons[4].label = app.showProjectSettings ? "Hide settings" : "Show settings"
				gui.setActive(guiState, "projectSettings", app.showProjectSettings)
		}
	}
	guiState.onOption.saveOpenBar = (buttons:gui.Buttons, i:int) {
		if i ~= 1  return

		local items = {"Recent:"}

		if app.recentFiles {
			for app.recentFiles  insert(items, it)
			insert(items, "Clear history")
		} else {
			insert(items, "(no recent files)")
		}

		gui.showContextMenu(guiState, items, [items] (i:int) {
			if i <= 1 or not app.recentFiles {
				-- void
			} elseif i == #items {
				app.recentFiles = {}
			} else {
				local path = items[i]
				openProject(path)
			}
		})
	}

	-- Project settings.
	guiState.onRefresh.pixelateWorld = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.pixelateWorld
	}
	guiState.onAction.pixelateWorld = (checkbox:gui.Checkbox, i:int) {
		local project            = app.projects[app.currentProjectIndex]
		project.pixelateWorld    = checkbox.checked
		scheduleRecreateCanvases = true

		if project.pixelateWorld and project.zoomLevel < -1 {
			project.zoomLevel  = -1
			project.zoomSource = project.zoom
			project.zoomTarget = 2^project.zoomLevel
		}
	}
	guiState.onRefresh.pixelateTextures = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		checkbox.checked = project.pixelateTextures
	}
	guiState.onAction.pixelateTextures = (checkbox:gui.Checkbox, i:int) {
		local project            = app.projects[app.currentProjectIndex]
		project.pixelateTextures = checkbox.checked
		scheduleRecreateCanvases = true
		updateParticleImageFilters()

		if project.pixelateTextures and project.zoomLevel < -1 {
			project.zoomLevel  = -1
			project.zoomSource = project.zoom
			project.zoomTarget = 2^project.zoomLevel
		}
	}

	guiState.onRefresh.bgColor = (colorEl:gui.Color) {
		local project    = app.projects[app.currentProjectIndex]
		colorEl.color[1] = project.bgColorH
		colorEl.color[2] = project.bgColorS
		colorEl.color[3] = project.bgColorV
	}
	guiState.onAction.bgColor = (colorEl:gui.Color, i:int) {
		local project    = app.projects[app.currentProjectIndex]
		project.bgColorH = colorEl.color[1]
		project.bgColorS = colorEl.color[2]
		project.bgColorV = colorEl.color[3]
	}
	guiState.onRefresh.bgChecker = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.bgChecker
	}
	guiState.onAction.bgChecker = (slider:gui.Slider, i:int) {
		local project     = app.projects[app.currentProjectIndex]
		project.bgChecker = slider.value
	}

	guiState.onRefresh.emitterMovement = (radio:gui.Radio) {
		local project  = app.projects[app.currentProjectIndex]
		local found, i = indexWith(radio.buttons, "value", project.movementPreset)
		assert(found)
		radio.index = i
	}
	guiState.onAction.emitterMovement = (radio:gui.Radio, i:int) {
		local project          = app.projects[app.currentProjectIndex]
		project.movementPreset = cast(Movement) radio.buttons[i].value
	}
	guiState.onRefresh.emitterMovementSx = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.movementScaleX
	}
	guiState.onAction.emitterMovementSx = (slider:gui.Slider, i:int) {
		local project          = app.projects[app.currentProjectIndex]
		project.movementScaleX = slider.value
	}
	guiState.onRefresh.emitterMovementSy = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.movementScaleY
	}
	guiState.onAction.emitterMovementSy = (slider:gui.Slider, i:int) {
		local project          = app.projects[app.currentProjectIndex]
		project.movementScaleY = slider.value
	}
	guiState.onRefresh.emitterMovementSpeed = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		slider.value  = project.movementSpeed
	}
	guiState.onAction.emitterMovementSpeed = (slider:gui.Slider, i:int) {
		local project         = app.projects[app.currentProjectIndex]
		project.movementSpeed = slider.value
	}

	-- Systems.
	guiState.onRefresh.systems = (tabs:gui.Tabs) {
		local project = app.projects[app.currentProjectIndex]
		tabs.buttons  = {}

		for project.systems {
			insert(tabs.buttons, cast(gui.Button){ system=it, draggable=true })
		}
		insert(tabs.buttons, cast(gui.Button){ image="iconAdd", tooltip="New particle system" })

		tabs.index = project.systemIndex
	}
	guiState.onAction.systems = (tabs:gui.Tabs, i:int) {
		local project = app.projects[app.currentProjectIndex]

		if i < #tabs.buttons {
			setCurrentSystem(i)
			return
		}

		addNewSystem(project)
		gui.refreshRecursively(guiState, "systems")
		setCurrentSystem(#project.systems)
	}
	guiState.onOption.systems = (tabs:gui.Tabs, i:int) {
		if i == #tabs.buttons  return

		local project              = app.projects[app.currentProjectIndex]
		project.systems[i].visible = not project.systems[i].visible
	}
	guiState.onClose.systems = (tabs:gui.Tabs, i:int) {
		if i == #tabs.buttons  return

		local project   = app.projects[app.currentProjectIndex]
		local isCurrent = i == project.systemIndex

		-- @UX: Confirm removal of system.
		remove(project.systems, i)

		if project.systems[1] == NULL
			addNewSystem(project)
		elseif i < project.systemIndex
			project.systemIndex -= 1
		else
			project.systemIndex = math.min(project.systemIndex, #project.systems)

		gui.refreshRecursively(guiState, "systems")
		if isCurrent  setCurrentSystem(project.systemIndex, force=true)
	}
	guiState.onDrag.systems = (tabs:gui.Tabs, i:int, mx,my:int) {
		local project     = app.projects[app.currentProjectIndex]
		local targetIndex = math.clamp(math.floor(1 + (mx - tabs.layoutX) / tabs.buttonWidth), 1, #project.systems)
		if targetIndex == i  return

		local isCurrent = (i == project.systemIndex)

		local _, system = remove(project.systems, i)
		local _, button = remove(tabs.buttons, i)
		insert(project.systems, targetIndex, system)
		insert(tabs.buttons,    targetIndex, button)

		if isCurrent
			project.systemIndex = targetIndex
		elseif i > project.systemIndex and targetIndex <= project.systemIndex
			project.systemIndex += 1
		elseif i < project.systemIndex and targetIndex >= project.systemIndex
			project.systemIndex -= 1

		tabs.index = project.systemIndex

		guiState.activeSubid  = targetIndex
		guiState.hoveredSubid = targetIndex
	}

	-- Texture.
	guiState.onRefresh.textureName = (radio:gui.Radio) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		radio.buttons = {}

		for particleImageNames {
			insert(radio.buttons, cast(gui.Button){ value=it, tooltip=it, image=it })
		}

		local found, i = indexOf(particleImageNames, system.textureName)
		assert(found)
		radio.index = i
	}
	guiState.onAction.textureName = (radio:gui.Radio, i:int) {
		local project      = app.projects[app.currentProjectIndex]
		local system       = project.systems[project.systemIndex]
		system.textureName = cast(string) radio.buttons[i].value
		updateParticleTexture(project, system)
	}

	guiState.onRefresh.texturePath = (input:gui.InputText) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		input.value   = system.texturePath
	}
	guiState.onAction.texturePath = (input:gui.InputText) {
		local project      = app.projects[app.currentProjectIndex]
		local system       = project.systems[project.systemIndex]
		local path         = normalizeFilePath(trim(input.value))
		system.texturePath = path
		input.value        = path
		updateParticleTexture(project, system)
	}

	guiState.onRefresh.textureOffsetX = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		slider.value  = system.offsetX
	}
	guiState.onAction.textureOffsetX = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		system.offsetX = slider.value
		updateParticleTextureOffset(system)
	}

	guiState.onRefresh.textureOffsetY = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		slider.value  = system.offsetY
	}
	guiState.onAction.textureOffsetY = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		system.offsetY = slider.value
		updateParticleTextureOffset(system)
	}
	--

	guiState.onRefresh.insertMode = (radio:gui.Radio) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		local found, i = indexWith(radio.buttons, "value", system.particles.getInsertMode!())
		assert(found)
		radio.index = i
	}
	guiState.onAction.insertMode = (radio:gui.Radio, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		system.particles.setInsertMode!(cast(LG.ParticleInsertMode) radio.buttons[i].value)
	}

	guiState.onRefresh.emitterLifetime = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		slider.value  = math.max(system.particles.getEmitterLifetime!(), 0)
	}
	guiState.onAction.emitterLifetime = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		system.particles.setEmitterLifetime!(slider.value > 0 ? slider.value : -1.0)
		if slider.value <= 0  system.particles.start!()
	}
	guiState.onRefresh.particleLifetimeMin = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		local min, max = system.particles.getParticleLifetime!()
		slider.value   = min
	}
	guiState.onAction.particleLifetimeMin = (slider:gui.Slider, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		local min, max = system.particles.getParticleLifetime!()
		system.particles.setParticleLifetime!(slider.value, max)
	}
	guiState.onRefresh.particleLifetimeMax = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		local min, max = system.particles.getParticleLifetime!()
		slider.value   = max
	}
	guiState.onAction.particleLifetimeMax = (slider:gui.Slider, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		local min, max = system.particles.getParticleLifetime!()
		system.particles.setParticleLifetime!(min, slider.value)
	}

	guiState.onRefresh.emissionRate = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		slider.value  = system.particles.getEmissionRate!()
	}
	guiState.onAction.emissionRate = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		system.particles.setEmissionRate!(slider.value)
	}

	guiState.onRefresh.areaDistribution = (radio:gui.Radio) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local found, i = indexWith(radio.buttons, "value", (ps.getEmissionArea!()))
		assert(found)
		radio.index = i
		gui.setActive(guiState, "areaParams", i > 1)
	}
	guiState.onAction.areaDistribution = (radio:gui.Radio, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()
		distribution  = cast(LG.AreaSpreadDistribution) radio.buttons[i].value
		ps.setEmissionArea!(distribution, dx,dy, angle, relative)
		gui.setActive(guiState, "areaParams", i > 1)
		gui.refreshRecursively(guiState, "areaParams")
	}
	guiState.onRefresh.areaAngle = (direction:gui.Direction) {
		local project   = app.projects[app.currentProjectIndex]
		local ps        = project.systems[project.systemIndex].particles
		local distribution, dx,dy, angle = ps.getEmissionArea!()
		direction.angle = angle
	}
	guiState.onAction.areaAngle = (direction:gui.Direction, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()
		ps.setEmissionArea!(distribution, dx,dy, direction.angle, relative)
	}
	guiState.onRefresh.areaDx = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local distribution, dx = ps.getEmissionArea!()
		slider.value  = dx
	}
	guiState.onAction.areaDx = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()
		ps.setEmissionArea!(distribution, slider.value,dy, angle, relative)
	}
	guiState.onRefresh.areaDy = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local distribution, dx,dy = ps.getEmissionArea!()
		slider.value  = dy
	}
	guiState.onAction.areaDy = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()
		ps.setEmissionArea!(distribution, dx,slider.value, angle, relative)
	}
	guiState.onRefresh.areaRelative = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		local ps         = project.systems[project.systemIndex].particles
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()
		checkbox.checked = relative
	}
	guiState.onAction.areaRelative = (checkbox:gui.Checkbox, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local distribution, dx,dy, angle, relative = ps.getEmissionArea!()
		ps.setEmissionArea!(distribution, dx,dy, angle, checkbox.checked)
	}

	guiState.onRefresh.direction = (direction:gui.Direction) {
		local project   = app.projects[app.currentProjectIndex]
		local ps        = project.systems[project.systemIndex].particles
		direction.angle = ps.getDirection!()
	}
	guiState.onAction.direction = (direction:gui.Direction, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		ps.setDirection!(direction.angle)
	}
	guiState.onRefresh.directionSpread = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		slider.value  = ps.getSpread!()
	}
	guiState.onAction.directionSpread = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		ps.setSpread!(slider.value)
	}

	guiState.onRefresh.speedMin = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpeed!()
		slider.value   = min
	}
	guiState.onAction.speedMin = (slider:gui.Slider, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpeed!()
		ps.setSpeed!(slider.value, max)
	}
	guiState.onRefresh.speedMax = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpeed!()
		slider.value   = max
	}
	guiState.onAction.speedMax = (slider:gui.Slider, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpeed!()
		ps.setSpeed!(min, slider.value)
	}

	guiState.onRefresh.accLinearXmin = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		slider.value  = xmin
	}
	guiState.onAction.accLinearXmin = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		ps.setLinearAcceleration!(slider.value,ymin, xmax,ymax)
	}
	guiState.onRefresh.accLinearXmax = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		slider.value  = xmax
	}
	guiState.onAction.accLinearXmax = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		ps.setLinearAcceleration!(xmin,ymin, slider.value,ymax)
	}
	guiState.onRefresh.accLinearYmin = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		slider.value  = ymin
	}
	guiState.onAction.accLinearYmin = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		ps.setLinearAcceleration!(xmin,slider.value, xmax,ymax)
	}
	guiState.onRefresh.accLinearYmax = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		slider.value  = ymax
	}
	guiState.onAction.accLinearYmax = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
		ps.setLinearAcceleration!(xmin,ymin, xmax,slider.value)
	}

	guiState.onRefresh.radialAccelerationMin = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getRadialAcceleration!()
		slider.value   = min
	}
	guiState.onAction.radialAccelerationMin = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local min, max = ps.getRadialAcceleration!()
		ps.setRadialAcceleration!(slider.value, max)
	}
	guiState.onRefresh.radialAccelerationMax = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getRadialAcceleration!()
		slider.value   = max
	}
	guiState.onAction.radialAccelerationMax = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local min, max = ps.getRadialAcceleration!()
		ps.setRadialAcceleration!(min, slider.value)
	}

	guiState.onRefresh.tangentialAccelerationMin = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getTangentialAcceleration!()
		slider.value   = min
	}
	guiState.onAction.tangentialAccelerationMin = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local min, max = ps.getTangentialAcceleration!()
		ps.setTangentialAcceleration!(slider.value, max)
	}
	guiState.onRefresh.tangentialAccelerationMax = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getTangentialAcceleration!()
		slider.value   = max
	}
	guiState.onAction.tangentialAccelerationMax = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local min, max = ps.getTangentialAcceleration!()
		ps.setTangentialAcceleration!(min, slider.value)
	}

	guiState.onRefresh.linearDampingMin = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getLinearDamping!()
		slider.value   = min
	}
	guiState.onAction.linearDampingMin = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local min, max = ps.getLinearDamping!()
		ps.setLinearDamping!(slider.value, max)
	}
	guiState.onRefresh.linearDampingMax = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getLinearDamping!()
		slider.value   = max
	}
	guiState.onAction.linearDampingMax = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local min, max = ps.getLinearDamping!()
		ps.setLinearDamping!(min, slider.value)
	}

	guiState.onRefresh.rotationMin = (direction:gui.Direction) {
		local project   = app.projects[app.currentProjectIndex]
		local ps        = project.systems[project.systemIndex].particles
		local min, max  = ps.getRotation!()
		direction.angle = min
	}
	guiState.onAction.rotationMin = (direction:gui.Direction, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getRotation!()
		ps.setRotation!(direction.angle, max)
	}
	guiState.onRefresh.rotationMax = (direction:gui.Direction) {
		local project   = app.projects[app.currentProjectIndex]
		local ps        = project.systems[project.systemIndex].particles
		local min, max  = ps.getRotation!()
		direction.angle = max
	}
	guiState.onAction.rotationMax = (direction:gui.Direction, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getRotation!()
		ps.setRotation!(min, direction.angle)
	}
	guiState.onRefresh.rotationRelative = (checkbox:gui.Checkbox) {
		local project    = app.projects[app.currentProjectIndex]
		local ps         = project.systems[project.systemIndex].particles
		checkbox.checked = ps.hasRelativeRotation!()
	}
	guiState.onAction.rotationRelative = (checkbox:gui.Checkbox, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		ps.setRelativeRotation!(checkbox.checked)
	}

	guiState.onRefresh.spinMin = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpin!()
		slider.value   = min
	}
	guiState.onAction.spinMin = (slider:gui.Slider, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpin!()
		ps.setSpin!(slider.value, max)
	}
	guiState.onRefresh.spinMax = (slider:gui.Slider) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpin!()
		slider.value   = max
	}
	guiState.onAction.spinMax = (slider:gui.Slider, i:int) {
		local project  = app.projects[app.currentProjectIndex]
		local ps       = project.systems[project.systemIndex].particles
		local min, max = ps.getSpin!()
		ps.setSpin!(min, slider.value)
	}
	guiState.onRefresh.spinVariation = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		slider.value  = ps.getSpinVariation!()
	}
	guiState.onAction.spinVariation = (slider:gui.Slider, i:int) {
		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		ps.setSpinVariation!(slider.value)
	}

	guiState.onRefresh.sizes = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		local sizes   = {system.particles.getSizesAsVararg!()}
		for 1, 8 {
			gui.setActive(guiState, format("sizeContainer%d", it), (sizes[it] ~= NULL))
		}
	}
	guiState.onAction.sizeAdd = (buttons:gui.Buttons, i:int) {
		i = cast(int) buttons.data

		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local sizes   = {ps.getSizesAsVararg!()}

		if sizes[8] ~= NULL {
			setErrorText("Max 8 sizes")
			return
		}

		insert(sizes, i, sizes[i])
		ps.setSizes!(sizes)

		for j = i, #sizes {
			local name = format("sizeContainer%d", j)
			gui.setActive(guiState, name, true)
			gui.refreshRecursively(guiState, name)
		}
	}
	guiState.onAction.sizeRemove = (buttons:gui.Buttons, i:int) {
		i = cast(int) buttons.data

		local project = app.projects[app.currentProjectIndex]
		local ps      = project.systems[project.systemIndex].particles
		local sizes   = {ps.getSizesAsVararg!()}

		if sizes[2] == NULL {
			sizes[1] = 1
		} else {
			gui.setActive(guiState, format("sizeContainer%d", #sizes), false)
			remove(sizes, i)
		}

		ps.setSizes!(sizes)

		for j = i, #sizes {
			gui.refreshRecursively(guiState, format("sizeContainer%d", j))
		}
	}
	for i = 1, 8 {
		guiState.onRefresh[format("size%d", i)] = (slider:gui.Slider) {
			local project = app.projects[app.currentProjectIndex]
			local system  = project.systems[project.systemIndex]
			local sizes   = {system.particles.getSizesAsVararg!()}
			slider.value  = sizes[cast(int)slider.data]
		}
		guiState.onAction[format("size%d", i)] = (slider:gui.Slider, i:int) {
			local project = app.projects[app.currentProjectIndex]
			local system  = project.systems[project.systemIndex]
			local sizes   = {system.particles.getSizesAsVararg!()}
			sizes[cast(int)slider.data] = slider.value
			system.particles.setSizes!(sizes)
		}
	}

	guiState.onRefresh.colors = (slider:gui.Slider) {
		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		local colors  = system.colors
		for 1, 8 {
			gui.setActive(guiState, format("colorContainer%d", it), (colors[it*4] ~= NULL))
		}
	}
	guiState.onAction.colorAdd = (buttons:gui.Buttons, i:int) {
		i = cast(int) buttons.data

		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		local colors  = system.colors

		if colors[8*4] ~= NULL {
			setErrorText("Max 8 colors")
			return
		}

		local i1 = i*4 - 3
		local h  = colors[i1  ]
		local s  = colors[i1+1]
		local v  = colors[i1+2]
		local a  = colors[i1+3]

		insert(colors, i1,   h)
		insert(colors, i1+1, s)
		insert(colors, i1+2, v)
		insert(colors, i1+3, a)

		updateParticleColors(system)

		for j = i, #colors//4 {
			local name = format("colorContainer%d", j)
			gui.setActive(guiState, name, true)
			gui.refreshRecursively(guiState, name)
		}
	}
	guiState.onAction.colorRemove = (buttons:gui.Buttons, i:int) {
		i = cast(int) buttons.data

		local project = app.projects[app.currentProjectIndex]
		local system  = project.systems[project.systemIndex]
		local colors  = system.colors

		if colors[4+1] == NULL {
			colors[1] = 0
			colors[2] = 0
			colors[3] = 1
			colors[4] = 1

		} else {
			gui.setActive(guiState, format("colorContainer%d", #colors//4), false)

			local i1 = i*4 - 3
			remove(colors, i1+3)
			remove(colors, i1+2)
			remove(colors, i1+1)
			remove(colors, i1  )
		}

		updateParticleColors(system)

		for j = i, #colors//4 {
			gui.refreshRecursively(guiState, format("colorContainer%d", j))
		}
	}
	guiState.onDrag.colorMove = (buttons:gui.Buttons, i:int, mx,my:int) {
		i = cast(int) buttons.data

		local colorDragContainer = gui.getElement(guiState, "colors", gui.Vbox)

		local project     = app.projects[app.currentProjectIndex]
		local system      = project.systems[project.systemIndex]
		local colors      = system.colors
		local targetIndex = math.clamp(math.floor(1 + (my - (colorDragContainer.layoutY + gui.getScrollOffset(colorDragContainer))) / colorDragContainer[1].layoutHeight), 1, #colors//4)
		if targetIndex == i  return

		local dir = math.getSign(targetIndex-i)

		for j = i, targetIndex-dir, dir {
			colors[j*4-3], colors[(j+dir)*4-3] = colors[(j+dir)*4-3], colors[j*4-3]
			colors[j*4-2], colors[(j+dir)*4-2] = colors[(j+dir)*4-2], colors[j*4-2]
			colors[j*4-1], colors[(j+dir)*4-1] = colors[(j+dir)*4-1], colors[j*4-1]
			colors[j*4  ], colors[(j+dir)*4  ] = colors[(j+dir)*4  ], colors[j*4  ]
		}

		updateParticleColors(system)

		guiState.activeId  = colorDragContainer[targetIndex][1].id -- @Volatile
		guiState.hoveredId = guiState.activeId

		gui.refreshRecursively(guiState, colorDragContainer)
	}
	for i = 1, 8 {
		guiState.onRefresh[format("color%d", i)] = (colorEl:gui.Color) {
			local project    = app.projects[app.currentProjectIndex]
			local system     = project.systems[project.systemIndex]
			local colors     = system.colors
			local i1         = (4 * cast(int) colorEl.data) - 3
			colorEl.color[1] = colors[i1+0]
			colorEl.color[2] = colors[i1+1]
			colorEl.color[3] = colors[i1+2]
			colorEl.color[4] = colors[i1+3]
		}
		guiState.onAction[format("color%d", i)] = (colorEl:gui.Color, i:int) {
			local project  = app.projects[app.currentProjectIndex]
			local system   = project.systems[project.systemIndex]
			local colors   = system.colors
			local i1       = (4 * cast(int) colorEl.data) - 3
			colors[i1+i-1] = colorEl.color[i]
			updateParticleColors(system)
		}
	}

	guiState.onRefresh.colorPreview = (preview:gui.ColorPreview) {
		local project     = app.projects[app.currentProjectIndex]
		local system      = project.systems[project.systemIndex]
		preview.blendMode = system.blendMode
	}

	guiState.onRefresh.blendMode = (radio:gui.Radio) {
		local project  = app.projects[app.currentProjectIndex]
		local system   = project.systems[project.systemIndex]
		local found, i = indexWith(radio.buttons, "value", system.blendMode)
		assert(found)
		radio.index = i
	}
	guiState.onAction.blendMode = (radio:gui.Radio, i:int) {
		local project    = app.projects[app.currentProjectIndex]
		local system     = project.systems[project.systemIndex]
		local blendMode  = cast(LG.BlendMode) radio.buttons[i].value
		system.blendMode = blendMode
		gui.getElement(guiState, "colorPreview", gui.ColorPreview).blendMode = blendMode
	}

	--==============================================================
	--= Save/open project
	--==============================================================
	do {
		local Item :: struct { isDir=false, name="" }
		static dirCurrent:  string = NULL
		static dirFallback: string = NULL

		static lastProjectBeforeTemp: Project = NULL

		local loadPreview :: (path:string) {
			local lastIndex = app.currentProjectIndex

			local ok, project = openProject(path, asPreview=true)
			if not ok  return

			if lastProjectBeforeTemp == NULL {
				lastProjectBeforeTemp = app.projects[lastIndex]
			}
		}

		local unloadPreview :: () {
			local currentProject = app.projects[app.currentProjectIndex]

			for < app.projects  if it.preview {
				remove(app.projects, itIndex)
			}

			local ok, i = indexOf(app.projects, (currentProject.preview ? lastProjectBeforeTemp : currentProject))
			assert(ok)
			gui.refreshRecursively(guiState, "projects")
			setCurrentProject(i, force=true)

			lastProjectBeforeTemp = NULL
			scheduleSaveWorkspace()
		}

		guiState.onActive.saveProjectAs = (frame:gui.Frame) {
			local isSave            = (frame.name == "saveProjectAs")
			local project           = app.projects[app.currentProjectIndex]
			local path              = project.path
			local ok, dir, filename = matchPattern(path, "^(.+)/([^/]+)$")

			if not ok {
				dir      = LF.getSaveDirectory().."/projects"
				filename = "untitled.hotparticles"
			}

			if not isSave  filename = ""

			dirCurrent  = cast(string) dir
			dirFallback = LF.getSaveDirectory()

			local filenameInput = gui.getElement(guiState, (isSave ? "saveProjectAs_filename" : "openProject_filename"), gui.InputText)
			filenameInput.value = cast(string) filename

			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_bookmarks" : "openProject_bookmarks"))
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_recent"    : "openProject_recent"))
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items"     : "openProject_items"))
			gui.setFocus(guiState, filenameInput)
			filenameInput.field.selectAll!()
			-- filenameInput.field.setSelection!(0, utf8.len(basename)) -- @UX
		}
		guiState.onActive.openProject = guiState.onActive.saveProjectAs

		guiState.onInactive.saveProjectAs = (frame:gui.Frame) {
			unloadPreview()
		}
		guiState.onInactive.openProject = guiState.onInactive.saveProjectAs

		-- Bookmarks.
		guiState.onRefresh.saveProjectAs_bookmarks = (buttons:gui.Buttons) {
			buttons.buttons = {}
			for app.bookmarkedFolders {
				insert(buttons.buttons, cast(gui.Button){ value=it, label=it, image="iconFolder" })
			}
		}
		guiState.onRefresh.openProject_bookmarks = guiState.onRefresh.saveProjectAs_bookmarks

		guiState.onAction.saveProjectAs_bookmarks = (buttons:gui.Buttons, i:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			dirCurrent   = app.bookmarkedFolders[i]
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))
		}
		guiState.onAction.openProject_bookmarks = guiState.onAction.saveProjectAs_bookmarks

		guiState.onOption.saveProjectAs_bookmarks = (buttons:gui.Buttons, indexToRemove:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")

			gui.showContextMenu(guiState, {"Remove bookmark"}, [indexToRemove,isSave] (i:int) {
				if i == {
					case 1:
						remove(app.bookmarkedFolders, indexToRemove)
						gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_bookmarks" : "openProject_bookmarks"))
				}
			})
		}
		guiState.onOption.openProject_bookmarks = guiState.onOption.saveProjectAs_bookmarks

		guiState.onAction.saveProjectAs_addBookmark = (buttons:gui.Buttons, i:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")

			if insertIfUnique(app.bookmarkedFolders, dirCurrent) {
				sort(app.bookmarkedFolders)
				gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_bookmarks" : "openProject_bookmarks"))
			}
		}
		guiState.onAction.openProject_addBookmark = guiState.onAction.saveProjectAs_addBookmark

		-- Recent.
		guiState.onRefresh.saveProjectAs_recent = (buttons:gui.Buttons) {
			buttons.buttons = {}
			for app.recentFolders {
				insert(buttons.buttons, cast(gui.Button){ value=it, label=it, image="iconFolder" })
			}
		}
		guiState.onRefresh.openProject_recent = guiState.onRefresh.saveProjectAs_recent

		guiState.onAction.saveProjectAs_recent = (buttons:gui.Buttons, i:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			dirCurrent   = app.recentFolders[i]
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))
		}
		guiState.onAction.openProject_recent = guiState.onAction.saveProjectAs_recent

		guiState.onAction.saveProjectAs_clearRecent = (buttons:gui.Buttons, i:int) {
			local isSave      = (buttons.frame.name == "saveProjectAs")
			app.recentFolders = {}
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_recent" : "openProject_recent"))
		}
		guiState.onAction.openProject_clearRecent = guiState.onAction.saveProjectAs_clearRecent

		-- Directory.
		guiState.onRefresh.saveProjectAs_directory = (input:gui.InputText, i:int) {
			input.value = dirCurrent
		}
		guiState.onRefresh.openProject_directory = guiState.onRefresh.saveProjectAs_directory

		guiState.onSubmit.saveProjectAs_directory = (input:gui.InputText, i:int) {
			local isSave = (input.frame.name == "saveProjectAs")
			dirCurrent   = input.value
			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))
		}
		guiState.onSubmit.openProject_directory = guiState.onSubmit.saveProjectAs_directory

		-- Directory items.
		guiState.onRefresh.saveProjectAs_items = (buttons:gui.Buttons) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			local dir    = dirCurrent

			if not connectToRemoteDirectory(dir) {
				dir = dirFallback
				if not connectToRemoteDirectory(dir) {
					dir = LF.getSaveDirectory().."/projects"
					if not connectToRemoteDirectory(dir) {
						dir = LF.getSaveDirectory()
						if not connectToRemoteDirectory(dir) {
							dir = LF.getWorkingDirectory()
							assert(connectToRemoteDirectory(dir))
						}
					}
				}
			}
			defer disconnectFromRemoteDirectory()
			dirCurrent  = dir
			dirFallback = dir -- Last successfully connected directory.

			local dirs:      []string
			local filenames: []string

			for LF.getDirectoryItems("") {
				static info: LF.FileInfo

				if LF.getInfo(it, info) == nil {
					-- void  The file may be a system file or something.
				} elseif info.type == LF.FileType.DIRECTORY {
					if not findPattern(it, "^%$")  insert(dirs, it)
				} elseif info.type == LF.FileType.FILE {
					if findPattern(it, "%.hotparticles$")  insert(filenames, it)
				}
			}

			sort(dirs,      compareFilenames)
			sort(filenames, compareFilenames)

			buttons.buttons = {}
			insert(buttons.buttons, cast(gui.Button){ value=cast(Item){isDir=true,name=".."}, label="..", image="iconFolder" })

			for dirs {
				insert(buttons.buttons, cast(gui.Button){
					value = cast(Item) {isDir=true, name=it},
					label = it,
					image = "iconFolder",
				})
			}
			for filenames {
				local basename, ext = splitBasenameAndExtension(it, keepDot=true)
				insert(buttons.buttons, cast(gui.Button){
					value  = cast(Item) {isDir=false, name=it},
					label  = basename,
					suffix = ext,
				})
			}

			gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_directory" : "openProject_directory"))
		}
		guiState.onRefresh.openProject_items = guiState.onRefresh.saveProjectAs_items

		guiState.onAction.saveProjectAs_items = (buttons:gui.Buttons, i:int) {
			local isSave = (buttons.frame.name == "saveProjectAs")
			local item   = cast(Item) buttons.buttons[i].value

			if not item.isDir {
				gui.getElement(guiState, (isSave ? "saveProjectAs_filename" : "openProject_filename"), gui.InputText).value = item.name
				loadPreview(dirCurrent.."/"..item.name)
			} elseif item.name == ".." {
				dirCurrent = replacePattern(dirCurrent, "/[^/]+$", "")
				gui.refreshRecursively(guiState, (isSave ? "saveProjectAs_items" : "openProject_items"))
			} else {
				dirCurrent = dirCurrent.."/"..item.name
				gui.refreshRecursively(guiState, buttons)
			}
		}
		guiState.onAction.openProject_items = guiState.onAction.saveProjectAs_items

		-- Save.
		guiState.onDouble.saveProjectAs_items    = (buttons:gui.Buttons, i:int) { if not (cast(Item) buttons.buttons[i].value).isDir  save() }
		guiState.onSubmit.saveProjectAs_filename = (input:gui.InputText)        { save() }
		guiState.onAction.saveProjectAs_save     = (buttons:gui.Buttons, i:int) { save() }
		local save :: () {
			local input    = gui.getElement(guiState, "saveProjectAs_filename", gui.InputText)
			local filename = input.value
			filename       = normalizeFilePath(trim(filename))

			if filename == "" {
				input.value = filename
				gui.setFocus(guiState, input)
				return
			}

			if not findPattern(filename, "%.hotparticles$") {
				filename    = filename..".hotparticles"
				input.value = filename
			}

			local project = app.projects[app.currentProjectIndex]
			project.path  = dirCurrent.."/"..filename

			local ok, fileExists = saveProject(project)
			if ok {
				popPanel()

			} elseif fileExists {
				local BUTTONS: []gui.Button = {{label="Overwrite"},{label="Cancel"}}

				pushTempDialog("Confirm save as", filename.." already exists. Overwite it?", BUTTONS, (i:int) {
					if i ~= 1  return

					local project = app.projects[app.currentProjectIndex]
					saveProject(project, overwrite=true)
					popPanel("saveProjectAs")
				})

			} else {
				-- void  Stay in the dialog.
			}
		}

		-- Open.
		guiState.onDouble.openProject_items    = (buttons:gui.Buttons, i:int) { if not (cast(Item) buttons.buttons[i].value).isDir  open() }
		guiState.onSubmit.openProject_filename = (input:gui.InputText)        { open() }
		guiState.onAction.openProject_open     = (buttons:gui.Buttons, i:int) { open() }
		local open :: () {
			local input    = gui.getElement(guiState, "openProject_filename", gui.InputText)
			local filename = input.value
			filename       = normalizeFilePath(trim(filename))

			if filename == "" {
				input.value = filename
				gui.setFocus(guiState, input)
				return
			}

			local path = dirCurrent.."/"..filename
			local ok, project = openProject(path)
			if ok {
				project.preview = false -- In case the project was already opened as a preview (which it probably always is).
				popPanel()
			}
		}
	}

	--==============================================================
	--= Animation
	--==============================================================
	do {
		local PARAMS :: {
			"animation_sequence_frameSize",
			"animation_sequence_framePadding",
			"animation_sequence_frameSpacing",
			"animation_sequence_areaPosition",
			"animation_sequence_areaSize",
		}

		guiState.onActive.animation = (vbox:gui.Vbox) {
			local project = app.projects[app.currentProjectIndex]
			local system  = project.systems[project.systemIndex]

			for PARAMS {
				local input     = gui.getElement(guiState, it, gui.InputText)
				local ok, value = getGuiValue(system, it)
				if ok  input.value = value
			}

			gui.refreshRecursively(guiState, "animation_frames")
		}

		guiState.onAction.animation_empty = (buttons:gui.Buttons, buttonIndex:int) {
			local project = app.projects[app.currentProjectIndex]
			local system  = project.systems[project.systemIndex]
			system.frames = {}
			gui.refreshRecursively(guiState, "animation_frames")
			updateParticleAnimation(system)
		}

		local parseTwoInts :: (s:string) -> bool, int, int {
			s = trim(s)

			local ok, xStr, yStr = matchPattern(s, "^(%-?%d+) +(%-?%d+)$")
			if not ok  return false, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)

			return true, x, y
		}

		local parseFourInts :: (s:string) -> bool, int, int, int, int {
			s = trim(s)

			local ok, xStr, yStr, zStr, wStr = matchPattern(s, "^(%-?%d+) +(%-?%d+) +(%-?%d+) +(%-?%d+)$")
			if not ok  return false, 0, 0, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)
			local _, z = stringToInt(cast(string) zStr)
			local _, w = stringToInt(cast(string) wStr)

			return true, x, y, z, w
		}

		local parseOneOrTwoInts :: (s:string) -> bool, int, int {
			s = trim(s)

			local        ok, xStr, yStr = matchPattern(s, "^(%-?%d+) +(%-?%d+)$")
			if not ok  { ok, xStr       = matchPattern(s, "^%-?%d+$") ; yStr = xStr }
			if not ok  return false, 0, 0

			local _, x = stringToInt(cast(string) xStr)
			local _, y = stringToInt(cast(string) yStr)

			return true, x, y
		}

		guiState.onAction.animation_sequence_generate = (buttons:gui.Buttons, buttonIndex:int) {
			local project = app.projects[app.currentProjectIndex]
			local system  = project.systems[project.systemIndex]
			local image   = cast(LG.Image) system.particles.getTexture!()
			local iw, ih  = image.getDimensions!()

			local frameSizeStr = trim(gui.getElement(guiState, "animation_sequence_frameSize",    gui.InputText).value)
			local paddingStr   = trim(gui.getElement(guiState, "animation_sequence_framePadding", gui.InputText).value)
			local spacingStr   = trim(gui.getElement(guiState, "animation_sequence_frameSpacing", gui.InputText).value)
			local areaPosStr   = trim(gui.getElement(guiState, "animation_sequence_areaPosition", gui.InputText).value)
			local areaSizeStr  = trim(gui.getElement(guiState, "animation_sequence_areaSize",     gui.InputText).value)

			local ok, frameW, frameH = parseOneOrTwoInts(frameSizeStr)
			if not ok                          { setErrorText("Invalid frame size format") ; return }
			if not (frameW > 0 and frameH > 0) { setErrorText("Frame size must be positive") ; return }

			local ^ok, padX, padY = parseOneOrTwoInts(paddingStr)
			if not ok { setErrorText("Invalid padding format") ; return }

			local ^ok, spacingX, spacingY = parseOneOrTwoInts(spacingStr)
			if not ok { setErrorText("Invalid spacing format") ; return }

			local ^ok, areaX, areaY = parseTwoInts(areaPosStr)
			if not ok { setErrorText("Invalid area position format") ; return }
			if areaX < 0  areaX += iw
			if areaY < 0  areaY += ih

			local ^ok, areaW, areaH = parseOneOrTwoInts(areaSizeStr)
			if not ok { setErrorText("Invalid area size format") ; return }
			if areaW <= 0  areaW += iw-areaX
			if areaH <= 0  areaH += ih-areaY

			local paddedW = frameW + 2*padX
			local paddedH = frameH + 2*padY
			local cols    = (areaW + spacingX) // (paddedW + spacingX)
			local rows    = (areaH + spacingY) // (paddedH + spacingY)

			local frameCount = cols * rows
			if frameCount < 1 { setErrorText("Animation frame count is zero") ; return }

			setMessageText("")
			system.frames = {}

			for row = 1, rows {
				for col = 1, cols {
					local x = areaX + (col-1) * (paddedW + spacingX) + padX
					local y = areaY + (row-1) * (paddedH + spacingY) + padY

					local animFrame: AnimationFrame = {x=x, y=y, w=frameW, h=frameH}
					insert(system.frames, animFrame)
				}
			}

			for PARAMS {
				local input = gui.getElement(guiState, it, gui.InputText)
				setGuiValue(system, it, input.value)
			}

			updateParticleAnimation(system)
			gui.refreshRecursively(guiState, "animation_frames")
		}

		guiState.onRefresh.animation_frames = (vbox:gui.Vbox) {
			local project = app.projects[app.currentProjectIndex]
			local system  = project.systems[project.systemIndex]

			for < vbox  gui.delete(guiState, it)

			for system.frames {
				local inputValue = format("%s %s %s %s", it.x, it.y, it.w, it.h)

				insert(vbox, guiState.hbox!({ name="animation_frame", data=itIndex, labelLeft=format("#%d", itIndex),
					guiState.buttons!({ buttons={
						{name="animation_delete", image="iconDelete", tooltip="Remove frame"},
						{name="animation_add",    image="iconAdd",    tooltip="Add/duplicate frame"},
						-- {name="animation_move",   image="iconMoveV",  tooltip="Move frame (drag)", draggable=true},
					} }),
					guiState.inputText!({ name="animation_xywh", weight=1, value=inputValue, tooltip="Format: [x y width height]" }),
					guiState.text!({ name="animation_message", width=50 }),
				}))
			}
		}

		local getAnimationFrame :: (el:gui.Element) -> AnimationFrame, int {
			local project = app.projects[app.currentProjectIndex]
			local system  = project.systems[project.systemIndex]

			local _, parent = gui.findParent(guiState, el, "animation_frame")
			local i         = cast(int) parent.data

			return system.frames[i], i
		}

		guiState.onAction.animation_delete = (buttons:gui.Buttons, buttonIndex:int) {
			local animFrame, i = getAnimationFrame(buttons)
			-- @Incomplete
		}
		guiState.onAction.animation_add = (buttons:gui.Buttons, buttonIndex:int) {
			local animFrame, i = getAnimationFrame(buttons)
			-- @Incomplete
		}
		guiState.onAction.animation_xywh = (buttons:gui.Buttons, buttonIndex:int) {
			local animFrame, i = getAnimationFrame(buttons)
			-- @Incomplete
		}
		-- guiState.onDrag.animation_move = (buttons:gui.Buttons, buttonIndex:int, mx,my:int) {
		-- 	local animFrame, i = getAnimationFrame(buttons)
		-- 	-- @Incomplete
		-- }
	}

	--==============================================================
	--= Exit
	--==============================================================

	guiState.onAction.exit_exit = (buttons:gui.Buttons, i:int) {
		pushQuitEvent()
	}

	--==============================================================
	--= Utils
	--==============================================================

	guiState.onAction.util_pushPanel = (el:gui.Element, i:int) {
		pushPanel(cast(string) el.data)
	}
	guiState.onAction.util_popPanel = (el:gui.Element, i:int) {
		popPanel()
	}
}


