--[[============================================================
--=
--=  Workspace loading and saving
--=
--=-------------------------------------------------------------
--=
--=  Hot Particles - a particle editor for LÖVE
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	loadWorkspace
	saveWorkspace, saveProject

--============================================================]]

local LAST_FILE_VERSION :: 2



local writeValue :: (buffer:[]string, v:int, eol=false) {
	insert(buffer, format(" %d", v))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, v:float, eol=false) {
	insert(buffer, " ")
	insert(buffer, toString(v))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, v:string, eol=false) {
	v = replace(v, "\\", "\\\\")
	v = replace(v, "\n", "\\n")
	insert(buffer, format(" %d %s", #v, v))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, v:bool, eol=false) {
	insert(buffer, (v ? " true" : " false"))
	if eol  insert(buffer, "\n")
}
local writeValue :: (buffer:[]string, arr:[]$T, eol=false) {
	for arr  writeValue(buffer, it)
	if eol  insert(buffer, "\n")
}

local writeValues :: (buffer:[]string, v1,v2:$T, eol=false) {
	writeValue(buffer, v1, eol=false)
	writeValue(buffer, v2, eol=eol)
}

local writeProject :: (buffer:[]string, project:Project, writePath:bool) {
	insert(buffer, ":project\n")

	if writePath and project.path {
		insert(buffer, "path") ; writeValue(buffer, eol=true, project.path)
	}

	insert(buffer, "bgColor")          ; writeValue(buffer, eol=true, {project.bgColorH, project.bgColorS, project.bgColorV})
	insert(buffer, "bgChecker")        ; writeValue(buffer, eol=true, project.bgChecker)
	insert(buffer, "pixelateWorld")    ; writeValue(buffer, eol=true, project.pixelateWorld)
	insert(buffer, "pixelateTextures") ; writeValue(buffer, eol=true, project.pixelateTextures)
	insert(buffer, "zoom")             ; writeValue(buffer, eol=true, project.zoomLevel)

	insert(buffer, "movement")
	writeValue(buffer, cast(int) project.movementPreset)
	writeValue(buffer, project.movementScaleX)
	writeValue(buffer, project.movementScaleY)
	writeValue(buffer, project.movementSpeed)
	insert(buffer, "\n")

	for system: project.systems {
		insert(buffer, ":system\n")
		insert(buffer, "colors")      ; writeValue(buffer, eol=true, system.colors)
		insert(buffer, "blendMode")   ; writeValue(buffer, eol=true, cast(string) system.blendMode)
		insert(buffer, "texture")     ; writeValue(buffer, eol=true, system.textureName)
		insert(buffer, "texturePath") ; writeValue(buffer, eol=true, system.texturePath)

		local ps = system.particles
		insert(buffer, "bufferSize")       ; writeValue(buffer, eol=true, ps.getBufferSize!())
		insert(buffer, "direction")        ; writeValue(buffer, eol=true, ps.getDirection!())
		insert(buffer, "emissionRate")     ; writeValue(buffer, eol=true, ps.getEmissionRate!())
		insert(buffer, "emitterLifetime")  ; writeValue(buffer, eol=true, (ps.getEmitterLifetime!() <= 0) ? .0 : ps.getEmitterLifetime!())
		insert(buffer, "insertMode")       ; writeValue(buffer, eol=true, cast(string) ps.getInsertMode!())
		insert(buffer, "offset")           ; writeValues(buffer,eol=true, system.offsetX, system.offsetY)
		insert(buffer, "relativeRotation") ; writeValue(buffer, eol=true, ps.hasRelativeRotation!())
		insert(buffer, "sizes")            ; writeValue(buffer, eol=true, {ps.getSizesAsVararg!()})
		insert(buffer, "sizeVariation")    ; writeValue(buffer, eol=true, ps.getSizeVariation!())
		insert(buffer, "spinVariation")    ; writeValue(buffer, eol=true, ps.getSpinVariation!())
		insert(buffer, "spread")           ; writeValue(buffer, eol=true, ps.getSpread!())
		do {
			local min, max = ps.getLinearDamping!()
			insert(buffer, "linearDamping")
			writeValues(buffer, eol=true, min, max)
		}
		do {
			local min, max = ps.getParticleLifetime!()
			insert(buffer, "particleLifetime")
			writeValues(buffer, eol=true, min, max)
		}
		do {
			local min, max = ps.getRadialAcceleration!()
			insert(buffer, "radialAcceleration")
			writeValues(buffer, eol=true, min, max)
		}
		do {
			local min, max = ps.getRotation!()
			insert(buffer, "rotation")
			writeValues(buffer, eol=true, min, max)
		}
		do {
			local min, max = ps.getSpeed!()
			insert(buffer, "speed")
			writeValues(buffer, eol=true, min, max)
		}
		do {
			local min, max = ps.getSpin!()
			insert(buffer, "spin")
			writeValues(buffer, eol=true, min, max)
		}
		do {
			local min, max = ps.getTangentialAcceleration!()
			insert(buffer, "tangentialAcceleration")
			writeValues(buffer, eol=true, min, max)
		}
		do {
			local distribution, dx, dy, angle, relative = ps.getEmissionArea!()
			insert(buffer, "emissionArea")
			writeValue(buffer, cast(string) distribution)
			writeValue(buffer, dx)
			writeValue(buffer, dy)
			writeValue(buffer, angle)
			writeValue(buffer, relative)
			insert(buffer, "\n")
		}
		do {
			local xmin,ymin, xmax,ymax = ps.getLinearAcceleration!()
			insert(buffer, "linearAcceleration")
			writeValue(buffer, xmin)
			writeValue(buffer, ymin)
			writeValue(buffer, xmax)
			writeValue(buffer, ymax)
			insert(buffer, "\n")
		}
	}
}

export saveWorkspace :: () {
	if not workspaceSaveScheduled  return

	-- print("Saving workspace.")

	workspaceSaveScheduled = false
	workspaceSaveDelay     = 0
	workspaceSaveTime      = LT.getTime()

	local projectIndexToSave = 0

	for app.projects  if not it.preview {
		projectIndexToSave += 1
		if itIndex == app.currentProjectIndex  break
	}
	-- Note: projectIndexToSave may be slightly wrong when loaded if the program
	-- exits before closing previews, but that's not the end of the world!

	local buffer: []string
	insert(buffer, format("%d\n", LAST_FILE_VERSION))

	insert(buffer, "stats")               ; writeValue(buffer, eol=true, app.showStats)
	insert(buffer, "showProjectSettings") ; writeValue(buffer, eol=true, app.showProjectSettings)
	insert(buffer, "showPanelNumbers")    ; writeValue(buffer, eol=true, app.showPanelNumbers)
	insert(buffer, "project")             ; writeValue(buffer, eol=true, projectIndexToSave)
	insert(buffer, "recentFiles")         ; writeValue(buffer, eol=true, app.recentFiles)
	insert(buffer, "recentFolders")       ; writeValue(buffer, eol=true, app.recentFolders)
	insert(buffer, "bookmarkedFolders")   ; writeValue(buffer, eol=true, app.bookmarkedFolders)

	for app.projects  if not it.preview {
		writeProject(buffer, it, writePath=true)
	}

	local ok, err = LF.write("workspace", concatinate(buffer))
	if not ok  setErrorText("Could not save workspace: %s", err)
}

export saveProject :: (project:Project, overwrite=false) -> (success:bool, fileExists:bool) {
	local setErrorMessage :: (fileExists:bool, s:string) -> (success:bool, fileExists:bool) {
		setErrorText(s)
		return false, fileExists
	}
	local setErrorMessage :: (fileExists:bool, s:string, v,...:int|float|string) -> (success:bool, fileExists:bool) {
		setErrorText(s, v, ...)
		return false, fileExists
	}

	local ok, dir, filename = matchPattern(project.path, "^(.+)/([^/]+)$")
	if not ok  return setErrorMessage(false, "Invalid path '%s'", project.path)

	ok = connectToRemoteDirectory(cast(string)dir)
	if not ok  return setErrorMessage(false, "Could not access folder '%s'", dir)
	defer disconnectFromRemoteDirectory()

	addRecent(app.recentFolders, normalizeDirectoryPath(cast(string)dir), MAX_RECENT_FOLDERS)

	if not overwrite {
		local info = LF.getInfo(cast(string)filename)
		if info ~= nil  return false, true
	}

	local buffer: []string
	insert(buffer, format("%d\n", LAST_FILE_VERSION))

	writeProject(buffer, project, writePath=false)

	local ^ok, err = LF.write(cast(string)filename, concatinate(buffer))
	if not ok  return setErrorMessage(false, "Could not write project to file: %s", err)

	addRecent(app.recentFiles, project.path, MAX_RECENT_FILES)

	project.fileIsSaved   = true
	project.displayedName = cast(string)filename

	gui.refreshRecursively(guiState, "projects")
	scheduleSaveWorkspace()
	setMessageText("Saved '%s'", project.displayedName)
	return true, false
}



local parsingError :: (path:string, ln:int, s:string, ...:int|float|string) -> (success:bool, gotError:bool, app:App) {
	printf("Error: %s:%d: "..s, path, ln, ...)
	return false, true, NULL
}

local readInt :: (line:string, ptr:int) -> (success:bool, ptr:int, n:int) {
	local found, nStr, _ptr = matchPattern(line, "^ +(%-?%d+)()", ptr)
	if not found  return false, NULL, NULL

	local ok, n = stringToInt(cast(string)nStr)
	if not ok  return false, NULL, NULL

	return true, cast(int)_ptr, n
}
local readFloat :: (line:string, ptr:int) -> (success:bool, ptr:int, n:float) {
	local         found, nStr, _ptr = matchPattern(line, "^ +(%-?%d*%.?%d+[Ee][-+]?%d+)()", ptr)
	if not found  found, nStr, _ptr = matchPattern(line, "^ +(%-?%d*%.?%d+)()",             ptr)
	if not found  return false, NULL, NULL

	local ok, n = stringToFloat(cast(string)nStr)
	if not ok  return false, NULL, NULL

	return true, cast(int)_ptr, n
}

local readBool :: (line:string, ptr:int) -> (success:bool, ptr:int, b:bool) {
	local found, boolStr, _ptr = matchPattern(line, "^ +(%S+)()", ptr)
	if not found  return false, NULL, NULL

	if boolStr == {
		case "true":  return true,  cast(int)_ptr, true
		case "false": return true,  cast(int)_ptr, false
		case:         return false, NULL,          NULL
	}
}

local readString :: (line:string, ptr:int) -> (success:bool, ptr:int, s:string) {
	-- Strings consist of a length (int) and then the actual string.
	local ok, ^ptr, len = readInt(line, ptr)
	if not ok  return false, NULL, NULL

	if line[ptr] ~= !char " "  return false, NULL, NULL
	ptr += 1

	local v = getSubstring(line, ptr, ptr+len-1)
	if #v ~= len  return false, NULL, NULL
	ptr += len

	local gotError = false
	v = replacePatternWithFunction(v, "\\(.)", [gotError] (c:string) -> string|none {
		if c == "n"   return "\n"
		if c == "\\"  return "\\"
		gotError = true
		return nil
	})
	if gotError  return false, NULL, NULL

	return true, ptr, v
}

local readFloatArray :: (line:string, ptr:int) -> (success:bool, ptr:int, arr:[]float) {
	local arr: []float

	while ptr <= #line {
		local ok, _ptr, n = readFloat(line, ptr)
		if not ok  return false, NULL, NULL

		ptr = cast(int) _ptr
		insert(arr, n)
	}

	return true, ptr, arr
}
local readStringArray :: (line:string, ptr:int) -> (success:bool, ptr:int, arr:[]string) {
	local arr: []string

	while ptr <= #line {
		local ok, _ptr, n = readString(line, ptr)
		if not ok  return false, NULL, NULL

		ptr = cast(int) _ptr
		insert(arr, n)
	}

	return true, ptr, arr
}

export loadWorkspace :: (path:string) -> (success:bool, gotError:bool, app:App) {
	local file, err = LF.newFile(path, LF.FileMode.READ)
	if file == NULL  return false, false, NULL

	local app: App !shadow
	local projects = app.projects

	do {
		local project: Project = NULL
		local system:  System  = NULL

		local ps: LG.ParticleSystem = NULL

		local ln   = 0
		local iter = (cast(LF.File)file).lines!()

		local version: int
		do {
			local line1 = iter(nil, nil)
			if line1 == nil  return parsingError(path, ln, "Missing file version.")

			local ok, ^version = stringToInt(cast(string) line1)
			if not ok                       return parsingError(path, ln, "Invalid version line format.")
			if version < 1                  return parsingError(path, ln, "Invalid version number '%d'.", version)
			if version > LAST_FILE_VERSION  return parsingError(path, ln, "Unsupported version number '%d'.", version)
		}

		for line in iter, nil, nil {
			ln += 1
			if line == ""  continue

			if line[1] == !char ":" {
				local label = getSubstring(line, 2)

				if label == {
					case "project":
						project = Project()
						system  = NULL
						insert(projects, project)

					case "system":
						if project == NULL  return parsingError(path, ln, "Unexpected 'system' label.")
						system = System()
						ps     = system.particles
						insert(project.systems, system)

					case:
						return parsingError(path, ln, "Unknown label '%s'.", label)
				}

				continue
			}

			local ok, param, ptr = matchPattern(line, "(%S+)()")
			if not ok  return parsingError(path, ln, "Bad parameter line format: %s", line)

			if project == NULL {
				if param == {
					case "stats":
						local ^ok, ^ptr, flag = readBool(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.showStats = flag
					case "showProjectSettings":
						local ^ok, ^ptr, flag = readBool(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.showProjectSettings = flag
					case "showPanelNumbers":
						local ^ok, ^ptr, flag = readBool(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.showPanelNumbers = flag

					case "project":
						local ^ok, ^ptr, i = readInt(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.currentProjectIndex = i

					case "recentFiles":
						local ^ok, ^ptr, paths = readStringArray(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.recentFiles = paths
					case "recentFolders":
						local ^ok, ^ptr, paths = readStringArray(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.recentFolders = paths

					case "bookmarkedFolders":
						local ^ok, ^ptr, paths = readStringArray(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						app.bookmarkedFolders = paths

					case:
						return parsingError(path, ln, "Unknown program parameter '%s'.", param)
				}

			} elseif system == NULL {
				if param == {
					case "path":
						local ^ok, ^ptr, savedPath = readString(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)

						project.path        = savedPath
						project.fileIsSaved = true

						local found, filename = matchPattern(savedPath, "[^/]+$")
						if found  project.displayedName = cast(string)filename

					case "bgColor":
						local ^ok, ^ptr, h = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, s = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, v = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						if version < 2  h, s, v = rgbToHsv(h, s, v)
						project.bgColorH = h
						project.bgColorS = s
						project.bgColorV = v

					case "bgChecker":
						local ^ok, ^ptr, amount = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.bgChecker = amount

					case "pixelateWorld":
						local ^ok, ^ptr, flag = readBool(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.pixelateWorld = flag
					case "pixelateTextures":
						local ^ok, ^ptr, flag = readBool(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.pixelateTextures = flag

					case "zoom":
						local ^ok, ^ptr, zoomLevel = readInt(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.zoomLevel  = zoomLevel
						project.zoom       = 2^zoomLevel
						project.zoomSource = project.zoom
						project.zoomTarget = project.zoom

					case "movement":
						local ^ok, ^ptr, preset = readInt  (line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, sx     = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, sy     = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, speed  = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						project.movementPreset = cast(Movement) preset -- @Robustness: Validate enum value.
						project.movementScaleX = sx
						project.movementScaleY = sy
						project.movementSpeed  = speed

					case:
						return parsingError(path, ln, "Unknown project parameter '%s'.", param)
				}

			} else {
				if param == {
					case "colors":
						local ^ok, ^ptr, colors = readFloatArray(line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if #colors % 4   ~= 0     return parsingError(path, ln, "Bad color array format: %s", line)
						if colors[1]     == NULL  return parsingError(path, ln, "No colors.")
						if colors[8*4+1] ~= NULL  return parsingError(path, ln, "Too many colors. (Max is 8, got %d)", #colors // 4)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						if version < 2 {
							for i = 1, #colors, 4 {
								colors[i], colors[i+1], colors[i+2] = rgbToHsv(colors[i], colors[i+1], colors[i+2])
							}
						}
						system.colors = colors

					case "blendMode":
						local ^ok, ^ptr, blendMode = readString(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.blendMode = cast(LG.BlendMode) blendMode -- @Robustness: Validate enum value.

					case "texture":
						local ^ok, ^ptr, textureName = readString(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.textureName = textureName

					case "texturePath":
						local ^ok, ^ptr, texturePath = readString(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.texturePath = texturePath

					case "bufferSize":
						local ^ok, ^ptr, size = readInt(line, cast(int)ptr)  if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setBufferSize!(size)

					case "direction":
						local ^ok, ^ptr, dir = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setDirection!(dir)

					case "emissionRate":
						local ^ok, ^ptr, rate = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setEmissionRate!(rate)

					case "emitterLifetime":
						local ^ok, ^ptr, lifetime = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setEmitterLifetime!(lifetime <= 0 ? -1.0 : lifetime)

					case "insertMode":
						local ^ok, ^ptr, mode = readString(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setInsertMode!(cast(LG.ParticleInsertMode) mode) -- @Robustness: Validate enum value.

					case "relativeRotation":
						local ^ok, ^ptr, relative = readBool(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setRelativeRotation!(relative)

					case "sizes":
						local ^ok, ^ptr, sizes = readFloatArray(line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if sizes[1]   == NULL     return parsingError(path, ln, "No sizes.")
						if sizes[8+1] ~= NULL     return parsingError(path, ln, "Too many sizes. (Max is 8, got %d)", #sizes)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setSizes!(sizes)

					case "sizeVariation":
						local ^ok, ^ptr, variation = readFloat(line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setSizeVariation!(variation)

					case "spinVariation":
						local ^ok, ^ptr, variation = readFloat(line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setSpinVariation!(variation)

					case "spread":
						local ^ok, ^ptr, spread = readFloat(line, cast(int)ptr)
						if not ok                 return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setSpread!(spread)

					case "linearDamping":
						local ^ok, ^ptr, min = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setLinearDamping!(min, max)

					case "particleLifetime":
						local ^ok, ^ptr, min = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setParticleLifetime!(min, max)

					case "radialAcceleration":
						local ^ok, ^ptr, min = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setRadialAcceleration!(min, max)

					case "rotation":
						local ^ok, ^ptr, min = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setRotation!(min, max)

					case "speed":
						local ^ok, ^ptr, min = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setSpeed!(min, max)

					case "spin":
						local ^ok, ^ptr, min = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setSpin!(min, max)

					case "tangentialAcceleration":
						local ^ok, ^ptr, min = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, max = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setTangentialAcceleration!(min, max)

					case "offset":
						local ^ok, ^ptr, x = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, y = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						system.offsetX = x
						system.offsetY = y

					case "emissionArea":
						local ^ok, ^ptr, distribution = readString(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, dx           = readFloat (line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, dy           = readFloat (line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, angle        = readFloat (line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, relative     = readBool  (line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setEmissionArea!(cast(LG.AreaSpreadDistribution)distribution, dx, dy, angle, relative) -- @Robustness: Validate enum value.

					case "linearAcceleration":
						local ^ok, ^ptr, xmin = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, ymin = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, xmax = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						local ^ok, ^ptr, ymax = readFloat(line, cast(int)ptr) ; if not ok  return parsingError(path, ln, "Bad value format: %s", line)
						if cast(int)ptr <= #line  return parsingError(path, ln, "Garbage after values: %s", line)
						ps.setLinearAcceleration!(xmin,ymin, xmax,ymax)

					case:
						return parsingError(path, ln, "Unknown project parameter '%s'.", param)
				}
			}
		}

		if not projects  return parsingError(path, ln, "No projects.")
	}

	for project: projects {
		if not project.systems  return parsingError(path, 0, "Missing systems for at least one project.")
	}

	return true, false, app
}


